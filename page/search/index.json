[{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://demo.stack.jimmycai.com/post/hello-world/cover_hu_9e6bcf9cfe9a9448.jpg","permalink":"https://demo.stack.jimmycai.com/post/hello-world/","title":"Hello World"},{"content":"摘自：http://ijs.cass.cn/xsyj/bkwz/202406/t20240607_5757785.shtml\n日本深观察丨大国竞争下日本企业应对“失去的三十年”的经验及启示\n作者：闫坤 肖宇 来源：中国经济时报 时间：2024-06-07\n“失去的三十年”指的是日本经济增速低迷的平成时代（1989年—2019年）。日本社会开始进入结构性萧条，在美国“不许超越”的持续打压之下，日本出口立国模式崩溃。1985年《广场协议》签订之后，日本政府试图在确保国内物价稳定的基础上，让本国经济转向内需主导型来扭转总需求不足的颓势。在此期间，日本房地产泡沫破灭、金融机构不良债权增加令日本政府自顾不暇。面对中国等新兴经济体的劳动力成本优势，日本企业不得不同时面对通货紧缩和制造业比较优势丧失的挑战。日企在此期间的应对措施，值得我们研究借鉴。\n一、“失去的三十年”日企面临的生存环境\n在1960年—1989年日本经济的高速增长期，依托低利率的资金配给以及有计划的政策性投融资支持，日本社会的基础设施实现了跨越式发展。同时，依托日元升值和日本独特的企业与工会缔结的工资协定（工会主动控制工资上涨），日本成功度过了上世纪80年代的石油危机。日本的汽车和半导体制造超过美国，日本制造席卷美国市场，这导致了很大一部分日本企业形成了路径依赖，从而丧失了在即将到来的危机中求得转机的宝贵机会。\n（一）人口减少引发日本社会总需求结构的巨大变化\n日本社会生育率一直不高。社会生育率的下降、人口自然增长率的减少和人口老龄化的增加导致日本社会的总需求曲线发生了永久性左移。资产泡沫破灭导致居民收入减少，对未来的收入增长预期普遍悲观（日本内阁府公布的以收入增长为标准衡量的消费者信心指数显示，1989年为50.7，1999年为40.9，2009年为36.1）。内需萎靡，企业销售收入开始锐减。内需的减少叠加日元升值，使得日本企业开始普遍步入需求不足的困境，大量日本企业在“大水大鱼”时代所熟悉的商业模式难以为继。\n（二）房地产泡沫破灭导致日企的资产负债表普遍受损\n为刺激经济增长，日本央行从1992年开始实施“零利率”。但极低的利率也没能促进日本企业扩大再生产。原因在于，日本企业在泡沫期大举借贷，大肆进行房地产等固定资产投资、参与股票投机，随着房地产和股票市场的下跌，资产价格缩水导致了企业的资产负债表大幅衰退。为了修复资产负债表，这些企业不得不将从银行新获得的贷款用于还贷，而这种个体的占优策略最终演化成了“合成谬误”，加剧了日本企业经营目标从“利润最大化”向“负债最小化”转化，最终形成了一个不断循环的负反馈。\n（三）汇率贬值影响日本制造业企业参与全球水平分工\n上世纪90年代，IT革命和互联网大幅降低了信息处理的成本和通信成本，距离对经济活动的限制越来越小，一些美国企业开始将服务外包向印度和爱尔兰等国家转移，这推动了全球制造业从垂直一体化走向水平式分工。然而，在日元贬值的大背景下，日本企业为了控制成本，不得不收缩生产线、在日本国内增设工厂，将生产制造环节向国内转移。这方面的典型例子是日本的夏普公司（生产电器和电子产品）和美国的苹果公司。苹果公司采用水平一体化，将制造环节外包给中国的富士康公司，自己只保留设计、营销、物流和品牌管理。这一生产组织方式所带来的最终结果是，2016年4月，夏普被中国富士康母公司鸿海精密吞并，而苹果公司却一度跃升至全球市值最高的企业。\n二、日本企业应对“失去的三十年”的经验\n虽然在此期间，日本企业普遍面临着较为不利的生产经营环境，但也有部分企业依托提升核心竞争力，不断适应变化了的市场需求，从而成功地化危为机。\n（一）及时调整策略适应居民消费趋势性变化\n对于“失去的三十年”来说，日本面临的整体趋势是日益来临的老龄化社会和整体人口规模不断减少带来的消费萎缩，这使得日本社会的消费曲线发生了永久性左移。在这一趋势性变化下，日本居民的消费观念和消费需求趋向于回归理性，更加注重产品的实用舒适与物美价廉。在此期间，零售业态中的百元店（Daiso—大创、Seria、Cando、Watts）、软折扣店以及一些淡化品牌概念但更重视简洁实用的休闲服饰（优衣库）、家居用品（宜得利）、食药产品（松本清）、化妆品等性价比较高的新型商业模式得到了日本消费者的认可并取得了巨大成功。\n（二）在资源约束中寻找并形成新的比较优势\n面对经济全球化分工的转变，日本制造业企业开始向技术含量和产品附加值高的精密机械、高端电子零部件、半导体设备、存储/逻辑芯片制造、高机能材料等行业发展。以三井财团的东芝和索尼等为代表的制造业企业基于危机感的“自我升级”一直都没有停止，“日本制造”及“日本设计”逐步摆脱了“山寨”恶名，获得了世界级的信誉。其中的佼佼者还有三菱重工、富士重工、丰田汽车公司、本田技研工业株式会社等。这些经验可以总结为：在战略层面，跟踪国际科技前沿，学习世界先进技术，高度重视工程师培育；在战术层面，推广以“精益生产”为典型的先进制造模式。\n（三）紧密围绕全球产业链演进的趋势进行发力\n虽然日本对当时经济全球化趋势演进的方向作出了错误的整体判断，但反应过来的部分日本企业迅速认识到了这一全球分工体系的核心本质，将制造业的服务化和服务型制造作为主攻的方向，并取得了不俗的业绩。这一领域的代表性企业是基恩士。这家1974年在日本创立的小企业，自诞生以来，依靠提供能够改善自动化制造质量与效率的解决方案，迅速在全球建成了高效的服务网络，为世界各地的从“财富500强”制造商到小供应商提供传感器、测量仪、数据采集仪、测量系统、视觉系统、控制系统等软硬件产品，覆盖汽车、半导体、电子元件、医疗、物流、商品药品等多个行业。整体来看，日本企业迅速通过制造业服务化和服务型制造补上了起跑的短板，诞生了一批具有国际竞争力的全球性企业。\n（四）依托对外投资提高产业链和供应链韧性\n资源约束一直是日本企业发展过程中面临的最硬性约束。《广场协议》签订后，为应对贸易冲击，日本政府推出“黑字环流”计划，核心目标是通过政府援助、商业贷款等手段，将日本的国际贸易盈余、外汇储备和国内私人资本流向发展中国家的能源和原材料行业。这标志着日本从“贸易立国”开始向“对外投资立国”转变。在此期间，以索尼、本田等为代表的日本企业海外收入占比已经在总收入中的占比超过了半壁江山。日本企业“出海”分为两类，一是以降低制造成本为目的的“垂直直接投资”，即产业链外迁；二是以获取需求为目标的“水平直接投资”，即海外市场扩张。\n（五）小企业坚持走专业化和“隐形冠军”道路\n随着日本经济进入下行周期，大量日本中小企业开始面临较大的生存压力，市场份额迅速向头部企业集中。通过聚焦赛道、走专业化和精细化等“专精特新”道路，日本中小企业在国民经济的各个行业都诞生了一批“隐形冠军”。以制造业领域的碳纤维为例，在小丝束碳纤维市场上，东丽、帝人（东邦母公司）和三菱合计占据全球49%的市场份额；在半导体芯片领域，成就了信越化学、SUMCO、住友电木、日立化学和京瓷化学等众多公司。在服务业领域，日本知名游戏企业任天堂，从一家做游戏纸牌的小企业发展成为全球电子游戏行业巨头。这些企业之所以能够成功，一个重要原因在于他们都非常专注于所在赛道，通过创新和下大力气攻克核心技术形成了独一无二的产品优势。\n三、对我国的政策启示\n一是要妥善应对当前房地产市场的新局面。大环境是企业生存的土壤，房地产具有财政和产业链带动性强的双重属性，房地产市场的下行将会传导到企业的需求端。因此，必须要守住房地产市场不发生系统性风险的底线，把解决烂尾楼等保交楼、保民生和保稳定工作以及妥善处置房企风险纳入地方政府考核。加大保障房建设力度，出台措施为二手房流动提供便利，逐步扩大租售同权适用范围。引导房企走高质量发展道路，鼓励房企推出高品质的产品和服务，满足群众多样化的住房需求。\n二是为市场主体提供良好和稳定的融资环境。一方面，要稳妥推进资本账户开放，为国内货币政策的独立性创造条件，大幅降低企业的负债成本，把资金“赶上”实体经济，助力企业尽快走出“创伤期”。另一方面，要确保汇率不发生大的波动，稳步深化汇率市场化改革，完善以市场供求为基础、参考一篮子货币进行调节、有管理的浮动汇率制度。为中资企业走出去和外资企业进入中国市场提供稳定的汇率预期。\n三是引导企业把创新摆在经营的核心位置。鼓励企业要加强对市场需求的研判，及时调整产品和服务的定价策略，通过技术创新和商业模式创新，适应不断变化的市场环境，掌握未来发展的主动权。围绕“卡脖子”技术和关键核心领域，形成一批走差异化和专业化路线的“专精特新”企业，推动中国经济新质生产力全面成型。\n（闫坤系中国社会科学院日本研究所党委书记、副所长、研究员；肖宇系中国社会科学院亚太与全球战略研究院副研究员）\n","date":"2026-01-28T16:29:52+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E6%97%A5%E6%9C%AC%E6%B7%B1%E8%A7%82%E5%AF%9F%E4%B8%A8%E5%A4%A7%E5%9B%BD%E7%AB%9E%E4%BA%89%E4%B8%8B%E6%97%A5%E6%9C%AC%E4%BC%81%E4%B8%9A%E5%BA%94%E5%AF%B9%E5%A4%B1%E5%8E%BB%E7%9A%84%E4%B8%89%E5%8D%81%E5%B9%B4%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%90%AF%E7%A4%BA/","title":"日本深观察丨大国竞争下日本企业应对“失去的三十年”的经验及启示"},{"content":"既然考向转到了纯证明，那我们就换个打法。不要晕，数理方程的证明题其实比计算题更死板，因为起手式（First Step）通常只有两三种。\n只要你能判断出题目属于哪一类，直接套用对应的“公式模板”就能拿下一半的分数。\n为了帮你治好“晕晕的”感觉，我把这些考点重新归纳为三大核心证明体系。你只要记住：看见什么词，就用什么工具。\n体系一：看见“唯一性”或“能量”，用【格林第一公式】 这是考频最高的证明题。只要题目让你证“解是唯一的”，或者涉及“能量积分”，绝对是这个路子。\n核心工具：格林第一公式 $$ \\int_V (\\nabla u)^2 dV + \\int_V u \\nabla^2 u dV = \\oint_S u \\frac{\\partial u}{\\partial n} dS $$ （物理意义：总能量 = 内部势能 + 边界做功）\n经典考题1：证明第一类边值问题（Dirichlet）解的唯一性 题目：已知 $\\nabla^2 u = f$，且 $u|_S = \\phi$，证明解 $u$ 唯一。\n【套路式证明】：\n构造差函数：假设有两个解 $u_1, u_2$。令 $w = u_1 - u_2$。 找 $w$ 的方程： $\\nabla^2 w = \\nabla^2 u_1 - \\nabla^2 u_2 = f - f = 0$ （内部调和）。 $w|_S = u_1|_S - u_2|_S = \\phi - \\phi = 0$ （边界为0）。 套公式（起手式）：对 $w$ 使用格林第一公式： $$ \\int_V (\\nabla w)^2 dV + \\int_V w \\underbrace{\\nabla^2 w}_{0} dV = \\oint_S \\underbrace{w}_{0} \\frac{\\partial w}{\\partial n} dS $$ 推导： 中间项含 $\\nabla^2 w = 0$，右边项含 $w|_S = 0$。 于是剩下：$\\int_V (\\nabla w)^2 dV = 0$。 结论： 因为 $(\\nabla w)^2 \\ge 0$，积分要为0，被积函数必须恒为0。 $\\implies \\nabla w = 0 \\implies w = C$（常数）。 又因为边界上 $w=0$，所以 $C=0$。 $\\implies u_1 \\equiv u_2$，唯一性得证。 体系二：看见“对称性”或“表达式”，用【格林第二公式】 只要题目让你证 $G(x, \\xi) = G(\\xi, x)$，或者让你推导解的积分公式，那就是这一套。\n核心工具：格林第二公式 $$ \\int_V (u \\nabla^2 v - v \\nabla^2 u) dV = \\oint_S (u \\frac{\\partial v}{\\partial n} - v \\frac{\\partial u}{\\partial n}) dS $$经典考题2：证明格林函数的对称性 题目：证明 $G(M_1, M_2) = G(M_2, M_1)$。\n【套路式证明】：\n设函数：令 $u = G(M, M_1)$， $v = G(M, M_2)$。 列方程： $\\nabla^2 u = \\delta(M - M_1)$ $\\nabla^2 v = \\delta(M - M_2)$ 边界上 $u|_S = 0, v|_S = 0$。 套公式（起手式）：把 $u, v$ 代入格林第二公式。 消边界： 因为边界上 $u=0, v=0$，所以公式右边的面积分 $\\oint (\u0026hellip;) dS = 0$。 筛选性质： 左边体积分变为： $$ \\int_V [G(M, M_1)\\delta(M - M_2) - G(M, M_2)\\delta(M - M_1)] dV_M = 0 $$ 利用 $\\delta$ 函数的“筛选性质”（积哪里就在哪里取值）： $$ G(M_2, M_1) - G(M_1, M_2) = 0 $$ $$ \\implies G(M_2, M_1) = G(M_1, M_2) $$，得证。 体系三：看见“最大值”、“比较”或“平均值”，用【调和函数性质】 这类证明题比较抽象，通常不涉及积分公式的运算，而是逻辑推理。\n核心逻辑链： 平均值公式 $\\to$ 极大值原理 $\\to$ 比较原理 $\\to$ 唯一性\n经典考题3：证明平均值公式（Mean Value Theorem） 题目：证明调和函数球心值等于球面平均值。 证明思路： 对 $\\nabla^2 u = 0$ 在小球内用格林第二公式，取辅助函数 $v = 1/r$。这其实就是求解公式的特例，推导过程即“挖洞法”。\n经典考题4：证明极大值原理（Maximum Principle） 题目：证明调和函数 $u$ 若不为常数，最大值必在边界取到。 【套路式证明（反证法）】：\n假设内部某点 $M_0$ 是最大值点。 用平均值公式：$u(M_0)$ 等于它周围一个小球面上所有值的平均。 找矛盾：既然 $M_0$ 是最大值，球面上所有点都不能比它大。如果球面上有点比它小，平均值就会小于 $u(M_0)$，矛盾。所以球面上所有点必须等于 $u(M_0)$。 扩散：一圈圈推出去，整个区域都得等于 $u(M_0)$，即 $u$ 是常数。 结论：如果 $u$ 不是常数，最大值不能在内部。 经典考题5：证明比较原理（Comparison Principle） 题目：若在区域内 $\\nabla^2 u = \\nabla^2 v$，且边界上 $u|_S \\ge v|_S$，证明在区域内部 $u \\ge v$。\n【套路式证明】：\n构造差函数：令 $w = v - u$。 验证调和：$\\nabla^2 w = 0$。 看边界：因为 $u \\ge v$，所以 $w|_S \\le 0$。即边界上最大值也是 0（或者负数）。 用极大值原理：调和函数的最大值必须在边界取到。 既然边界上最大是 0，那么内部所有点都必须 $\\le 0$。 结论：$w \\le 0 \\implies v \\le u$，得证。 总结：考场救命“小抄”（脑图） 拿到一道证明题，先看关键词，决定用哪把“刀”：\n关键词：$\\int (\\nabla u)^2$、能量、唯一性\n$\\to$ 格林第一公式（令 $w=u_1-u_2$，利用 $(\\nabla w)^2 \\ge 0$）。 关键词：对称性、互换、积分表达式\n$\\to$ 格林第二公式（令 $u=G_1, v=G_2$，利用边界为0消项）。 关键词：大小关系、不等式 ($u \\ge v$)、有界性\n$\\to$ 极大值/比较原理（构造差函数，看边界最值）。 关键词：球心值、平均\n$\\to$ 平均值公式。 如果不确定用哪个？ 优先默写格林第二公式。在数理方程这一章，它是万法之源。只要写出公式，说明其中一项（如 $\\nabla^2 u$ 或边界积分）为 0，老师通常都会给步骤分。\n","date":"2026-01-13T22:43:40+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E6%95%B0%E7%90%86%E6%96%B9%E7%A8%8B%E6%A0%BC%E6%9E%97%E5%87%BD%E6%95%B0%E8%AF%81%E6%98%8E%E9%A2%98/","title":"数理方程格林函数证明题"},{"content":"我按你这份框架里强调的主线来“出题覆盖”：分离变量法→施图姆-刘维尔→级数解；非齐次方程拆分+固有函数法；非齐次边界用辅助函数化齐次；二维拉普拉斯/泊松按区域选坐标与拆分思路；格林函数与其性质；贝塞尔与傅里叶-贝塞尔级数。\n下面只提问、不提供答案。你可以用法：每题先说“用什么方法/为什么”，再写关键一步公式（例如分离常数、展开系数、边界条件如何给特征值），最后检查“边界/初值是否满足、物理/极限是否合理”。\n1 方法选择与总框架（先把“选路”练到秒出） 给定一维波动/热方程定解问题，你如何用“方程是否齐次、边界是否齐次、初值是否齐次”来秒判：分离变量 / 固有函数 / 辅助函数？ “有界区域”与“无界区域”在方法选择上最大的分水岭是什么？（你会优先想到哪两类工具？） 同一个问题，你能给出至少两条可行求解路线吗？各自的优缺点是什么（可计算性、表达式复杂度、适用性）？ 你如何判断一个边值问题“只有在区域很规则时才能分离变量”？你对“规则”的可操作判据是什么？ 做完任何 PDE 题，你会用哪 3 个“自检项”来避免低级错（比如系数、正交性、端点条件、零均值等）？ 2 分离变量法（从“会做”到“知道为什么这样做”） 2.1 基本结构与分离常数 你把 (u(x,t)=X(x)T(t)) 代回 PDE 后，为什么能得到“一个只含 x，一个只含 t”的常微分方程？你用到的逻辑是什么？ 分离常数取 (\\lambda) 还是 (-\\lambda) 的选择，背后是为了什么（与边界条件/特征值符号的关系）？ 对波动方程与热方程，分离后时间方程的通解结构分别是什么？在什么情况下会出现指数衰减/简谐振动/双曲函数？ 哪一步开始“必须使用齐次边界条件”？如果边界不是齐次，会在这里卡住在哪里？ 2.2 施图姆–刘维尔问题（你必须能口述出来） 你能把“利用齐次边界条件求施图姆–刘维尔问题”这句话展开成：未知量是什么？求什么？输出是什么？ 为什么要求“非零解”？如果允许零解会发生什么？ 特征值为什么通常是离散的？（你能从边界条件“钉住”解的角度解释吗？） 你如何证明不同特征值对应的特征函数正交？证明里最关键的“减法+积分+分部”一步是什么？ 什么时候会得到正弦系，什么时候是余弦系，什么时候是 (\\sin((2n-1)\\cdot)) 这种“半波”结构？ 若边界是 (X(0)=0, X(l)=0)，你能写出特征值 (\\lambda_n) 的形式与特征函数族吗？ 若边界是 (X\u0026rsquo;(0)=0, X\u0026rsquo;(l)=0)，与上题相比哪里变了？为什么会出现 (n=0) 项？ 混合边界（如 (X(0)=0, X\u0026rsquo;(l)=0)）的特征值为何会变成“半整数”结构？你能推导出量化条件吗？ 2.3 级数解与系数（把“套公式”变成“能解释每个符号”） 为什么最终解写成 (\\sum_n X_n(x)T_n(t)) 的线性叠加是合理的？你用到 PDE 的哪个性质？ 初位移 (\\varphi(x))、初速度 (\\psi(x)) 分别决定了系数的哪一部分？为什么一个对应“余弦项系数”，另一个对应“正弦项系数”？ 在波动方程中，如果 (\\psi(x)=0) 会消掉哪些时间项？你能从物理解释吗？ 热方程中为什么不存在“振荡项”，而是“指数衰减模态”？对应的能量/最大值原理直觉是什么？ 你如何判断傅里叶级数该用正弦、余弦还是混合？只看边界条件够吗？初值的延拓（奇/偶）在你脑子里是什么图像？ 3 固有函数法（处理非齐次项：你要能把“比较系数”做熟） 3.1 结构性提问（按你框架的步骤来） 你能完整复述固有函数法 4 步吗？每一步的“输入/输出”是什么？ 为什么要把解按固有函数展开？这相当于在做什么“坐标变换/投影”？ “自由项也按固有函数系展开”的必要性是什么？如果不展开会卡在哪？ 代入 PDE 后“比较待定系数”得到的常微分方程，一般是什么类型（对波动/热分别是什么）？ 初值条件如何变成每个模态 (u_n(t)) 的附加条件？这一步最容易错在哪里？ 为什么在泊松方程场景下，你的框架特别提醒“需借助有界性和边界条件”？这句话具体防的是什么坑？ 3.2 非齐次方程拆分 当边界齐次、方程/初值非齐次时，为什么要把原问题拆成“齐次方程+原初值”和“非齐次方程+齐次初值”两部分？ 这两部分分别适合用什么方法？为什么不是反过来？ 这种拆分的“线性叠加”成立的前提条件是什么？（线性/齐次/边界匹配等） 4 非齐次边界与辅助函数（你要把“构造 w(x,t)”变成条件反射） 为什么边界非齐次时“必须引进辅助函数把边界化齐次”？如果不化齐次，分离变量会在哪一步失败？ 你如何系统构造 (w(x,t)) 使得 (u=v+w) 后，(v) 满足齐次边界？（把“满足边界条件”当作线性代数方程去解） 对 Dirichlet-Dirichlet：(u(0,t)=u_1(t), u(l,t)=u_2(t))，你能构造一个最简单的 (w) 吗？它为什么通常取“关于 x 的线性函数”？ 混合边界（Dirichlet-Neumann、Neumann-Dirichlet、Neumann-Neumann）分别怎么构造 (w)？你能说出每种构造的思路而不背公式吗？ 引入 (w) 之后，新的 PDE 对 (v) 的右端项如何变化？你如何避免漏掉 (w_t,w_{tt},w_{xx}) 这些项？ (w) 的选取不唯一：你能举例说明“选得不同会导致计算复杂度不同”，但最终 (u) 不变的原因是什么？ 5 二维拉普拉斯/泊松：坐标、分离与拆分 5.1 二维拉普拉斯边值问题 面对一个二维区域，你如何决定用直角坐标还是极坐标？你的判断标准是什么？ 为什么“在该坐标系中边界条件表达最简单”是第一优先级？你能举一个边界在直角坐标很复杂、换极坐标就简单的例子吗？ 在矩形域上做分离变量，为什么通常得到 (X\u0026rsquo;\u0026rsquo;+\\lambda X=0, Y\u0026rsquo;\u0026rsquo;-\\lambda Y=0) 这类“一个振荡一个指数”的组合？ 你如何利用边界条件决定是用 (\\sin) 还是 (\\cos) 的 x-方向基？ 对“带形区域/半无限带形”，分离后哪一个方向会出现连续谱？你会怎么处理（积分表示/变换）？ 5.2 二维泊松方程（你的框架给了两种思路） 思路1：为什么要先找一个特解 (w)，再令 (u=v+w) 把泊松化成拉普拉斯？这相当于在做什么“降阶/消源”？ 你通常怎么找特解 (w)？（试探法：多项式/对称性/只依赖 r 等） 思路2：把解看成两部分 (u=v+w)，并让 (v,w) 分别满足不同方程与边界：你能解释这样分配的自由度在哪里吗？ 当 (F(r,\\theta)) 具有某种正交展开形式时，你会倾向用“固有函数法”还是“先找特解”？为什么？ 6 无界区域的波动：达朗贝尔与泊松公式（把“影响域/特征线”讲清） 无限长弦自由振动：你能从 (u_{tt}=a^2u_{xx}) 推出通解 (u=f(x-at)+g(x+at)) 的逻辑主线吗？ 给定初值 (\\varphi,\\psi)，你如何确定 (f,g)？你最怕漏掉哪个积分常数/系数？ 你能解释达朗贝尔公式体现的“有限传播速度”和“影响域”吗？（点 ((x,t)) 只依赖区间 ([x-at,x+at])） 无限长弦强迫振动：外力项 (f(x,t)) 会如何进入积分表达式？你能解释“时空卷积/锥域积分”的几何意义吗？ 二维/三维波动初值问题的泊松公式：积分是在“圆/球面”上还是“圆盘/球体”上？对应的几何对象是什么？（若你想严格对应推导，可用你课本/讲义再核对） 7 积分变换：傅里叶/拉普拉斯（你要能把每条性质当工具用） 7.1 定义与适用条件 什么时候优先用傅里叶变换，什么时候优先用拉普拉斯变换？（自变量是 x 还是 t、定义域是 (\\mathbb R) 还是 (t\\ge0)） “在无穷远处为 0/可积/可变换”的技术条件你通常怎么检查？如果不满足你会怎么补救（广义函数/分段/引入衰减因子）？ 7.2 性质（请你每条都能举一个“用它解 PDE 的场景”） 线性性质：你在拆分问题时如何用它？ 微分定理：为什么傅里叶变换把导数变成乘 (i\\lambda)，这对解常系数 PDE 有什么致命好处？ 拉普拉斯的微分定理里为什么会出现初值项 (f(0),f\u0026rsquo;(0))？这对初值问题意味着什么？ 卷积定理：你能把“乘积↔卷积”在物理上解释成“系统响应/格林函数”吗？ 频移/位移定理与延迟定理：它们分别对应“自变量平移”和“乘指数”哪个？你能写出从一个已知变换快速得到另一个的操作步骤吗？ 你如何用拉普拉斯变换处理含 (\\delta(t)) 的激励？（别算，只讲流程和关键点） 你见到 (e^{-at}\\sin bt) 这类函数时，如何不查表快速写出拉普拉斯变换的结构？ 7.3 变换法解 PDE 的套路题（只说你会怎么做） 半无限域热方程（(x\u0026gt;0,t\u0026gt;0)）给定边界/初值：你会对哪个变量做哪个变换？为什么？ 全空间波动/热方程给定初值：你会对 x 做傅里叶、对 t 解 ODE；还是反过来？选择依据是什么？ 遇到“卷积型解表达式”，你如何从变换域解释它来自哪里（格林函数/基本解）？ 8 格林公式、基本解与格林函数（你要把“唯一性→表示公式→具体域构造”串起来） 8.1 基本解与格林第二公式 二维/三维拉普拉斯方程基本解分别是什么形式？它们的奇性（(\\ln r) vs (1/r)）为何不同？ 你能口述格林第二公式（空间/平面）里每一项的含义吗？哪些项来自分部积分？ 从格林第二公式到“调和函数积分表示式”，中间关键一步是什么（选 (v) 为基本解/格林函数）？ 8.2 调和函数性质与唯一性 你能用极值原理解释“调和函数的最大最小只能在边界取到”吗？ 平均值定理的几何意义是什么？它如何帮助你做“合理性检查”？ 比较原理如何推出解的唯一性？你能把逻辑链写成 3 句“如果…那么…”吗？ 8.3 格林函数的性质与构造 格林函数需要满足哪两类条件（域内方程 + 边界条件）？ “除去源点外满足拉普拉斯方程、在源点发散”的意义是什么？它与 (\\delta) 源如何对应？ 对称性 (G(M_1,M_2)=G(M_2,M_1)) 一般怎么证明？你需要什么前提（边界条件类型、算子自伴）？ 性质5（法向导数积分给常数）在你框架里是怎么用“唯一性+取 (u\\equiv1)”证明的？请你复述证明结构。 上半空间的格林函数为什么可以用“镜像法”构造？镜像点放哪？为什么边界上会抵消到 0？ 圆域/球域格林函数中为什么会出现 (R^2/r) 这种“反演”结构？它在几何上意味着什么？ 你能从格林函数写出狄利克雷问题的解表示，并解释每个符号（积分域、法向、核）代表什么吗？ 泊松公式（圆/球）与格林函数表示式之间是什么关系？你能说出“核函数”是如何由 (\\partial G/\\partial n) 得到的吗？ 9 贝塞尔方程与傅里叶-贝塞尔级数（极坐标分离的核心） 你在极坐标分离变量时，径向方程为什么会变成贝塞尔方程？其中 (n) 从哪里来（角向量化）？ 第一类贝塞尔 (J_n) 与第二类 (Y_n) 的差别是什么？为什么在“有界区域/原点可积”时通常舍去 (Y_n)？（说出你依赖的判据） 你能写出贝塞尔方程通解结构，并说明常数由什么边界条件决定吗？ 递推公式是怎么来的（从微分方程推、还是从生成函数/分部积分推）？你至少能推导其中一条吗？ “零点 (\\mu_m^{(n)})”在傅里叶-贝塞尔级数里扮演什么角色？它对应“特征值”还是“本征频率”？ 傅里叶-贝塞尔展开的正交性权重为什么是 (r)（积分里出现 (r,dr)）？它来自哪里（面积元）？ 给定边界 (u(R,\\theta)=0)，为什么径向部分必须取 (J_n(\\mu r/R)) 且 (\\mu) 为 (J_n) 的零点？ 你能说出傅里叶-贝塞尔系数公式的结构：分子像“投影”，分母像“范数”，并指出每一项来自哪里吗？ 把贝塞尔工具用于 PDE：圆域上的拉普拉斯/热/波方程，你会如何组合“角向傅里叶 + 径向贝塞尔 + 时间模态”三段式？ 10 综合题（把方法“串联”） 一维热方程：方程含源项 (f(x,t))，边界又是非齐次。请你给出从原问题到可解问题的完整流程（拆分/辅助函数/固有函数/求系数），并指出每一步产生的新方程是什么类型。 二维泊松方程在圆域：边界给定 (u(R,\\theta)=f(\\theta))，域内源项 (F(r,\\theta)) 已经可写成傅里叶级数。你会选“先找特解再化拉普拉斯”还是“直接固有函数法”？给出你选择的理由与步骤。 上半平面/上半空间狄利克雷问题：你能分别用“镜像法构造格林函数”与“泊松核积分”两条路描述求解吗？两条路的相同点与不同点是什么？ 一个题里同时出现：非齐次边界 + 非齐次方程 + 初值。你如何安排顺序：先化齐次边界还是先拆分非齐次源项？给出你的一般策略（以及反例：什么情况下要反过来）。 如果你愿意，我可以把这份题单按“期末高频题型”再压缩成 30 题必会版，或者按你老师的四段法（motivation/方法/验证/思考）把每个方法都改成“自问自答式 checklist”。\n","date":"2026-01-13T22:41:52+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E6%95%B0%E7%90%86%E6%96%B9%E7%A8%8B%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","title":"数理方程问题汇总"},{"content":"下面是我筛过的 EDA 学习教材 / notes / slides（都带网址），尽量选“短、讲得透、能直接看”的。\n物理设计 / VLSI CAD 总览（强烈推荐先看） Georgia Tech ECE6133（Physical Design Automation）— slides 很全、很清晰\n1 https://limsk.ece.gatech.edu/course/ece6133/slides/intro.pdf 1 https://limsk.ece.gatech.edu/course/ece6133/slides/placement.pdf 1 https://limsk.ece.gatech.edu/course/ece6133/slides/steiner.pdf (Limsk)\nNorthwestern ECE357（Intro to VLSI CAD）— lecture notes 风格，覆盖 partition/placement/routing/compaction\n1 https://www.eecs.northwestern.edu/~haizhou/357/ （例：lec1）\n1 https://www.eecs.northwestern.edu/~haizhou/357/lec1.pdf (西北大学电气与计算机工程)\nMIT 6.375（复杂数字系统，含“synthesis/placement/routing”速览）\n1 https://csg.csail.mit.edu/6.375/6_375_2006_www/handouts/lectures/L05-Synthesis-Placement-Routing.pdf （课程资源页）\n1 https://csg.csail.mit.edu/6.375/6_375_2009_www/resources.html (计算结构组)\nNTU（Y.-W. Chang）VLSI Design Automation 讲义（偏“短而密”）\n1 https://cc.ee.ntu.edu.tw/~ywchang/Courses/EDA04/lec1.pdf （Routing 讲义也很值得扫一遍）\n1 https://cc.ee.ntu.edu.tw/~ywchang/Courses/PD_Source/EDA_routing.pdf (东南大学)\nNPTEL（VLSI Physical Design with Timing Analysis）— 系统课，单节视频/讲义都很短\n1 https://nptel.ac.in/courses/108107380 (NPTEL)\n你关心的 Placement（再给你一个“从课件到可复现”的闭环） OpenROAD：Global Placement 文档（基于 RePlAce）\n1 https://openroad.readthedocs.io/en/latest/main/src/gpl/README.html (OpenROAD)\nRePlAce（源码+说明）\n1 https://github.com/The-OpenROAD-Project/RePlAce (GitHub)\nOpenROAD 教程资源汇总（含 slides/仓库/工具链）\n1 https://the-openroad-project.github.io/micro2022tutorial/content/4-resources.html (开放之路项目)\n“能动手”的开源工具文档（建议边学边跑） Yosys（综合）\n1 https://yosyshq.readthedocs.io/projects/yosys/en/latest/ (YosysHQ Docs)\nOpenSTA（静态时序分析）\n1 https://github.com/The-OpenROAD-Project/OpenSTA (GitHub)\nKLayout（版图查看/DRC/LVS）\n1 https://www.klayout.de/doc/manual/index.html (klayout.de)\n","date":"2026-01-12T23:27:09+08:00","permalink":"https://demo.stack.jimmycai.com/post/eda-resource/","title":"Eda Resource"},{"content":"第一阶段：扫除盲区（优先攻克 Ch6 \u0026amp; Ch7） 原因： 你说这两章不懂，但这部分概念在大题（如采样恢复）和填空选择中是必考的，而且一旦理解了，拿分很容易。\n1. 第七章：采样 (Sampling)\n核心逻辑： 采样就是频谱搬移。 必懂概念： 奈奎斯特采样定理： $\\omega_s \u0026gt; 2\\omega_m$ （或者 $f_s \u0026gt; 2f_{max}$）。这是送分题，必须拿住。 频谱混叠： 如果采样率不够，频谱会叠在一起，画图时要注意。 PPT难点攻克： “采样与重建过程的数学分析”。 动作： 这一块不要死记硬背公式，要会画图。复习时，在草稿纸上画一个三角形代表$X(j\\omega)$，然后画出采样后的$X_s(j\\omega)$（就是无数个三角形周期延拓），最后画一个矩形框（低通滤波器）把它滤出来。 A4纸准备： 抄上理想采样的频谱公式、重建公式（Sinc插值公式）。 2. 第六章：时频特性\n核心逻辑： 系统不失真传输的条件。 必懂概念： 无失真传输条件： 幅频特性是常数（$|H(j\\omega)| = K$），相频特性是过原点的直线（$\\angle H(j\\omega) = -t_0\\omega$）。这意味着输出信号只是输入的延时和缩放。 物理含义： 幅度失真 vs 相位失真。 A4纸准备： 把无失真传输的$H(j\\omega)$数学表达式抄上去。 第二阶段：强化计算与类比（Ch9 Laplace \u0026amp; Ch10 Z变换） 原因： 你熟悉Laplace但Z变换一般。这两者是高度平行的，放在一起复习效率最高。这部分通常占据计算大题的半壁江山。\n1. 建立映射关系（Z变换突击）\n复习策略： 不要把Z变换当新东西学，它就是离散版的Laplace。 $s$平面 $\\leftrightarrow$ $z$平面 虚轴 $\\leftrightarrow$ 单位圆 $Re[s] \u0026lt; 0$ (左半平面稳定) $\\leftrightarrow$ $|z| \u0026lt; 1$ (单位圆内稳定，注意：如果是因果系统，极点要在单位圆内)。 PPT难点攻克： $X(z)$的极点与收敛域(ROC)的关系。 口诀： 右边信号（因果）ROC在极点外；左边信号ROC在极点内；双边信号ROC在环状区域。 必练大题（70分主力）： 给差分方程 $\\to$ 求$H(z)$ $\\to$ 求$h[n]$（逆变换） $\\to$ 求零极点画图判断稳定性。 这套流程和Laplace里的 微分方程 $\\to$ $H(s)$ $\\to$ $h(t)$ 是一模一样的。 2. A4纸准备（抄什么）：\n常用变换对： 尤其是带$n$的、指数衰减的、正余弦的Z变换对。 性质： 初值定理、终值定理（最容易忘）、时域卷积定理（$Y(z)=X(z)H(z)$）。 部分分式展开法： 如果记不住公式，抄一个例题的过程上去。 第三阶段：稳固根基（Ch1 \u0026amp; Ch2 \u0026amp; Ch5） 原因： 你对卷积熟悉，但PPT里提到了“有始信号的卷积”是难点，容易在积分上下限翻车。\n1. 卷积 (Ch2)\n警惕点： PPT第8页提到的公式 $x_1(t-t_1) * x_2(t-t_2)$ 的新起点是 $t_1+t_2$。 做题策略： 计算题中，如果遇到复杂的卷积，先看能不能用拉普拉斯变换做（时域卷积=频域相乘），然后再逆变换回来。通常比直接积分快且准。 2. 信号与系统性质 (Ch1)\n必考点： 线性、时不变、因果、稳定的判断。 A4纸准备： 抄上判断“线性”和“时不变”的标准步骤（先移位后变换 vs 先变换后移位）。 3. DTFT (Ch5)\n既然不考CTFT，那DTFT可能会考一点。 重点： 频域的周期性（周期为$2\\pi$）。 A4纸准备： 几个关键的DTFT变换对，比如矩形窗 $\\leftrightarrow$ $\\frac{\\sin(\\omega N/2)}{\\sin(\\omega/2)}$ (这是离散Sinc，稍微复杂点，建议抄上)。 第四阶段：A4纸“小抄”制作指南（黄金战术） 这是半开卷考试的胜负手。不要抄你熟记于心的（如欧姆定律级别的公式），要抄**“考场上紧张容易忘”和“推导麻烦”**的东西。\n建议分区布局：\n左上角：常用变换对列表 Laplace对（特别是 $t^n e^{-at}$ 这种）。 Z变换对（特别是 $n a^n u[n]$，$\\cos(\\omega_0 n)u[n]$ 这种）。 DTFT对。 左下角：关键性质 移位性质（时域移位对应频域乘指数）。 微分/差分性质。 初值/终值定理。 右上角：系统稳定性与结构 $H(s)$ 稳定条件：极点在左半平面。 $H(z)$ 稳定条件：极点在单位圆内（模\u0026lt;1）。 二阶系统的结构流图（直接II型等，PPT里如果有框图，抄一个通用的）。 右下角：采样与杂项 采样定理条件。 三角函数积化和差公式（计算卷积或逆变换时经常用到）。 欧拉公式（$e^{jx} = \\cos x + j\\sin x$）。 综合复习日程建议（假设还有几天考试） Day 1 (攻坚):\n专注 Sampling (Ch7) 和 Z变换 (Ch10)。 找3-4道包含“采样-恢复”的题目做。 找3-4道“差分方程求系统响应”的Z变换大题做。 目标： 弄懂采样图怎么画，Z变换ROC怎么定。 Day 2 (巩固):\n复习 Laplace (Ch9) 和 系统框图。 做几道电路图转S域模型的题，或者框图求传函的题（梅森公式如果学了就复习，没学就用中间变量法）。 目标： 确保计算绝对正确，熟练使用部分分式展开。 Day 3 (扫尾与制表):\n快速过一遍 Ch1, Ch2, Ch6 的概念（选择填空题主要来源）。 制作A4纸。一边写一边默念公式，这是最好的复习。 做一套往年真题，模拟考试时间。 针对70分计算题的预测 根据华科（HUST）这种硬核课程的风格，4道大题大概率分布在：\n时域分析： 卷积积分（可能涉及阶跃信号、分段信号）。 连续系统复频域分析： 电路或框图 $\\to$ $H(s)$ $\\to$ 零极点/稳定性 $\\to$ 逆变换求 $h(t)$ 或响应。 离散系统Z域分析： 差分方程 $\\to$ $H(z)$ $\\to$ 频率响应 $\\to$ 稳态输出。 采样或综合题： 信号采样后的频谱分析，或者CTFT/DTFT的性质应用（虽然说不考CTFT，但它是采样的基础，注意审题）。 总结： 你的底子不错，只要把Z变换拉到和Laplace同一水平，再把采样的概念搞定，配合一张精心准备的A4纸，这门课拿高分不难。多动笔算，少看书看PPT！\n","date":"2025-12-11T22:13:08+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/","title":"信号与系统复习提纲"},{"content":"这个实验手册怎么样，是否需要进一步的丰富\n这太棒了。我们将这两份内容的精华彻底融合，打造一份史诗级的《C++ STL 深度解剖实验手册》。\n这份手册采用了**【显微镜模式】（底层原理）与【实战演练】（API与陷阱）**的双重架构。每一条都是一个独立的实验课题，请务必在 cgdb 中亲手验证。\n实验环境配置（再次强调）：\n1 2 3 # 必须关闭优化 (-O0) 并开启调试信息 (-g) g++ -g -O0 -std=c++17 main.cpp -o main cgdb ./main 第一章：动态数组的霸主 —— std::vector 核心目标：掌握连续内存管理、扩容代价、对象生命周期。\n【显微镜模式】(底层原理) 对象的骨架：vector\u0026lt;int\u0026gt; v;。打印 sizeof(v)。 GDB 验证：它通常等于 3 * sizeof(void*)（约24字节）。查看 p v，你能找到 _M_start, _M_finish, _M_end_of_storage 这三个指针吗？ 栈与堆的分离：vector 对象本身在栈上，数据在堆上。 GDB 验证：打印 \u0026amp;v 和 \u0026amp;v[0]。两者的地址差值巨大说明了什么？ 扩容的暴利：写循环 push_back，观察 v.capacity()。 GDB 验证：它是按 1.5 倍（MSVC）还是 2 倍（GCC）增长的？ 地址大迁徙：记录扩容前的 \u0026amp;v[0]。触发扩容后： GDB 验证：旧地址里的数据还在吗？（查看 x/10wd 旧地址）。 思考：这就是所有指向旧元素的迭代器/指针瞬间失效的物理原因。 Size vs Capacity 的骗局：push_back 100次后调用 v.clear()。 GDB 验证：size() 归零了，但 capacity() 变小了吗？内存真的释放给操作系统了吗？ 进阶：执行 v.shrink_to_fit() 后，再次观察 _M_start 地址是否改变？ 【实战演练】(API \u0026amp; 坑点) 构造的歧义：vector\u0026lt;int\u0026gt; v1(10, 5) vs vector\u0026lt;int\u0026gt; v2{10, 5}。 GDB 验证：p v1 和 p v2 的内容分别是什么？（一个是10个5，一个是10和5）。 遍历删除的死亡陷阱：在 for 循环中 erase 偶数元素。 代码：如果你写 v.erase(it); it++，程序会崩吗？ 修正：验证 it = v.erase(it) 的返回值是指向“下一个有效元素”的。 Emplace 优化：v.push_back(MyStruct(1,2)) vs v.emplace_back(1,2)。 GDB 断点：在 MyStruct 的拷贝构造函数打断点。观察 emplace_back 是否成功避开了拷贝/移动构造？ 访问安全：v[1000] vs v.at(1000)。 行为观察：哪个导致 SIGSEGV（段错误，进程直接死掉），哪个抛出 std::out_of_range 异常（可以被 catch）？ 插入效率：在 v.begin() 插入。 GDB 观察：打印 \u0026amp;v[1]（原 v[0]）。地址变了吗？说明了什么？（全员内存搬家）。 第二章：文本的特殊形态 —— std::string 核心目标：理解 SSO 优化、C 兼容性、只读视图。\n【显微镜模式】(底层原理) SSO (短字符串优化)：string s = \u0026quot;abc\u0026quot;;。 GDB 验证：p (void*)s.data() 的地址是否落在了 \u0026amp;s 对象的范围内？（说明数据存在栈上，未分配堆内存）。 SSO 临界点：不断 append 字符，直到长度超过 15 或 23（取决于编译器）。 GDB 验证：观察 s.data() 的地址何时突然跳变到堆区？ 隐形的结束符：string s = \u0026quot;abc\u0026quot;;。 GDB 验证：x/4bc s.data()。虽然 size() 是 3，但你能看到第 4 个字节是 \\0 吗？（为了兼容 C 接口）。 中间的 \\0：s += '\\0'; s += \u0026quot;def\u0026quot;;。 GDB 验证：p s.size() 是多少？p strlen(s.c_str()) 是多少？（理解 string 是“带长度的数组”，而 char* 依赖 \\0）。 Substr 的深拷贝：string s2 = s1.substr(0, 5)。 GDB 验证：s2 的数据地址和 s1 有重叠吗？（验证它是全新的内存分配）。 【实战演练】(API \u0026amp; 坑点) 只读视图 std::string_view (C++17)：string_view sv = s;。 GDB 验证：sizeof(sv) 只有 16 字节（指针+长度）。 陷阱：让 s 发生扩容或销毁，再访问 sv，观察到了什么？（悬垂指针/UAF）。 查找失败的返回值：size_t pos = s.find(\u0026quot;xyz\u0026quot;);。 GDB 验证：p pos 是 -1 吗？还是一个巨大的正整数？（验证 string::npos 的二进制表示）。 数值转换：std::stoi(\u0026quot;abc\u0026quot;)。 行为观察：它会返回 0 还是抛出异常？ 第三章：链式与分段 —— std::list \u0026amp; std::deque 核心目标：理解非连续内存、中控器、迭代器稳定性。\n【显微镜模式】(底层原理) Deque 的中控器：deque 插入大量数据。 GDB 验证：\u0026amp;d[0] 和 \u0026amp;d[size-1] 的距离等于 size * 4 吗？（绝不相等）。 结构探索：尝试在 GDB 中找到 _M_map（二级指针数组）。 List 的节点开销：list\u0026lt;int\u0026gt; l;。 GDB 验证：x/4xg [节点地址]。除了存 int，还多了两个 8 字节的指针（prev/next）。计算内存膨胀率。 地址随机性：连续 push_back 3个元素进 List。 GDB 验证：它们的地址是连续的吗？（验证堆分配的随机性）。 【实战演练】(API \u0026amp; 坑点) 头插法的奇迹：vector vs deque 的 push_front。 GDB 验证：deque 头部插入后，\u0026amp;d[1]（原 d[0]）的地址变了吗？（没变，说明 deque 只是开辟了新的“前驱块”，没有搬移数据）。 List 的接合 (Splice)：l1.splice(l1.end(), l2)。 GDB 验证：l2 变空了吗？l1 里的新节点地址变了吗？（指针操作，零拷贝，速度极快）。 迭代器失效对比： 场景：在中间插入元素。 验证：vector 的迭代器失效了吗？deque 的失效了吗？list 的失效了吗？（List 是唯一完全稳定的）。 第四章：树与哈希 —— std::map \u0026amp; std::unordered_map 核心目标：理解红黑树代价、哈希冲突、查找副作用。\n【显微镜模式】(底层原理) 红黑树节点：map\u0026lt;int, int\u0026gt; m;。 GDB 验证：解引用迭代器 p *it。看到的类型是 pair\u0026lt;const int, int\u0026gt; 吗？ 结构：节点里藏了 _M_parent, _M_left, _M_right, _M_color。算算这一个节点多大？ 哈希桶 (Bucket)：unordered_map。 GDB 验证：找到 _M_buckets 数组。 冲突实验：构造哈希冲突的 Key 插入。观察它们是否在同一个 bucket 指针下挂成了链表？ 【实战演练】(API \u0026amp; 坑点) [] 运算符的副作用：cout \u0026lt;\u0026lt; map[\u0026quot;不存在的key\u0026quot;];。 GDB 验证：p map.size() 从 0 变成 1 了吗？ 思考：只想查询不想插入时，应该用什么？(find() 或 at())。 Key 的不可变性：尝试 it-\u0026gt;first = 10。 验证：编译报错了吗？如果强行用指针改内存，树的结构会崩坏吗？（有序性丢失）。 自定义 Key： 代码：用 struct 做 Key。map 需要重载 \u0026lt;，unordered_map 需要重载 == 并提供 hash 函数。缺一个会怎样？ 性能退化：攻击哈希表。 场景：让所有 Key 哈希冲突。查找速度退化为 O(N) 了吗？ 第五章：容器适配器 —— std::stack / std::queue 核心目标：理解封装、底层替换、异常安全。\n换个心脏：stack\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; s;。 GDB 验证：ptype s。看到底层变成 vector 了吗？ 受限访问： GDB 验证：虽然代码不能写 s[0]，但 GDB 可以 p s.c[0] 偷看数据吗？ Pop 的返回值：为什么 pop() 返回 void 而不是元素值？ 思考：如果返回元素时发生拷贝异常，元素是不是就永久丢失了？（理解异常安全性的设计）。 清空栈：Stack 没有 clear()。 代码：如何最快清空？验证 s = stack\u0026lt;int\u0026gt;() 或 while(!s.empty()) s.pop()。 终极实验：手写 Vector 的设计蓝图 设计挑战：完成上述实验后，尝试回答：\n设计题：如果让你用 C 语言手写一个 vector： 你的结构体包含哪 3 个字段？ 你的 push_back 第一行代码是在检查什么？（Capacity）。 扩容时，你会用 realloc 还是 malloc + memcpy？（提示：对于 C++ 对象，memcpy 是非法的，必须调用移动构造）。 按照这 35 个问题走下来，你看到的将不再是枯燥的代码，而是内存中流动的字节和指针的舞蹈。祝你在 GDB 的世界里探索愉快！\n好的，这里是针对 C++ STL 常用容器的底层实现、方法应用、性能陷阱和现代 C++ 特性的 100 个深度问题。这些问题旨在考察开发者对 STL 的理解深度，而不仅仅是停留在“会用”的层面。\n问题分为以下几个类别：\n通用概念与容器对比 (1-15) std::vector (16-30) std::list \u0026amp; std::forward_list (31-40) std::deque (41-50) 有序关联容器 (map, set) (51-65) 无序关联容器 (unordered_map, unordered_set) (66-80) 容器适配器 (stack, queue, priority_queue) (81-85) 高级主题 (迭代器, 内存, 异常, 并发) (86-100) 一、通用概念与容器对比 (1-15) 迭代器失效 (Iterator Invalidation)：请分别解释在对 std::vector, std::list, std::deque, std::unordered_map 进行插入（insert）和删除（erase）操作时，会导致哪些类型的迭代器、指针和引用失效？为什么？ 性能权衡：在“随机访问”、“在序列中间插入/删除”和“在序列两端插入/删除”这三个场景下，请详细对比 vector, list, deque 的时间复杂度，并解释其底层数据结构如何导致这些性能差异。 缓存友好性 (Cache Friendliness)：为什么通常说 std::vector 是缓存友好的，而 std::list 不是？这在实际应用中会带来多大的性能影响？请举例说明。 emplace vs insert/push：emplace*系列方法（如 emplace_back, emplace）相比于 insert 或 push_back 的主要优势是什么？请解释其背后的完美转发（Perfect Forwarding）和原地构造（In-place Construction）机制。 节点式容器 vs 序列式容器：从内存分配和布局的角度，比较节点式容器（如 list, map）和序列式容器（如 vector, deque）的优缺点。 map::operator[] vs map::at：std::map 的 operator[] 和 at() 方法有何区别？在什么情况下应该优先使用哪一个？operator[] 对 mapped_type（值类型）有什么特殊要求？ 有序 vs 无序：在选择键值对存储时，你会在什么情况下选择 std::map 而不是 std::unordered_map？请至少列出三个决定性因素。 异常安全保证 (Exception Safety Guarantee)：STL 容器通常提供哪几种异常安全保证（基本、强、不抛出）？请以 vector::push_back 为例，说明当元素类型的拷贝/移动构造函数抛出异常时，容器会处于什么状态？ 存储指针 vs 存储对象：在容器中直接存储对象（vector\u0026lt;MyObject\u0026gt;）与存储对象的智能指针（vector\u0026lt;unique_ptr\u0026lt;MyObject\u0026gt;\u0026gt;）各有什么优缺点和适用场景？ size() vs capacity() vs max_size()：解释 vector（或其他适用容器）中这三个函数的含义和区别。 清除容器：clear() 方法和 c = {}（例如 v = {}）在清空一个容器时，行为上有什么潜在的差异？（提示：考虑内存） shrink_to_fit()：shrink_to_fit() 的作用是什么？为什么标准规定它是一个“非绑定请求”（non-binding request）？ 多重容器 (Multi-containers)：std::multimap 和 std::multiset 解决了什么问题？它们的底层实现与对应的 map 和 set 有何不同？ C++17 的异构查找 (Heterogeneous Lookup)：C++17 中，如何实现在 std::map\u0026lt;std::string, T\u0026gt; 中使用 std::string_view 进行查找而无需构造 std::string？这需要用到什么特性？ 选择合适的容器：设计一个日志系统，需要频繁在尾部追加日志条目，偶尔需要按时间戳范围查找日志。你会选择哪个或哪些 STL 容器组合来实现？并说明原因。 二、std::vector (16-30) 动态增长策略：std::vector 的容量在空间不足时是如何增长的？为什么通常采用“倍增”（或 1.5 倍）策略，而不是线性增加（如每次增加 10个元素）？ reserve() 的重要性：在什么场景下，预先调用 reserve() 会极大地提升性能？它如何避免不必要的性能开销？ vector\u0026lt;bool\u0026gt; 特化：std::vector\u0026lt;bool\u0026gt; 是一个“假的”容器吗？请解释它的特殊底层实现（位集），以及这种实现带来的优点和哪些违反常规容器语义的“坑”？ 移动语义与 vector：C++11 的移动语义（Move Semantics）如何优化 std::vector 的重分配（reallocation）过程？特别是当元素类型是 std::string 或 std::unique_ptr 时。 erase-remove 惯用法：请解释并实现 C++ 中的 \u0026ldquo;erase-remove idiom\u0026rdquo;。为什么直接循环调用 erase 来删除多个元素效率低下？ 指针失效的细节：当 vector 发生重分配时，为什么指向其元素的“所有”指针、引用和迭代器都会失效？ data() 方法：v.data() 返回的指针有什么用？它与 \u0026amp;v[0] 有什么异同？在 C++11 之前和之后有什么变化？ emplace_back 的异常安全：如果 emplace_back 的参数构造函数抛出异常，vector 的状态会怎样？它是否满足强异常安全保证？ vector 插入操作的复杂度：为什么在 vector 的末尾插入是“摊还 O(1)”，而在开头或中间插入是 O(N)？请解释“摊还”的含义。 非 noexcept 的移动构造函数：如果一个类型的移动构造函数没有被标记为 noexcept，vector 在扩容时会如何处理？这会带来什么性能影响？ 三、std::list \u0026amp; std::forward_list (31-40) list::size() 的历史：为什么在 C++11 之前，一些标准库实现的 list::size() 的时间复杂度是 O(N)？这与 splice 方法有什么关系？ splice 的威力：list::splice() 操作为什么效率极高（O(1)）？请描述它的作用和底层实现原理。 list vs. forward_list：std::forward_list 相比 std::list 有哪些优势和劣势？为什么它的 API 设计中充满了 *_after 形式的方法？ 自我排序：为什么 std::list 和 std::forward_list 拥有自己的 sort() 成员函数，而 vector 和 deque 却使用全局的 std::sort()？（提示：迭代器类别） 内存开销：详细分析 std::list\u0026lt;T\u0026gt; 相对于 std::vector\u0026lt;T\u0026gt; 的内存开销。除了数据 T 本身，每个元素还需额外存储什么？ 迭代器稳定性：为什么说 std::list 提供了最强的迭代器稳定性？除了被删除的那个元素，任何插入或删除操作都不会使指向其他元素的迭代器失效。 list 的适用场景：在现代 C++ 编程中，考虑到缓存性能的影响，std::list 的实际适用场景还有哪些？ 合并两个有序 list：如何高效地（优于 O(N log N)）合并两个已排序的 std::list？ forward_list 的 before_begin：forward_list 的 before_begin() 迭代器有什么特殊用途？为什么需要它？ 实现 list::reverse：如果不使用 list::reverse() 成员函数，请描述如何原地反转一个 std::list，并分析其复杂度。 四、std::deque (41-50) deque 的底层结构：请详细描述 std::deque 的典型底层数据结构（“分块数组”或“中控数组”）。 deque 的迭代器：std::deque 的迭代器是如何实现的？为什么它能表现得像一个随机访问迭代器，但其内部结构却比 vector 的指针复杂得多？ 性能特点：deque 如何做到在两端进行摊还 O(1) 的插入和删除？它的随机访问为什么比 vector 慢？ 迭代器失效的复杂性：deque 的插入/删除操作导致的迭代器失效规则比 vector 更复杂。请具体说明在 deque 中间插入/删除元素时，哪些迭代器、指针和引用会失效，哪些不会。 内存布局：deque 的元素在内存中是连续的吗？这对其性能有什么影响？ deque vs. vector：如果一个场景需要频繁在容器头部插入元素，deque 是唯一的选择吗？和 vector 相比，除了头部插入，它还有什么优势？（例如，不会发生一次性的大规模内存复制） deque 的收缩：deque 是否支持 shrink_to_fit()？其效果与 vector 有何不同？ 作为底层容器：为什么 std::stack 和 std::queue 默认使用 std::deque 作为其底层容器，而不是 std::vector 或 std::list？ 指针与引用：在 deque 的两端进行插入操作后，指向未受影响元素的指针和引用是否保持有效？为什么？ 小对象存储：对于存储大量小对象，deque 的分块结构相比 vector 的连续内存，在内存管理上可能有什么优势？ 五、有序关联容器 (map, set) (51-65) 底层实现：std::map 和 std::set 通常基于哪种自平衡二叉搜索树？为什么选择它而不是 AVL 树？ Key 的要求：作为 std::map 或 std::set 的键（Key），类型必须满足什么要求？（提示：Compare 函数对象） lower_bound vs upper_bound：请解释 map::lower_bound 和 map::upper_bound 的作用和区别。如何利用它们高效地对 map 进行范围查询？ 迭代顺序：遍历一个 std::map 或 std::set 时，元素的顺序是如何保证的？ 插入操作的返回值：map::insert 的返回值是什么类型？它包含了哪些信息？如何利用这些信息判断插入是否成功以及获取指向元素的迭代器？ emplace 与提示 (hint)：emplace_hint(iterator, args...) 中的 hint 参数有什么作用？在什么情况下它能将插入操作的复杂度从 O(log N) 优化到摊还 O(1)？ 自定义比较函数：当使用自定义对象作为 map 的 key 时，如何提供自定义的比较逻辑？如果比较逻辑不满足“严格弱序”（Strict Weak Ordering），会导致什么问题？ C++17 节点操作 (extract, merge)：C++17 引入的 extract 和 merge 方法解决了什么痛点？请举例说明如何用它们在不重新分配内存的情况下修改一个 map 中元素的 key。 count() 的效率：对于 std::map，count(key) 的效率如何？它和 find(key) != end() 相比，哪个更适合用来检查 key 是否存在？multimap 呢？ 迭代器与指针稳定性：map/set 的插入和删除操作是否会使指向其他元素的迭代器、指针或引用失效？为什么？ map 中的 const Key：为什么从 std::map\u0026lt;K, V\u0026gt;::iterator 中解引用得到的是 std::pair\u0026lt;const K, V\u0026gt;？Key 部分为什么是 const 的？ 透明比较器 (std::less\u0026lt;\u0026gt;)：在 C++14 中，如何使用 std::less\u0026lt;\u0026gt; (或std::greater\u0026lt;\u0026gt; 等) 作为模板参数，以实现异构查找？ equal_range：map::equal_range 的作用是什么？它在处理 multimap 时特别有用，为什么？ 内存开销：分析 std::map\u0026lt;K, V\u0026gt; 的单节点内存开销，除了 K 和 V，还包含哪些额外信息？ 查找复杂度的本质：为什么说 map 的查找是 O(log N)？这个 N 指的是什么？ 六、无序关联容器 (unordered_map, unordered_set) (66-80) 底层实现：std::unordered_map 通常的底层实现是什么？请描述哈希表、桶（bucket）和链表（或开放地址法）在其中的作用。 哈希与相等：要将自定义类型作为 unordered_map 的 key，需要为其提供哪两个函数？它们之间必须满足什么关系？（即，如果 a == b，则 hash(a) 必须等于 hash(b)） 哈希冲突 (Collision)：什么是哈希冲突？unordered_map 是如何解决冲突的？冲突对性能有什么影响？ 加载因子 (Load Factor)：什么是加载因子？它如何影响 unordered_map 的性能？max_load_factor 函数的作用是什么？ 重哈希 (Rehashing)：什么情况下会触发 unordered_map 的重哈希？重哈希是一个昂贵的操作吗？它对迭代器有什么影响？ reserve 的作用：unordered_map::reserve(n) 和 vector::reserve(n) 有何不同？它预留的是元素空间还是桶空间？ 最坏情况复杂度：unordered_map 的平均查找复杂度是 O(1)，但最坏情况是 O(N)。请描述一个能导致最坏情况发生的场景。 桶接口 (Bucket Interface)：bucket_count(), bucket_size(n), bucket(key) 这些桶接口函数有什么用？它们可以用来诊断哈希函数的质量吗？ 性能陷阱：使用默认的 std::hash\u0026lt;std::string\u0026gt; 时，如果输入的字符串有很多共同的前缀，可能会导致什么性能问题？如何解决？ 指针稳定性：在不发生重哈希的情况下，unordered_map 的插入操作是否会使指向已有元素的指针或引用失效？删除操作呢？ unordered_map vs. std::map：在性能敏感的应用中，即使不需要有序性，std::map 有时也可能比 unordered_map 更快。请解释可能的原因（例如，哈希计算开销、缓存行伪共享等）。 不可哈希的 Key：为什么像 std::vector 或 std::pair 这样的类型默认不能作为 unordered_map 的 key？如何让它们可以被用作 key？ C++20 contains：C++20 为关联容器增加了 contains 方法。相比 find(key) != end() 或 count(key)，它有什么优势？ 哈希函数的种子：一些哈希函数实现是带“种子”的，这有什么安全上的好处？（提示：哈希洪水攻击，Hash DoS） 开放地址法 vs. 链地址法：大多数标准库实现 unordered_map 使用链地址法。如果使用开放地址法实现，会有哪些不同的性能特性和优缺点？ 七、容器适配器 (stack, queue, priority_queue) (81-85) 适配器模式：为什么 stack, queue, priority_queue 被称为“容器适配器”？它们体现了设计模式中的哪个原则？ 底层容器选择：std::priority_queue 默认使用 std::vector，而 std::stack 和 std::queue 默认使用 std::deque。请解释这些默认选择的合理性。 priority_queue 实现：std::priority_queue 的底层是如何实现优先级的？（提示：堆 Heap）。插入（push）和弹出（pop）操作的时间复杂度是多少？ 自定义 priority_queue：如何创建一个最小堆（min-heap）而不是默认的最大堆（max-heap）？如何为自定义类型提供优先级比较逻辑？ 接口限制：为什么容器适配器不允许遍历其内部元素（即没有提供迭代器）？这种接口设计背后的意图是什么？ 八、高级主题 (迭代器, 内存, 异常, 并发) (86-100) 迭代器类别 (Iterator Categories)：解释 C++ 的五种迭代器类别（Input, Output, Forward, Bidirectional, Random Access）及其能力。请为每个类别至少举一个 STL 容器的例子。 自定义分配器 (Allocator)：std::allocator 是什么？在什么情况下你需要编写并使用一个自定义的分配器？（例如，内存池、对齐内存） STL 与线程安全：STL 容器是线程安全的吗？请详细解释标准对 STL 容器线程安全性的保证（“读-读”安全，“读-写/写-写”不安全）。 并发访问的风险：同时在不同线程中对同一个 std::vector 进行 push_back 会导致什么问题？仅仅加锁 push_back 调用本身足够吗？ 节点句柄 (Node Handles)：再谈 C++17 的 node_type，它如何实现容器间（例如 map 到 map，甚至 map 到 set）高效、无异常抛出的元素转移？ 不完整类型 (Incomplete Types)：是否可以在容器中存储不完整类型，例如在类定义中 class A { std::vector\u0026lt;A\u0026gt; children; };？为什么可以/不可以？std::vector\u0026lt;std::unique_ptr\u0026lt;A\u0026gt;\u0026gt; 呢？ std::array：std::array 和 C 风格数组、std::vector 相比，各有什么优缺点？为什么说它是“零开销抽象”？ std::span (C++20)：std::span 是一个容器吗？它如何与 std::vector, std::array 等容器交互，解决了什么问题？ 强异常安全保证的代价：为了在 vector::push_back 中提供强异常安全保证，当元素的移动构造函数不是 noexcept 时，实现必须回退到拷贝。请解释这背后的逻辑。 短字符串优化 (SSO)：虽然不是容器，但 std::string 的短字符串优化（SSO）与 vector 的动态内存管理形成了鲜明对比。请解释 SSO 的原理，并讨论如果 vector 也尝试实现类似的优化（“短向量优化”）会面临什么挑战。 allocator_traits：std::allocator_traits 是做什么用的？为什么我们应该通过它而不是直接调用分配器的方法？ 过对齐数据 (Over-aligned Data)：如何在一个 std::vector 中存储需要特定内存对齐（如 16-byte 或 32-byte 对齐）的数据？ 移动专用类型：对于像 std::unique_ptr 这样的移动专用（move-only）类型，它们在各种 STL 容器中的使用（插入、删除、排序）是如何工作的？有什么限制？ contiguous_iterator (C++20)：C++20 引入了 contiguous_iterator 概念。哪些容器的迭代器满足这个概念？这个概念有什么实际用途？ 未来展望：你认为 C++ 标准库的容器在未来可能会有哪些新的发展或改进？（例如，并发容器、更灵活的内存管理、平面容器 flat_map 等） ","date":"2025-12-06T21:48:00+08:00","permalink":"https://demo.stack.jimmycai.com/post/stl%E5%AE%B9%E5%99%A8%E9%97%AE%E9%A2%98/","title":"Stl容器问题"},{"content":"代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 #include \u0026lt;cinttypes\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;string_view\u0026gt; #include \u0026lt;vector\u0026gt; using std::cout; using std::endl; using std::string; using std::string_view; using std::vector; constexpr string_view letter0 = \u0026#34;AEIOUHWYaeiouhwy\u0026#34;; constexpr string_view letter1 = \u0026#34;BFPVbfpv\u0026#34;; constexpr string_view letter2 = \u0026#34;CGJKQSXZcgjkqsxz\u0026#34;; constexpr string_view letter3 = \u0026#34;DTdt\u0026#34;; constexpr string_view letter4 = \u0026#34;Ll\u0026#34;; constexpr string_view letter5 = \u0026#34;MNmn\u0026#34;; constexpr string_view letter6 = \u0026#34;Rr\u0026#34;; string letter_to_digit(string number, char c) { if (letter0.contains(c)) { number.push_back(\u0026#39;0\u0026#39;); return number; } else if (letter2.contains(c)) { number.push_back(\u0026#39;2\u0026#39;); return number; } else if (letter3.contains(c)) { number.push_back(\u0026#39;3\u0026#39;); return number; } else if (letter4.contains(c)) { number.push_back(\u0026#39;4\u0026#39;); return number; } else if (letter5.contains(c)) { number.push_back(\u0026#39;5\u0026#39;); return number; } else if (letter6.contains(c)) { number.push_back(\u0026#39;6\u0026#39;); return number; } else { return number; } } string name_to_number(string name) { string number; for (char c : name) { number = letter_to_digit(number, c); } return number; } string coalesce(string number) { string simplified_number; for (size_t i = 0; i \u0026lt; number.size(); i++) { if (i == 0) { simplified_number.push_back(number[i]); } else { if (number[i] == number[i - 1]) { } else { simplified_number.push_back(number[i]); } } } return simplified_number; } string replace_first_digit(string number, char first_letter) { number[0] = first_letter; return number; } string discard0(string letter_number) { string discard0_letter_number; for (size_t i = 0; i \u0026lt; letter_number.size(); i++) { if (letter_number[i] == \u0026#39;0\u0026#39;) { } else { discard0_letter_number.push_back(letter_number[i]); } } return discard0_letter_number; } string make_length4(string letter_number) { int size = letter_number.size(); if (size == 4) { } else if (size \u0026gt; 4) { letter_number.erase(4); } else if (size \u0026lt; 4) { int n = 4 - size; letter_number.append(n, \u0026#39;0\u0026#39;); } return letter_number; } string soundex(string name) { string number = name_to_number(name); number = coalesce(number); number = replace_first_digit(number, name[0]); number = discard0(number); number = make_length4(number); return number; } int main(int argc, char *argv[]) { // string number; // string number1; // number = letter_to_digit(number, \u0026#39;A\u0026#39;); // number.push_back(\u0026#39;a\u0026#39;); // // number1 = name_to_number(\u0026#34;AfaILODR\u0026#39;M[\u0026#34;); // cout \u0026lt;\u0026lt; number1 \u0026lt;\u0026lt; endl; // cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // string number2 = coalesce(\u0026#34;222025\u0026#34;); // cout \u0026lt;\u0026lt; number2 \u0026lt;\u0026lt; endl; // cout \u0026lt;\u0026lt; discard0(\u0026#34;200233\u0026#34;) \u0026lt;\u0026lt; endl; string name1 = \u0026#34;Curie\u0026#34;; string number1 = soundex(name1); string name2 = \u0026#34;O’Conner\u0026#34;; string number2 = soundex(name2); cout \u0026lt;\u0026lt; number1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; number2 \u0026lt;\u0026lt; endl; } 反思 在c++17中引入了string view，string和string_view可以理解为变量和指针的关系。在上面代码中，可以用string_view作为函数参数，这样就不用每次调用函数都拷贝一遍字符串了。\n在string需要修改时，不能传入string_view,\n","date":"2025-12-03T22:49:04+08:00","permalink":"https://demo.stack.jimmycai.com/post/cs106-assignment1-soundex/","title":"Cs106 Assignment1 Soundex"},{"content":"好的！以下是行波法、达朗贝尔公式、基尔霍夫公式的重新总结，其中基尔霍夫公式采用单位球面上的积分形式（这是理论分析和推导中更标准、更清晰的写法）。\n一、行波法（1D） 方程：\n$$ u_{tt} = c^2 u_{xx},\\quad x\\in\\mathbb{R},\\ t\u003e0 $$ 思想：引入特征变量 $\\xi = x - ct$，$\\eta = x + ct$，得通解\n$$ u(x,t) = f(x - ct) + g(x + ct) $$ 物理意义：解由左行波和右行波叠加而成，波形以速度 $c$ 无畸变传播。 二、达朗贝尔公式（1D 柯西问题） 初值问题：\n$$ \\begin{cases} u_{tt} = c^2 u_{xx} \\\\ u(x,0) = \\varphi(x),\\quad u_t(x,0) = \\psi(x) \\end{cases} $$ 解：\n$$ u(x,t) = \\frac{1}{2}\\big[\\varphi(x-ct) + \\varphi(x+ct)\\big] + \\frac{1}{2c} \\int_{x-ct}^{x+ct} \\psi(s)\\,ds $$ 依赖区域：区间 $[x-ct,, x+ct]$ 惠更斯原理：✅ 成立（扰动经过即消失） 三、基尔霍夫公式（3D 柯西问题，单位球形式） 方程：\n$$ u_{tt} = c^2 \\Delta u,\\quad (x,y,z)\\in\\mathbb{R}^3,\\ t\u003e0 $$ 初值：\n$$ u(P,0) = \\varphi(P),\\quad u_t(P,0) = \\psi(P) $$ ✅ 基尔霍夫公式（单位球面 $\\mathbb{S}^2$ 积分形式）： 令 $P = (x,y,z)$，$\\omega \\in \\mathbb{S}^2$ 为单位球面上的单位向量（$|\\omega| = 1$），则解为：\n$$ u(P, t) = \\frac{1}{4\\pi} \\frac{\\partial}{\\partial t} \\left( t \\int_{\\mathbb{S}^2} \\varphi(P + ct,\\omega), d\\omega \\right)\n\\frac{t}{4\\pi} \\int_{\\mathbb{S}^2} \\psi(P + ct,\\omega), d\\omega $$ 其中：\n$\\mathbb{S}^2 = { \\omega \\in \\mathbb{R}^3 : |\\omega| = 1 }$ 是单位球面； $d\\omega$ 是单位球面上的面积微元（即立体角元素，$\\int_{\\mathbb{S}^2} d\\omega = 4\\pi$）； $P + ct,\\omega$ 表示以 $P$ 为中心、半径为 $ct$ 的球面上的点。 🔔 说明：此形式通过变量代换 $Q = P + ct,\\omega$ 从原始球面积分导出，消除了半径依赖，更便于理论分析（如估计解的衰减、奇性传播等）。\n📌 特点： 解只依赖于球面 $|Q - P| = ct$ 上的初始数据； 严格满足惠更斯原理：在 $t \u0026gt; 0$ 时，若初始扰动紧支于某区域，则波前之外和波前之后的区域解均为零； 是三维自由空间波动传播的显式基本解表示。 四、对比小结（强调维数与积分域） 方法 空间维数 解的表达式核心 积分/依赖区域 惠更斯原理 行波法 1D $f(x-ct) + g(x+ct)$ 两点 $x\\pm ct$ ✅ 达朗贝尔公式 1D 初值在区间上的平均 + 积分 区间 $[x-ct, x+ct]$ ✅ 基尔霍夫公式 3D 初值在单位球面上的平均（加权 $t$） 球面 $ Q-P 💡 注：2D 的泊松公式需对单位圆盘（或单位圆内部）积分，不满足惠更斯原理。\n这种单位球形式的基尔霍夫公式在数学物理、偏微分方程理论、散射理论中更为常见，也更容易推广到非齐次项或高维情形。如果你需要从该形式推导出原始球面积分形式，或用它分析解的性质（如能量守恒、衰减率），也可以继续深入！\n","date":"2025-12-02T11:08:41+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E6%B3%A2%E5%8A%A8%E6%96%B9%E7%A8%8B%E7%9A%84%E8%BE%BE%E6%9C%97%E8%B4%9D%E5%B0%94%E5%85%AC%E5%BC%8F%E5%92%8C%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E5%85%AC%E5%BC%8F/","title":"波动方程的达朗贝尔公式和基尔霍夫公式"},{"content":"失真的类型有哪些？能否举一些常见电路中可能产生的失真的例子 复合管的等效 如何拆开bjt的黑盒子去分析输入和输出电阻 要打破“黑盒子”，你需要掌握一把“万能钥匙”：电阻反射规则（Impedance Reflection Rule）。\n第一步：打开黑盒子（建立心理模型） 在交流小信号分析中，把 BJT 想象成内部只有两个东西：\n基极-发射极之间（B-E）：夹着一个小电阻，叫 $r_{be}$（或者 $r_\\pi$）。 电流关系：流过发射极的电流 $i_e$ 是流过基极电流 $i_b$ 的 $1+\\beta$ 倍。 关键点来了： 电流在 B 极很小，在 E 极很大。这意味着：电阻在不同引脚“看”过去，阻值是不一样的。\n第二步：核心心法——“电阻反射规则” 这是分析输入输出电阻的终极捷径，请务必记住：\n1. 从基极看发射极（往里看，变大） 当你站在基极（Base）往发射极（Emitter）看时，你看到的任何接在发射极上的电阻，都会被放大 $1+\\beta$ 倍。\n直觉解释：因为发射极电流很大，基极只需要很小的电流就能控制它。对于基极来说，这感觉像是推一个很重的电阻，所以电阻看起来变大了。 公式： $$R_{in(\\text{从基极看})} = r_{be} + (1+\\beta) \\times R_{E(\\text{发射极总电阻})}$$ 2. 从发射极看基极（往回看，变小） 当你站在发射极（Emitter）往基极（Base）看时，你看到的任何接在基极上的电阻，都会被缩小 $1+\\beta$ 倍。\n直觉解释：因为发射极电流很大，它觉得基极那边的电阻简直微不足道。 公式： $$R_{out(\\text{从发射极看})} = \\frac{R_{B(\\text{基极外部电阻})} + r_{be}}{1+\\beta}$$ 第三步：标准化分析流程 现在我们用这个规则来分析你的输入电阻和输出电阻。\n1. 输入电阻 ($R_i$) 分析法 目标：从信号输入端看进去的总电阻。\nStep 1：画交流通路。电容短路，直流电源接地。 Step 2：找基极偏置电阻。通常有 $R_{b1}, R_{b2}$ 等，它们通常是并联在输入端的，先放在一边记着。 Step 3：看晶体管内部（应用反射规则）。 情况 A（发射极直接接地）：最简单。晶体管输入电阻就是 $r_{be}$。 情况 B（发射极接有电阻 $R_e$）：应用反射规则。晶体管输入电阻是 $r_{be} + (1+\\beta)R_e$。 Step 4：并联。 $$R_i = (\\text{偏置电阻}) // (\\text{晶体管输入电阻})$$ 回到刚才那道题（共射放大，Re被电容旁路）：\n发射极交流接地（情况 A）。 晶体管输入电阻 = $r_{be}$。 总输入电阻 $R_i = R_{b1} // R_{b2} // r_{be}$。 2. 输出电阻 ($R_o$) 分析法 目标：从输出端看进去，把负载 $R_L$ 拔掉后的等效电阻。 核心操作：令输入信号源 $v_s = 0$（短路），然后往里看。\n情况 A：从集电极（Collector）输出（如共射电路）\n当我们把输入信号短路（$v_s=0$），意味着基极没有交流电流 ($i_b=0$)。 既然 $i_b=0$，那么受控电流源 $\\beta i_b$ 也就等于 0（相当于开路/断路）。 结论：你看进去，只能看到一个孤独的集电极电阻 $R_c$。 情况 B：从发射极（Emitter）输出（如射极跟随器）\n这通常是最难的，但用反射规则秒杀。 你站在发射极往里看，看到了什么？看到了内部的 $r_{be}$ 和外部基极的电阻 $R_s$（信号源内阻）或偏置电阻。 记得规则：从 E 看 B，电阻要除以 $(1+\\beta)$。 结论： $$R_o = R_e // \\left[ \\frac{r_{be} + (R_{\\text{基极外部电阻}})}{1+\\beta} \\right]$$ 总结一张表（不再黑盒） 观察位置 看到什么 规则（口诀） 应用场景 从基极看 (B) 看到 $r_{be}$ 串联着 $R_E$ $R_E$ 变大 $(1+\\beta)$ 倍 算输入电阻 (共射/共集) 从集电极看 (C) 看到电流源 (开路) 和 $R_C$ 只剩 $R_C$ (因为 $i_b=0$) 算输出电阻 (共射) 从发射极看 (E) 看到 $r_{be}$ 串联着 $R_B$ $R_B$ 变小 $(1+\\beta)$ 倍 算输出电阻 (共集/射极跟随器) 试着分析刚才的题目： 输入电阻：因为 $R_e$ 被电容短路了，所以从基极看进去，只能看到 $r_{be}$。再加上外部的分压电阻，就是 $R_{b1} // R_{b2} // r_{be}$。 输出电阻：从集电极看进去，输入信号置零，$i_b=0$，电流源断开，只能看到 $R_c$（3kΩ）。 ","date":"2025-11-30T20:08:53+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E6%A8%A1%E7%94%B5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"模电问题记录"},{"content":"测试文件：\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; inline auto add(int x, int y) { return x + y; } auto add_xy(int x, int y) { return x + y; } int main() { int a, b; int c = add(a, b); int d = add_xy(a, b); } c++的编译过程：预处理，编译，汇编，链接\n环境与配置：空手套白狼 指令：g++ -dM -E -x c++ /dev/null 解释： -dM:倾倒出所有的宏 -E:只做预处理 -x c++:把文件当作cpp /dev/null 空输入文件 技巧：用grep命令读取想要的宏 查 C++ 版本：\u0026hellip; | grep __cplusplus 查平台架构：\u0026hellip; | grep -E \u0026ldquo;linux|x86|arm\u0026rdquo; 查类型大小：\u0026hellip; | grep SIZEOF 示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 g++ -dM -E -x c++ /dev/null (base) #define __DBL_MIN_EXP__ (-1021) #define __cpp_nontype_template_parameter_auto 201606L #define __UINT_LEAST16_MAX__ 0xffff #define __FLT16_HAS_QUIET_NAN__ 1 #define __ATOMIC_ACQUIRE 2 #define __FLT128_MAX_10_EXP__ 4932 #define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F #define __GCC_IEC_559_COMPLEX 2 #define __cpp_aggregate_nsdmi 201304L #define __UINT_LEAST8_TYPE__ unsigned char #define __SIZEOF_FLOAT80__ 16 #define __BFLT16_DENORM_MIN__ 9.18354961579912115600575419704879436e-41BF16 #define __INTMAX_C(c) c ## L #define __CHAR_BIT__ 8 #define __UINT8_MAX__ 0xff #define __SCHAR_WIDTH__ 8 #define __WINT_MAX__ 0xffffffffU #define __FLT32_MIN_EXP__ (-125) #define __cpp_static_assert 201411L #define __BFLT16_MIN_10_EXP__ (-37) #define __ORDER_LITTLE_ENDIAN__ 1234 #define __WCHAR_MAX__ 0x7fffffff #define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1 #define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1 #define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1 #define __GCC_ATOMIC_CHAR_LOCK_FREE 2 #define __GCC_IEC_559 2 #define __FLT32X_DECIMAL_DIG__ 17 #define __FLT_EVAL_METHOD__ 0 #define __cpp_binary_literals 201304L #define __FLT64_DECIMAL_DIG__ 17 #define __CET__ 3 #define __cpp_noexcept_function_type 201510L #define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2 #define __cpp_variadic_templates 200704L #define __UINT_FAST64_MAX__ 0xffffffffffffffffUL #define __SIG_ATOMIC_TYPE__ int #define __DBL_MIN_10_EXP__ (-307) #define __FINITE_MATH_ONLY__ 0 #define __cpp_variable_templates 201304L #define __FLT32X_MAX_EXP__ 1024 #define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1 #define __FLT32_HAS_DENORM__ 1 #define __UINT_FAST8_MAX__ 0xff #define __cpp_rvalue_reference 200610L #define __cpp_nested_namespace_definitions 201411L #define __DEC64_MAX_EXP__ 385 #define __INT8_C(c) c #define __LDBL_HAS_INFINITY__ 1 #define __INT_LEAST8_WIDTH__ 8 #define __cpp_variadic_using 201611L #define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL #define __INT_LEAST8_MAX__ 0x7f #define __cpp_attributes 200809L #define __cpp_capture_star_this 201603L #define __SHRT_MAX__ 0x7fff #define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L #define __FLT64X_MAX_10_EXP__ 4932 #define __cpp_if_constexpr 201606L #define __BFLT16_MAX_10_EXP__ 38 #define __BFLT16_MAX_EXP__ 128 #define __LDBL_IS_IEC_60559__ 1 #define __FLT64X_HAS_QUIET_NAN__ 1 #define __UINT_LEAST8_MAX__ 0xff #define __GCC_ATOMIC_BOOL_LOCK_FREE 2 #define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128 #define __UINTMAX_TYPE__ long unsigned int #define __cpp_nsdmi 200809L #define __BFLT16_DECIMAL_DIG__ 4 #define __linux 1 #define __DEC32_EPSILON__ 1E-6DF #define __FLT_EVAL_METHOD_TS_18661_3__ 0 #define __UINT32_MAX__ 0xffffffffU #define __GXX_EXPERIMENTAL_CXX0X__ 1 #define __DBL_DENORM_MIN__ double(4.94065645841246544176568792868221372e-324L) #define __FLT128_MIN_EXP__ (-16381) #define __WINT_MIN__ 0U #define __FLT128_MIN_10_EXP__ (-4931) #define __FLT32X_IS_IEC_60559__ 1 #define __INT_LEAST16_WIDTH__ 16 #define __SCHAR_MAX__ 0x7f #define __FLT128_MANT_DIG__ 113 #define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1) #define __INT64_C(c) c ## L #define __SSP_STRONG__ 3 #define __GCC_ATOMIC_POINTER_LOCK_FREE 2 #define __ATOMIC_SEQ_CST 5 #define __unix 1 #define __INT_LEAST64_MAX__ 0x7fffffffffffffffL #define __FLT32X_MANT_DIG__ 53 #define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2 #define __cpp_aligned_new 201606L #define __FLT32_MAX_10_EXP__ 38 #define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x #define __STDC_HOSTED__ 1 #define __DEC64_MIN_EXP__ (-382) #define __cpp_decltype_auto 201304L #define __DBL_DIG__ 15 #define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F #define __GXX_WEAK__ 1 #define __SHRT_WIDTH__ 16 #define __FLT32_IS_IEC_60559__ 1 #define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L #define __DBL_IS_IEC_60559__ 1 #define __DEC32_MAX__ 9.999999E96DF #define __cpp_threadsafe_static_init 200806L #define __cpp_enumerator_attributes 201411L #define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x #define __FLT32X_HAS_INFINITY__ 1 #define __unix__ 1 #define __INT_WIDTH__ 32 #define __STDC_IEC_559__ 1 #define __STDC_ISO_10646__ 201706L #define __DECIMAL_DIG__ 21 #define __STDC_IEC_559_COMPLEX__ 1 #define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64 #define __gnu_linux__ 1 #define __INT16_MAX__ 0x7fff #define __FLT64_MIN_EXP__ (-1021) #define __FLT64X_MIN_10_EXP__ (-4931) #define __LDBL_HAS_QUIET_NAN__ 1 #define __cpp_return_type_deduction 201304L #define __FLT16_MIN_EXP__ (-13) #define __FLT64_MANT_DIG__ 53 #define __FLT64X_MANT_DIG__ 64 #define __BFLT16_DIG__ 2 #define __GNUC__ 13 #define __GXX_RTTI 1 #define __pie__ 2 #define __MMX__ 1 #define __FLT_HAS_DENORM__ 1 #define __SIZEOF_LONG_DOUBLE__ 16 #define __BIGGEST_ALIGNMENT__ 16 #define __STDC_UTF_16__ 1 #define __FLT64_MAX_10_EXP__ 308 #define __BFLT16_IS_IEC_60559__ 0 #define __FLT16_MAX_10_EXP__ 4 #define __cpp_delegating_constructors 200604L #define __DBL_MAX__ double(1.79769313486231570814527423731704357e+308L) #define __cpp_raw_strings 200710L #define __INT_FAST32_MAX__ 0x7fffffffffffffffL #define __DBL_HAS_INFINITY__ 1 #define __INT64_MAX__ 0x7fffffffffffffffL #define __SIZEOF_FLOAT__ 4 #define __HAVE_SPECULATION_SAFE_VALUE 1 #define __cpp_fold_expressions 201603L #define __DEC32_MIN_EXP__ (-94) #define __INTPTR_WIDTH__ 64 #define __UINT_LEAST32_MAX__ 0xffffffffU #define __FLT32X_HAS_DENORM__ 1 #define __INT_FAST16_TYPE__ long int #define __MMX_WITH_SSE__ 1 #define __LDBL_HAS_DENORM__ 1 #define __SEG_GS 1 #define __BFLT16_EPSILON__ 7.81250000000000000000000000000000000e-3BF16 #define __cplusplus 201703L #define __cpp_ref_qualifiers 200710L #define __DEC32_MIN__ 1E-95DF #define __DEPRECATED 1 #define __cpp_rvalue_references 200610L #define __DBL_MAX_EXP__ 1024 #define __WCHAR_WIDTH__ 32 #define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32 #define __DEC128_EPSILON__ 1E-33DL #define __FLT16_DECIMAL_DIG__ 5 #define __SSE2_MATH__ 1 #define __ATOMIC_HLE_RELEASE 131072 #define __PTRDIFF_MAX__ 0x7fffffffffffffffL #define __amd64 1 #define __ATOMIC_HLE_ACQUIRE 65536 #define __GNUG__ 13 #define __LONG_LONG_MAX__ 0x7fffffffffffffffLL #define __SIZEOF_SIZE_T__ 8 #define __BFLT16_HAS_INFINITY__ 1 #define __FLT64X_MIN_EXP__ (-16381) #define __SIZEOF_WINT_T__ 4 #define __FLT32X_DIG__ 15 #define __LONG_LONG_WIDTH__ 64 #define __cpp_initializer_lists 200806L #define __FLT32_MAX_EXP__ 128 #define __cpp_hex_float 201603L #define __GXX_ABI_VERSION 1018 #define __FLT_MIN_EXP__ (-125) #define __GCC_HAVE_DWARF2_CFI_ASM 1 #define __x86_64 1 #define __cpp_lambdas 200907L #define __INT_FAST64_TYPE__ long int #define __BFLT16_MAX__ 3.38953138925153547590470800371487867e+38BF16 #define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64 #define __cpp_template_auto 201606L #define __FLT16_DENORM_MIN__ 5.96046447753906250000000000000000000e-8F16 #define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128 #define __FLT64X_NORM_MAX__ 1.18973149535723176502126385303097021e+4932F64x #define __SIZEOF_POINTER__ 8 #define __SIZE_TYPE__ long unsigned int #define __LP64__ 1 #define __DBL_HAS_QUIET_NAN__ 1 #define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x #define __LDBL_MAX_EXP__ 16384 #define __DECIMAL_BID_FORMAT__ 1 #define __FLT64_MIN_10_EXP__ (-307) #define __FLT16_MIN_10_EXP__ (-4) #define __FLT64X_DECIMAL_DIG__ 21 #define __DEC128_MIN__ 1E-6143DL #define __REGISTER_PREFIX__ #define __UINT16_MAX__ 0xffff #define __FLT128_HAS_INFINITY__ 1 #define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32 #define __UINT8_TYPE__ unsigned char #define __FLT_DIG__ 6 #define __NO_INLINE__ 1 #define __DEC_EVAL_METHOD__ 2 #define __FLT_MANT_DIG__ 24 #define __LDBL_DECIMAL_DIG__ 21 #define __VERSION__ \u0026#34;13.3.0\u0026#34; #define __UINT64_C(c) c ## UL #define __cpp_unicode_characters 201411L #define _STDC_PREDEF_H 1 #define __INT_LEAST32_MAX__ 0x7fffffff #define __GCC_ATOMIC_INT_LOCK_FREE 2 #define __FLT128_MAX_EXP__ 16384 #define __FLT32_MANT_DIG__ 24 #define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__ #define __FLT32X_MIN_EXP__ (-1021) #define __STDC_IEC_60559_COMPLEX__ 201404L #define __cpp_aggregate_bases 201603L #define __BFLT16_MIN__ 1.17549435082228750796873653722224568e-38BF16 #define __FLT128_HAS_DENORM__ 1 #define __FLT32_DECIMAL_DIG__ 9 #define __FLT128_DIG__ 33 #define __INT32_C(c) c #define __DEC64_EPSILON__ 1E-15DD #define __ORDER_PDP_ENDIAN__ 3412 #define __DEC128_MIN_EXP__ (-6142) #define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL #define __INT_FAST32_TYPE__ long int #define __UINT_LEAST16_TYPE__ short unsigned int #define __DEC128_MAX_EXP__ 6145 #define unix 1 #define __DBL_HAS_DENORM__ 1 #define __cpp_rtti 199711L #define __UINT64_MAX__ 0xffffffffffffffffUL #define __FLT_IS_IEC_60559__ 1 #define __GNUC_WIDE_EXECUTION_CHARSET_NAME \u0026#34;UTF-32LE\u0026#34; #define __FLT64X_DIG__ 18 #define __INT8_TYPE__ signed char #define __cpp_digit_separators 201309L #define __ELF__ 1 #define __GCC_ASM_FLAG_OUTPUTS__ 1 #define __UINT32_TYPE__ unsigned int #define __BFLT16_HAS_QUIET_NAN__ 1 #define __FLT_RADIX__ 2 #define __INT_LEAST16_TYPE__ short int #define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L #define __UINTMAX_C(c) c ## UL #define __FLT16_DIG__ 3 #define __k8 1 #define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x #define __SIG_ATOMIC_MAX__ 0x7fffffff #define __cpp_constexpr 201603L #define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2 #define __USER_LABEL_PREFIX__ #define __STDC_IEC_60559_BFP__ 201404L #define __SIZEOF_PTRDIFF_T__ 8 #define __FLT64X_HAS_INFINITY__ 1 #define __SIZEOF_LONG__ 8 #define __LDBL_DIG__ 18 #define __FLT64_IS_IEC_60559__ 1 #define __x86_64__ 1 #define __FLT16_IS_IEC_60559__ 1 #define __FLT16_MAX_EXP__ 16 #define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF #define __INT_FAST16_MAX__ 0x7fffffffffffffffL #define __GCC_CONSTRUCTIVE_SIZE 64 #define __FLT64_DIG__ 15 #define __UINT_FAST32_MAX__ 0xffffffffffffffffUL #define __UINT_LEAST64_TYPE__ long unsigned int #define __FLT16_EPSILON__ 9.76562500000000000000000000000000000e-4F16 #define __FLT_HAS_QUIET_NAN__ 1 #define __FLT_MAX_10_EXP__ 38 #define __LONG_MAX__ 0x7fffffffffffffffL #define __FLT64X_HAS_DENORM__ 1 #define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL #define __FLT_HAS_INFINITY__ 1 #define __GNUC_EXECUTION_CHARSET_NAME \u0026#34;UTF-8\u0026#34; #define __cpp_unicode_literals 200710L #define __UINT_FAST16_TYPE__ long unsigned int #define __DEC64_MAX__ 9.999999999999999E384DD #define __INT_FAST32_WIDTH__ 64 #define __CHAR16_TYPE__ short unsigned int #define __PRAGMA_REDEFINE_EXTNAME 1 #define __SIZE_WIDTH__ 64 #define __SEG_FS 1 #define __INT_LEAST16_MAX__ 0x7fff #define __FLT16_NORM_MAX__ 6.55040000000000000000000000000000000e+4F16 #define __DEC64_MANT_DIG__ 16 #define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32 #define __SIG_ATOMIC_WIDTH__ 32 #define __INT_LEAST64_TYPE__ long int #define __INT16_TYPE__ short int #define __INT_LEAST8_TYPE__ signed char #define __FLT16_MAX__ 6.55040000000000000000000000000000000e+4F16 #define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128 #define __cpp_structured_bindings 201606L #define __SIZEOF_INT__ 4 #define __DEC32_MAX_EXP__ 97 #define __INT_FAST8_MAX__ 0x7f #define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128 #define __INTPTR_MAX__ 0x7fffffffffffffffL #define __cpp_sized_deallocation 201309L #define __cpp_guaranteed_copy_elision 201606L #define linux 1 #define __FLT64_HAS_QUIET_NAN__ 1 #define __FLT32_MIN_10_EXP__ (-37) #define __EXCEPTIONS 1 #define __UINT16_C(c) c #define __PTRDIFF_WIDTH__ 64 #define __LDBL_MANT_DIG__ 64 #define __cpp_range_based_for 201603L #define __INT_FAST16_WIDTH__ 64 #define __FLT64_HAS_INFINITY__ 1 #define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x #define __FLT16_HAS_INFINITY__ 1 #define __STDCPP_DEFAULT_NEW_ALIGNMENT__ 16 #define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1) #define __code_model_small__ 1 #define __GCC_ATOMIC_LONG_LOCK_FREE 2 #define __cpp_nontype_template_args 201411L #define __DEC32_MANT_DIG__ 7 #define __k8__ 1 #define __INTPTR_TYPE__ long int #define __UINT16_TYPE__ short unsigned int #define __WCHAR_TYPE__ int #define __pic__ 2 #define __UINTPTR_MAX__ 0xffffffffffffffffUL #define __INT_FAST64_WIDTH__ 64 #define __cpp_decltype 200707L #define __INT_FAST64_MAX__ 0x7fffffffffffffffL #define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1 #define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F #define __FLT32_HAS_INFINITY__ 1 #define __FLT64X_MAX_EXP__ 16384 #define __UINT_FAST64_TYPE__ long unsigned int #define __cpp_inline_variables 201606L #define __BFLT16_MIN_EXP__ (-125) #define __INT_MAX__ 0x7fffffff #define __linux__ 1 #define __INT64_TYPE__ long int #define __FLT_MAX_EXP__ 128 #define __ORDER_BIG_ENDIAN__ 4321 #define __DBL_MANT_DIG__ 53 #define __cpp_inheriting_constructors 201511L #define __SIZEOF_FLOAT128__ 16 #define __BFLT16_MANT_DIG__ 8 #define __DEC64_MIN__ 1E-383DD #define __WINT_TYPE__ unsigned int #define __UINT_LEAST32_TYPE__ unsigned int #define __SIZEOF_SHORT__ 2 #define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32 #define __SSE__ 1 #define __LDBL_MIN_EXP__ (-16381) #define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64 #define __amd64__ 1 #define __WINT_WIDTH__ 32 #define __INT_LEAST64_WIDTH__ 64 #define __FLT32X_MAX_10_EXP__ 308 #define __cpp_namespace_attributes 201411L #define __SIZEOF_INT128__ 16 #define __FLT16_MIN__ 6.10351562500000000000000000000000000e-5F16 #define __FLT64X_IS_IEC_60559__ 1 #define __LDBL_MAX_10_EXP__ 4932 #define __ATOMIC_RELAXED 0 #define __DBL_EPSILON__ double(2.22044604925031308084726333618164062e-16L) #define __INT_LEAST32_TYPE__ int #define _LP64 1 #define __UINT8_C(c) c #define __FLT64_MAX_EXP__ 1024 #define __SIZEOF_WCHAR_T__ 4 #define __GNUC_PATCHLEVEL__ 0 #define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128 #define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64 #define __FLT128_HAS_QUIET_NAN__ 1 #define __INTMAX_MAX__ 0x7fffffffffffffffL #define __INT_FAST8_TYPE__ signed char #define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x #define __STDCPP_THREADS__ 1 #define __BFLT16_HAS_DENORM__ 1 #define __GNUC_STDC_INLINE__ 1 #define __FLT64_HAS_DENORM__ 1 #define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32 #define __FLT16_HAS_DENORM__ 1 #define __DBL_DECIMAL_DIG__ 17 #define __STDC_UTF_32__ 1 #define __INT_FAST8_WIDTH__ 8 #define __FXSR__ 1 #define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x #define __DBL_NORM_MAX__ double(1.79769313486231570814527423731704357e+308L) #define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__ #define __GCC_DESTRUCTIVE_SIZE 64 #define __INTMAX_WIDTH__ 64 #define __cpp_runtime_arrays 198712L #define __FLT32_DIG__ 6 #define __UINT64_TYPE__ long unsigned int #define __UINT32_C(c) c ## U #define __cpp_alias_templates 200704L #define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F #define __FLT128_IS_IEC_60559__ 1 #define __INT8_MAX__ 0x7f #define __LONG_WIDTH__ 64 #define __DBL_MIN__ double(2.22507385850720138309023271733240406e-308L) #define __PIC__ 2 #define __INT32_MAX__ 0x7fffffff #define __UINT_FAST32_TYPE__ long unsigned int #define __FLT16_MANT_DIG__ 11 #define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x #define __CHAR32_TYPE__ unsigned int #define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F #define __SSE2__ 1 #define __cpp_deduction_guides 201703L #define __BFLT16_NORM_MAX__ 3.38953138925153547590470800371487867e+38BF16 #define __INT32_TYPE__ int #define __SIZEOF_DOUBLE__ 8 #define __cpp_exceptions 199711L #define __FLT_MIN_10_EXP__ (-37) #define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64 #define __INT_LEAST32_WIDTH__ 32 #define __INTMAX_TYPE__ long int #define __GLIBCXX_BITSIZE_INT_N_0 128 #define __FLT32X_HAS_QUIET_NAN__ 1 #define __ATOMIC_CONSUME 1 #define __GNUC_MINOR__ 3 #define __GLIBCXX_TYPE_INT_N_0 __int128 #define __UINTMAX_MAX__ 0xffffffffffffffffUL #define __PIE__ 2 #define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x #define __cpp_template_template_args 201611L #define __DBL_MAX_10_EXP__ 308 #define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L #define __INT16_C(c) c #define __STDC__ 1 #define __PTRDIFF_TYPE__ long int #define __FLT32X_MIN_10_EXP__ (-307) #define __UINTPTR_TYPE__ long unsigned int #define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD #define __DEC128_MANT_DIG__ 34 #define __LDBL_MIN_10_EXP__ (-4931) #define __cpp_generic_lambdas 201304L #define __SSE_MATH__ 1 #define __SIZEOF_LONG_LONG__ 8 #define __cpp_user_defined_literals 200809L #define __FLT128_DECIMAL_DIG__ 36 #define __GCC_ATOMIC_LLONG_LOCK_FREE 2 #define __FLT32_HAS_QUIET_NAN__ 1 #define __FLT_DECIMAL_DIG__ 9 #define __UINT_FAST16_MAX__ 0xffffffffffffffffUL #define __LDBL_NORM_MAX__ 1.18973149535723176502126385303097021e+4932L #define __GCC_ATOMIC_SHORT_LOCK_FREE 2 #define __SIZE_MAX__ 0xffffffffffffffffUL #define __UINT_FAST8_TYPE__ unsigned char #define _GNU_SOURCE 1 #define __cpp_init_captures 201304L #define __ATOMIC_ACQ_REL 4 #define __ATOMIC_RELEASE 3 预处理 预处理：展开#include，替换#define，处理#ifdef\n头文件引用树 -H 用法：g++ -H 文件名 示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 g++ -H simple.cpp (base) . /usr/include/stdio.h .. /usr/include/x86_64-linux-gnu/bits/libc-header-start.h ... /usr/include/features.h .... /usr/include/features-time64.h ..... /usr/include/x86_64-linux-gnu/bits/wordsize.h ..... /usr/include/x86_64-linux-gnu/bits/timesize.h ...... /usr/include/x86_64-linux-gnu/bits/wordsize.h .... /usr/include/x86_64-linux-gnu/sys/cdefs.h ..... /usr/include/x86_64-linux-gnu/bits/wordsize.h ..... /usr/include/x86_64-linux-gnu/bits/long-double.h .... /usr/include/x86_64-linux-gnu/gnu/stubs.h ..... /usr/include/x86_64-linux-gnu/gnu/stubs-64.h .. /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h .. /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h .. /usr/include/x86_64-linux-gnu/bits/types.h ... /usr/include/x86_64-linux-gnu/bits/wordsize.h ... /usr/include/x86_64-linux-gnu/bits/timesize.h .... /usr/include/x86_64-linux-gnu/bits/wordsize.h ... /usr/include/x86_64-linux-gnu/bits/typesizes.h ... /usr/include/x86_64-linux-gnu/bits/time64.h .. /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h ... /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h .. /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h .. /usr/include/x86_64-linux-gnu/bits/types/__FILE.h .. /usr/include/x86_64-linux-gnu/bits/types/FILE.h .. /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h .. /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h .. /usr/include/x86_64-linux-gnu/bits/stdio_lim.h .. /usr/include/x86_64-linux-gnu/bits/floatn.h ... /usr/include/x86_64-linux-gnu/bits/floatn-common.h .... /usr/include/x86_64-linux-gnu/bits/long-double.h Multiple include guards may be useful for: /usr/include/features-time64.h /usr/include/x86_64-linux-gnu/bits/libc-header-start.h /usr/include/x86_64-linux-gnu/bits/time64.h /usr/include/x86_64-linux-gnu/bits/typesizes.h /usr/include/x86_64-linux-gnu/gnu/stubs-64.h /usr/include/x86_64-linux-gnu/gnu/stubs.h /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h gcc的冗长模式：一网打尽 (-v) 命令：g++ -v 文件名 示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 g++ -v simple.cpp (base) Using built-in specs. COLLECT_GCC=g++ COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-linux-gnu/13/lto-wrapper OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa OFFLOAD_TARGET_DEFAULT=1 Target: x86_64-linux-gnu Configured with: ../src/configure -v --with-pkgversion=\u0026#39;Ubuntu 13.3.0-6ubuntu2~24.04\u0026#39; --with-bugurl=file:///usr/share/doc/gcc-13/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++,m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-13 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/libexec --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-libstdcxx-backtrace --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-13-fG75Ri/gcc-13-13.3.0/debian/tmp-nvptx/usr,amdgcn-amdhsa=/build/gcc-13-fG75Ri/gcc-13-13.3.0/debian/tmp-gcn/usr --enable-offload-defaulted --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2 Thread model: posix Supported LTO compression algorithms: zlib zstd gcc version 13.3.0 (Ubuntu 13.3.0-6ubuntu2~24.04) COLLECT_GCC_OPTIONS=\u0026#39;-v\u0026#39; \u0026#39;-shared-libgcc\u0026#39; \u0026#39;-mtune=generic\u0026#39; \u0026#39;-march=x86-64\u0026#39; \u0026#39;-dumpdir\u0026#39; \u0026#39;a-\u0026#39; /usr/libexec/gcc/x86_64-linux-gnu/13/cc1plus -quiet -v -imultiarch x86_64-linux-gnu -D_GNU_SOURCE simple.cpp -quiet -dumpdir a- -dumpbase simple.cpp -dumpbase-ext .cpp -mtune=generic -march=x86-64 -version -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/cclUwaRn.s GNU C++17 (Ubuntu 13.3.0-6ubuntu2~24.04) version 13.3.0 (x86_64-linux-gnu) compiled by GNU C version 13.3.0, GMP version 6.3.0, MPFR version 4.2.1, MPC version 1.3.1, isl version isl-0.26-GMP GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072 ignoring duplicate directory \u0026#34;/usr/include/x86_64-linux-gnu/c++/13\u0026#34; ignoring nonexistent directory \u0026#34;/usr/local/include/x86_64-linux-gnu\u0026#34; ignoring nonexistent directory \u0026#34;/usr/lib/gcc/x86_64-linux-gnu/13/include-fixed/x86_64-linux-gnu\u0026#34; ignoring nonexistent directory \u0026#34;/usr/lib/gcc/x86_64-linux-gnu/13/include-fixed\u0026#34; ignoring nonexistent directory \u0026#34;/usr/lib/gcc/x86_64-linux-gnu/13/../../../../x86_64-linux-gnu/include\u0026#34; #include \u0026#34;...\u0026#34; search starts here: #include \u0026lt;...\u0026gt; search starts here: /usr/include/c++/13 /usr/include/x86_64-linux-gnu/c++/13 /usr/include/c++/13/backward /usr/lib/gcc/x86_64-linux-gnu/13/include /usr/local/include /usr/include/x86_64-linux-gnu /usr/include End of search list. Compiler executable checksum: c81c05345ce537099dafd5580045814a COLLECT_GCC_OPTIONS=\u0026#39;-v\u0026#39; \u0026#39;-shared-libgcc\u0026#39; \u0026#39;-mtune=generic\u0026#39; \u0026#39;-march=x86-64\u0026#39; \u0026#39;-dumpdir\u0026#39; \u0026#39;a-\u0026#39; as -v --64 -o /tmp/ccKEJBaY.o /tmp/cclUwaRn.s GNU assembler version 2.42 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.42 COMPILER_PATH=/usr/libexec/gcc/x86_64-linux-gnu/13/:/usr/libexec/gcc/x86_64-linux-gnu/13/:/usr/libexec/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/13/:/usr/lib/gcc/x86_64-linux-gnu/ LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/13/:/usr/lib/gcc/x86_64-linux-gnu/13/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/13/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/13/../../../:/lib/:/usr/lib/ COLLECT_GCC_OPTIONS=\u0026#39;-v\u0026#39; \u0026#39;-shared-libgcc\u0026#39; \u0026#39;-mtune=generic\u0026#39; \u0026#39;-march=x86-64\u0026#39; \u0026#39;-dumpdir\u0026#39; \u0026#39;a.\u0026#39; /usr/libexec/gcc/x86_64-linux-gnu/13/collect2 -plugin /usr/libexec/gcc/x86_64-linux-gnu/13/liblto_plugin.so -plugin-opt=/usr/libexec/gcc/x86_64-linux-gnu/13/lto-wrapper -plugin-opt=-fresolution=/tmp/ccWd4zaK.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro /usr/lib/gcc/x86_64-linux-gnu/13/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/13/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/13/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/13 -L/usr/lib/gcc/x86_64-linux-gnu/13/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/13/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/13/../../.. /tmp/ccKEJBaY.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/13/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/13/../../../x86_64-linux-gnu/crtn.o COLLECT_GCC_OPTIONS=\u0026#39;-v\u0026#39; \u0026#39;-shared-libgcc\u0026#39; \u0026#39;-mtune=generic\u0026#39; \u0026#39;-march=x86-64\u0026#39; \u0026#39;-dumpdir\u0026#39; \u0026#39;a.\u0026#39; 编译阶段 编译：将代码汇编成汇编代码，然后翻译成机器码\n汇编显微镜(-S) 命令：g++ -S -fverbose-asm file1.cpp -o file2.s 解释： -S:到生成汇编这一步 -fverbose-asm:它会把原本的 C++ 变量名、函数名作为注释写在汇编指令旁边。 示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 g++ -S -fverbose-asm simple.cpp -o simple.s 21 │ movl -8(%rbp), %eax # b, tmp89 22 │ addl %edx, %eax # tmp88, tmp87 23 │ movl %eax, -4(%rbp) # tmp87, c 24 │ # simple.cpp:5: } 25 │ movl $0, %eax #, _4 26 │ popq %rbp # 27 │ .cfi_def_cfa 7, 8 28 │ ret 29 │ .cfi_endproc 30 │ .LFE0: 31 │ .size main, .-main 32 │ .ident \u0026#34;GCC: (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0\u0026#34; 33 │ .section .note.GNU-stack,\u0026#34;\u0026#34;,@progbits 34 │ .section .note.gnu.property,\u0026#34;a\u0026#34; 35 │ .align 8 36 │ .long 1f - 0f 37 │ .long 4f - 1f 38 │ .long 5 39 │ 0: 40 │ .string \u0026#34;GNU\u0026#34; 41 │ 1: 42 │ .align 8 43 │ .long 0xc0000002 44 │ .long 3f - 2f 45 │ 2: 46 │ .long 0x3 47 │ 3: 48 │ .align 8 49 │ 4: 链接阶段 C++ 支持函数重载（Overloading，即多个函数可以叫同一个名字，只要参数不同）。 为了让链接器（Linker）区分 void foo(int) 和 void foo(double)，编译器会把函数名改成一串独一无二的“乱码”。\nfoo(int) 可能变成 -\u0026gt; _Z3fooi foo(double) 可能变成 -\u0026gt; _Z3food 1. c++filt：乱码翻译机 它的作用：把那串看不懂的“乱码”还原回人类能读懂的 C++ 函数名。\n场景： 你编译时报错了： undefined reference to '_Z3addii' 你一脸懵逼，_Z3addii 是什么鬼？我代码里没写过这个啊。\n用法：\n1 c++filt _Z3addii 输出：\n1 add(int, int) 真相大白：原来是你调用了 add(int, int) 这个函数，但是链接器找不到它的实现。\n2. nm：透视眼（查看符号表） 它的作用：列出一个二进制文件（.o 目标文件, .a 静态库, .so 动态库, 或者可执行文件）里到底包含哪些函数和变量。\nnm 是 \u0026ldquo;Name List\u0026rdquo; 的缩写。\n场景： 你明确知道自己写了 add(int, int)，并且也编译成了 libmath.a，但链接器死活报错说找不到（Undefined reference）。你想确认一下：我的库文件里到底有没有把这个函数编译进去？\n用法： 通常配合 -C 参数使用（-C 相当于自动调用了 c++filt，直接显示人话）。\n1 nm -C libmath.a 输出解读（最关键的部分）： 输出会有三列：[地址] [类型] [名字]。你只需要关注中间的类型字母：\nT (Text)：我有这个函数！ 表示这个函数是在当前文件里**定义（实现了）**的。 例：0000000 T add(int, int) -\u0026gt; 说明 libmath.a 里确实有 add 函数的实体。 U (Undefined)：我用到了它，但我没它！ 表示当前文件调用了这个函数，但是没找到它的定义，需要去别的地方链接。 例： U printf -\u0026gt; 说明你的代码用了 printf，链接器需要去系统库里找它。 优化阶段 (-fopt-info) 命令： g++ -O3 -fopt-info-vec test.cpp g++ -O3 -fopt-info-vec-missed test.cpp g++ -O3 -fopt-info-inline test.cpp g++ -O3 -fopt-info-all test.cpp 示例： 1 2 3 4 5 6 7 8 9 10 11 g++ -O3 -fopt-info-all simple.cpp (base) simple.cpp:7:17: note: Considering inline candidate auto add_xy(int, int)/31. simple.cpp:7:17: optimized: Inlining auto add_xy(int, int)/31 into int main()/32. simple.cpp:6:14: note: Considering inline candidate auto add(int, int)/30. simple.cpp:6:14: optimized: Inlining auto add(int, int)/30 into int main()/32. Unit growth for small function inlining: 7-\u0026gt;7 (0%) Inlined 2 calls, eliminated 1 functions simple.cpp:3:40: note: ***** Analysis failed with vector mode VOID simple.cpp:8:1: note: ***** Analysis failed with vector mode VOID 总结 极简速查表 场景 命令核心 作用 查环境/版本 g++ -dM -E -x c++ /dev/null 打印预定义宏、版本号、平台信息 查头文件路径 g++ -v -x c++ /dev/null 显示 #include 搜索目录列表 查引用关系 g++ -H ... 打印头文件包含树状图 查汇编代码 g++ -S -fverbose-asm ... 生成带 C++ 变量注释的汇编代码 查库/对象符号 nm -C ... 查看 .o 或 .a 文件里有哪些函数(T/U) 解乱码符号 c++filt ... 将 _Z... 还原为人类可读函数名 查优化细节 g++ -fopt-info ... 让编译器报告向量化/内联结果 查完整流水线 g++ -v ... 显示预处理、编译、汇编、链接全过程指令 ","date":"2025-11-30T00:10:08+08:00","permalink":"https://demo.stack.jimmycai.com/post/gcc%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95/","title":"Gcc的黑魔法"},{"content":"GCC编译命令黑魔法全面深刻详细总结 核心理念：GCC不仅是编译器，更是代码解剖刀。掌握这些魔法，让你从\u0026quot;写代码的程序员\u0026quot;蜕变为\u0026quot;掌控编译器的大师\u0026quot;。当遇到链接错误、性能瓶颈或宏定义冲突时，你能像外科医生般精准定位问题根源。\n一、编译流水线全景透视 C++编译是四阶段流水线：预处理→编译→汇编→链接。每个阶段都有专属魔法：\n预处理阶段：透视宏与依赖的显微镜 终极宏侦探（核心魔法）\n1 g++ -dM -E -x c++ /dev/null | grep __cplusplus 原理：-dM输出所有预定义宏，-E仅预处理，-x c++指定语言，/dev/null作为空输入 实战：快速确认编译器支持的C++标准（-std=c++17/c++20等） 进阶：去掉grep查看所有1600+预定义宏，理解编译器内置特性 头文件依赖树（解决编译慢/重复定义）\n1 g++ -H your_code.cpp 2\u0026gt; deps.log 深度技巧：重定向到文件(2\u0026gt;)避免污染屏幕，用grep -v '\u0026lt;stdin\u0026gt;' deps.log过滤噪声 案例：发现某第三方库间接包含了30个无用头文件，通过#pragma once优化编译速度47% 头文件搜索路径侦察\n1 g++ -v -x c++ /dev/null 2\u0026gt;\u0026amp;1 | sed -n \u0026#39;/#include/,/End of search list/p\u0026#39; 关键细节：#include \u0026quot;...\u0026quot;优先当前目录，#include \u0026lt;...\u0026gt;搜索系统路径 解决经典问题：WSL中cannot find \u0026lt;openssl/ssl.h\u0026gt;，通过对比路径发现未安装libssl-dev 宏展开可视化\n1 g++ -E -dD your_code.cpp | less -dD魔法：保留所有宏定义指令，清晰展示#define替换过程 调试场景：定位MAX(a,b)宏在MAX(x++, y++)中产生的副作用 编译与汇编阶段：代码与机器的桥梁 带注释的汇编代码（性能分析圣杯）\n1 g++ -S -fverbose-asm -O2 your_code.cpp -o your_code.s 核心价值：注释中保留C++变量名，如movl $10, -4(%rbp) # a 实战案例：验证std::string_view是否真正避免拷贝——汇编中无call memcpy即证明零拷贝 进阶：结合-masm=intel生成Intel语法汇编，更易读 架构特定优化\n1 g++ -march=native -mtune=native -O3 your_code.cpp -march=native：自动启用CPU所有指令集（AVX2/AVX-512） -mtune=native：针对当前CPU微架构优化指令调度 性能提升：在Intel Ice Lake上向量化循环提速3.8倍 中间表示(IR)窥探\n1 g++ -fdump-tree-all -O2 your_code.cpp 生成30+文件：.original（原始代码）, .optimized（优化后）, .vect（向量化信息） 专家级用例：分析为何编译器拒绝内联某个函数，直接查看GIMPLE中间表示 链接阶段：符号世界的解密者 符号粉碎还原术（解决undefined reference）\n1 2 c++filt _ZN3FooC1Ev # 输出: Foo::Foo() 原理：C++ Name Mangling将Foo::Foo()编码为_ZN3FooC1Ev 链接错误诊断：将报错中的乱码通过c++filt还原，精准定位缺失函数 目标文件符号审计\n1 nm -C --defined-only your_lib.a | grep \u0026#34; T \u0026#34; -C：自动解码C++符号 --defined-only：仅显示已定义符号 T：标记代码段符号（Text section） 实战：确认静态库是否包含void calculate()的实现，避免链接时缺失 链接过程全追踪\n1 g++ -Wl,--verbose your_code.cpp 2\u0026gt; link.log 关键线索：在link.log中搜索attempt to open查看库搜索顺序 经典问题：解决\u0026quot;multiple definition of vtable for X\u0026quot;，通过日志发现重复链接了两个版本的库 优化阶段：编译器的思维解码 向量化优化报告（性能调优核心）\n1 g++ -O3 -fopt-info-vec-optimized=vec.log your_code.cpp 输出示例：\nvec.cpp:23:15: optimized: loop vectorized using 32 byte vectors 深度解读：32字节向量=AVX2指令，若显示16字节则仅用SSE 内联决策分析\n1 g++ -O2 -fopt-info-inline-missed=inline.log your_code.cpp 典型拒绝原因： function too large（函数体超过阈值） recursive function（递归函数无法内联） noinline attribute（显式禁止内联） 未优化代码诊断\n1 g++ -O3 -fopt-info-loop-missed=loop.log your_code.cpp 关键信息：\nloop.cpp:10:3: missed: couldn't vectorize loop\nloop.cpp:10:3: missed: not vectorized: data alignment issues 解决方案：用__attribute__((aligned(32)))对齐数据 二、黑魔法军火库（实战速查表） 场景 命令/组合 价值等级 快速检查C++标准 g++ -dM -E -x c++ /dev/null | grep __cplusplus ⭐⭐⭐⭐⭐ 头文件依赖分析 g++ -H -E your_file.cpp 2\u0026gt; deps.txt \u0026amp;\u0026amp; sed '/^\\. /d' deps.txt ⭐⭐⭐⭐ 汇编级性能分析 g++ -S -fverbose-asm -O3 -masm=intel perf.cpp + grep -A20 'main:' ⭐⭐⭐⭐⭐ 符号冲突诊断 nm -C lib1.a lib2.a | sort | uniq -d ⭐⭐⭐⭐ 链接路径审计 g++ -Wl,-t your_code.cpp 2\u0026gt;\u0026amp;1 | grep 'lib.*\\.so' ⭐⭐⭐⭐ 宏定义冲突定位 g++ -dD -E -P your_file.cpp | grep -n MAX ⭐⭐⭐⭐ 内存错误检测 g++ -fsanitize=address -g debug.cpp \u0026amp;\u0026amp; ./a.out ⭐⭐⭐⭐⭐ 未定义行为捕捉 g++ -fsanitize=undefined -fno-sanitize-recover=all ub.cpp ⭐⭐⭐⭐ 编译时间优化 g++ -ftime-report huge_project.cpp 2\u0026gt; time.log ⭐⭐⭐ 跨平台ABI验证 g++ -m32 -dM -E - \u0026lt; /dev/null | grep __SIZEOF_POINTER__ ⭐⭐⭐ 三、大师级实战案例 案例1：向量化失败的根源分析 1 2 3 4 // vec_fail.cpp void scale(float* data, int n) { for(int i=0; i\u0026lt;n; ++i) data[i] *= 2.0f; } 诊断过程：\n1 2 g++ -O3 -fopt-info-vec-missed=vec.log vec_fail.cpp -c cat vec.log 输出：\n1 2 vec_fail.cpp:3:3: missed: not vectorized: data alignment issues vec_fail.cpp:3:3: missed: not vectorized: control flow in loop body 解决方案：\n声明对齐：float __attribute__((aligned(32))) data[1024]; 添加#pragma omp simd强制向量化 案例2：静态库符号缺失 现象：链接时undefined reference to 'Logger::log()'\n解剖步骤：\n1 2 3 4 5 6 7 8 # 1. 检查符号是否存在 nm -C libutils.a | grep Logger::log # 2. 若未找到，检查编译选项 g++ -c logger.cpp -fPIC # 确保与库编译选项一致 # 3. 验证Name Mangling c++filt _ZN6Logger3logEv # 确认编译器生成的符号名 案例3：宏定义污染 现象：第三方库的MAX宏与项目冲突\n溯源：\n1 2 g++ -dD -E -P project.cpp \u0026gt; expanded.cpp grep -n \u0026#34;define MAX\u0026#34; expanded.cpp 输出：\n1 2 42:#define MAX(a,b) ((a)\u0026gt;(b)?(a):(b)) 1567:#define MAX 1024 // 第三方库污染！ 解决方案：在包含第三方头文件前#undef MAX\n四、终极心法 分层调试原则：\n预处理问题 → -E\n编译问题 → -S\n链接问题 → nm/c++filt\n性能问题 → -fopt-info\n黄金组合拳：\n1 2 g++ -O3 -g -fverbose-asm -fopt-info-vec-optimized \\ -Wl,--verbose your_code.cpp 2\u0026gt; full.log 一次生成：汇编代码 + 优化报告 + 链接细节\n编译器自白书：\n添加-Q选项显示编译器实际启用的优化：\n1 g++ -Q -O3 --help=optimizers 大师箴言：当代码在生产环境崩溃时，普通人看日志，高手看coredump，而编译器大师直接看汇编。这些魔法不仅是工具，更是思维模式的转变——从\u0026quot;相信编译器\u0026quot;到\u0026quot;理解并掌控编译器\u0026quot;。当你能流畅解读movaps %xmm0,0x10(%rsp)背后的C++语义时，你已站在系统编程的珠峰之巅。\n附：最常用6大魔法速记\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 查C++标准 g++ -dM -E -x c++ /dev/null | grep __cplusplus # 2. 看头文件依赖 g++ -H your_file.cpp 2\u0026gt;/dev/null | grep -v \u0026#39;^ \u0026#39; # 3. 生成可读汇编 g++ -S -fverbose-asm -masm=intel -O2 your_file.cpp # 4. 符号解码 nm -C your_file.o | grep \u0026#39; T \u0026#39; # 5. 乱码还原 c++filt _Z3fooi # 6. 优化报告 g++ -O3 -fopt-info-vec-optimized=vec.log your_file.cpp ","date":"2025-11-29T23:42:26+08:00","permalink":"https://demo.stack.jimmycai.com/post/g++%E7%9A%84shell%E5%91%BD%E4%BB%A4%E9%BB%91%E9%AD%94%E6%B3%95/","title":"gcc的shell命令黑魔法"},{"content":"收到。这不仅是一次简单的整合，更是一次根据你最新的复习侧重点（20分共形映射+基础概念挖根）进行的战略升级。\n我将原来的基础篇与进阶篇完美融合，并针对共形映射进行了地毯式加固，同时严格执行你的要求：每一个定理都要拷问其成立的前提条件。\n这是一份针对《复变函数》全书概念的终极质检单。\n第一部分：初等函数与复数基础（地基篇） 1. 指数函数 $e^z$\n周期性：$e^z$ 的周期是多少？（注意：是 $2\\pi$ 还是 $2\\pi i$？） 非零性：方程 $e^z = 0$ 有解吗？条件：在有限复平面内，为什么它永远不等于零？ 模与角：$|e^{x+iy}|$ 仅由实部 $x$ 决定吗？$\\text{Arg}(e^{x+iy})$ 仅由虚部 $y$ 决定吗？ 映射：$w=e^z$ 将带状区域 $0 \u0026lt; y \u0026lt; \\pi$ 映射为什么区域？（是整个上半平面吗？） 2. 对数与幂函数\n多值性：$\\text{Ln } z$ 的多值性来源于哪一个几何量（幅角）的不确定性？ 主值支解析条件：$\\ln z$（主值）在负实轴及原点上解析吗？条件：若要在某个区域内谈 $\\ln z$ 的解析分支，该区域必须满足什么几何特征？（不能包含什么？） 幂函数定义：$z^a$ 的严格定义是什么？它是单值的还是多值的？条件：当 $a$ 满足什么条件时，$z^a$ 才是单值函数？（整数？有理数？复数？） 第二部分：导数、解析与调和函数（微积分基础） 3. C-R 方程与可导\nC-R 方程：$u_x, u_y, v_x, v_y$ 必须满足什么关系？（背诵！） 充分性陷阱：仅仅满足 C-R 方程就能保证函数可导吗？条件：偏导数本身还需要满足什么性质？（是否需要连续？） 解析的定义：$f(z)$ 在 $z_0$ 点解析，是指仅在该点可导，还是要在该点的某个邻域内处处可导？ 4. 调和函数\n定义：满足什么方程的函数叫调和函数？ 共轭条件：如果 $v$ 是 $u$ 的共轭调和函数，即 $u+iv$ 解析。那么 $u$ 是 $v$ 的共轭调和函数吗？（提示：符号是否要变？）条件：构造解析函数的前提是 $u$ 和 $v$ 所在的区域必须是什么类型的？（单连通？） 第三部分：复积分（计算工具库） 5. 积分基础与牛顿-莱布尼茨公式\n路径无关性：在什么条件下，积分与路径无关？条件：区域 $D$ 需要是单连通吗？函数 $f(z)$ 需解析吗？ 牛顿-莱布尼茨公式：$\\int_a^b f(z)dz = F(b) - F(a)$。条件：$f(z)$ 在路径所在的单连通区域内不仅要连续，还必须具有什么（原函数）？或者说必须是解析的吗？ 6. 柯西-古萨（Cauchy-Goursat）定理\n零值判据：$\\oint_C f(z)dz = 0$。条件： $C$ 是简单的闭曲线。 $f(z)$ 在 $C$ 的内部以及边界上，都必须满足什么性质？（少一个点解析行不行？） 7. 柯西积分公式（及其高阶导数）\n基本公式：$f(z_0) = \\frac{1}{2\\pi i} \\oint_C \\frac{f(z)}{z-z_0} dz$。条件：$z_0$ 必须在 $C$ 的哪一侧？ 高阶形式：求 $n$ 阶导数时，被积函数分母的幂次是 $n$ 还是 $n+1$？前面的系数有一项阶乘，是 $n!$ 吗？ 8. 平均值定理与柯西不等式\n平均值定理：解析函数在圆心的值 $f(z_0)$ 等于它在圆周上取值的积分平均吗？条件：整个圆面（含边界）内必须解析吗？ 柯西不等式：$|f^{(n)}(z_0)| \\le \\frac{n! M}{R^n}$。这里 $M$ 是什么？$R$ 是什么？这个不等式常用于证明刘维尔定理，这暗示了有界整函数只能是什么函数？ 第四部分：级数与留数（解题核心） 9. Taylor 与 Laurent 级数\n展开唯一性：同一个函数在不同圆环域内的 Laurent 展开式相同吗？ 收敛域形态：Taylor 级数的收敛域一定是圆吗？Laurent 级数的收敛域一定是圆环吗？ 10. 奇点与留数\n奇点分类：$\\lim_{z \\to z_0} f(z)$ 不存在且有界，这是不可能的。如果极限不存在且不为 $\\infty$，是什么奇点？ 计算公式： 如果是单极点，$Res = \\lim (z-z_0)f(z)$。 如果是 $P/Q$ 型单极点，公式是 $P(z_0)/Q\u0026rsquo;(z_0)$ 吗？条件：$Q\u0026rsquo;(z_0)$ 能等于 0 吗？ 如果是 $m$ 阶极点，极限式中导数要在这个基础上求几阶？（$m-1$阶？） 第五部分：共形映射（20分重点 - 必须死磕） 11. 共形映射的定义\n几何特征：所谓“共形”，必须同时满足哪两个性质？（保角性和保伸缩率性？）。 判别据：$w=f(z)$ 在 $z_0$ 实现共形映射的充要条件是什么？条件：1. 解析。2. 导数 $f\u0026rsquo;(z_0) \\neq$ 多少？ 方向性：解析变换保持角度的大小和旋转方向，如果是 $\\bar{z}$ 这样的共轭变换，保角但方向如何？它是共形映射吗？ 12. 分式线性变换 (L.F.T/Möbius)\n定义式：$w = \\frac{az+b}{cz+d}$。条件：为保证不是常数，$ad-bc$ 必须满足什么条件？（不为零）。 保圆性：为什么说它一定把“圆变为圆”？条件：在复数域中，直线被视作半径无穷大的圆吗？ 三点定式：任给 $z$ 平面三点到 $w$ 平面三点的映射是唯一确定的吗？这通常是解题的通法。 13. 两个核心映射模型（必背！）\n单位圆到单位圆：把 $|z|\u0026lt;1$ 映射为 $|w|\u0026lt;1$ 的一般形式是 $w = e^{i\\theta} \\frac{z-a}{1-\\bar{a}z}$。 理解：这里的 $a$ 是 $z$ 平面内部哪个点被映射到了 $w$ 平面的原点？ 边界：圆周 $|z|=1$ 上的点模长计算结果一定是 1 吗？ 上半平面到单位圆：把 Im $z \u0026gt; 0$ 映射为 $|w|\u0026lt;1$ 的一般形式是 $w = e^{i\\theta} \\frac{z-a}{z-\\bar{a}}$。 条件：参数 $a$ 的虚部必须满足 Im $a \u0026gt; 0$ 吗？ 理解：$z-\\bar{a}$ 在分母，意味着下半平面的点 $\\bar{a}$ 成了奇点，这点合理吗？（映射区域不含奇点）。 14. 幂函数与其他初等映射（预处理）\n角形域处理：如果要处理一个顶角为 $\\alpha$ 的角形区域（比如第一象限 $\\alpha = \\pi/2$），应该先用什么幂函数 $w=z^k$ 把它“拉”成上半平面？（$k$ 与 $\\alpha$ 的关系是 $k = \\pi / \\alpha$ 吗？） 带状域处理：将无穷长带状区域转化，通常使用指数函数 $e^z$ 还是对数函数？ 第六部分：积分变换（高频考点） 15. Fourier 变换\n常见函数： $\\delta(t)$ 的傅里叶变换是 1。 常数 $1$ 的傅里叶变换是 $2\\pi\\delta(\\omega)$ 吗？ $e^{-a|t|} (a\u0026gt;0)$ 的变换结果是洛伦兹线型（$ \\frac{2a}{\\omega^2 + a^2}$）吗？ 微分性质：$f\u0026rsquo;(t) \\leftrightarrow i\\omega F(\\omega)$。条件：这是在时域求导对应频域乘算子吗？ 16. Laplace 变换\n常见函数： 阶跃函数 $u(t)$ 的变换是 $1/s$ 吗？ $e^{at}$ 的变换是 $\\frac{1}{s-a}$ 吗？ $\\sin \\omega t$ 和 $\\cos \\omega t$ 的变换分母都是 $s^2+\\omega^2$，分子分别是什么？（一个是 $\\omega$，一个是 $s$，哪个对哪个？） 解微分方程： 导数性质：$\\mathcal{L}[y\u0026rsquo;] = sY(s) - y(0)$，那么 $\\mathcal{L}[y\u0026rsquo;\u0026rsquo;]$ 等于什么？别忘了减去初值项 $s y(0)$ 和 $y\u0026rsquo;(0)$。 求解逻辑：1. 变换变代数方程 -\u0026gt; 2. 解出 $Y(s)$ -\u0026gt; 3. ? (最后一步一定要进行什么变换？逆变换回到 $t$ 域)。 最后嘱咐： 请对照着这个列表，盖上右边的答案（或者心理预期的答案），如果对于任何一个“条件”或者“公式细节”有迟疑，不要猜测，立刻去查书上那一行的原文。概念题的陷阱就在“非零”、“单连通”、“边界含不含”这些细节里。祝复习顺利！\n","date":"2025-11-28T21:03:30+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%9C%80%E5%90%8E%E5%A4%8D%E4%B9%A0/","title":"复变函数最后复习"},{"content":"这是一份关于数理方程课程中一维波动方程（弦振动方程）的行波法与达朗贝尔公式的复习总结。\n这份总结按照“定解问题 $\\to$ 通解（行波法）$\\to$ 特解（达朗贝尔公式）$\\to$ 物理意义”的逻辑整理，适合期末复习或梳理思路。\n一、 定解问题模型 (The Cauchy Problem) 我们研究的是无界弦（无限长）的自由振动问题，数学上称为柯西问题（初值问题）：\n$$ \\begin{cases} \\frac{\\partial^2 u}{\\partial t^2} = a^2 \\frac{\\partial^2 u}{\\partial x^2} \u0026 (-\\infty \u003c x \u003c \\infty, t \u003e 0) \\quad \\text{(泛定方程)} \\\\ u(x, 0) = \\phi(x) \u0026 (-\\infty \u003c x \u003c \\infty) \\quad \\text{(初始位移)} \\\\ \\frac{\\partial u}{\\partial t}(x, 0) = \\psi(x) \u0026 (-\\infty \u003c x \u003c \\infty) \\quad \\text{(初始速度)} \\end{cases} $$ $u(x,t)$: 代表位移。 $a$: 波速，物理上 $a = \\sqrt{T/\\rho}$（$T$为张力，$\\rho$为线密度）。 二、 行波法 (Method of Traveling Waves) 行波法的核心思想是通过特征变换，将二阶偏微分方程化简，从而求出通解。\n1. 特征线与变量代换 方程 $u_{tt} - a^2 u_{xx} = 0$ 可以因式分解为算子形式： $$(\\frac{\\partial}{\\partial t} - a\\frac{\\partial}{\\partial x})(\\frac{\\partial}{\\partial t} + a\\frac{\\partial}{\\partial x})u = 0$$ 这提示我们要寻找使得 $x \\pm at$ 为常数的线，即特征线。\n引入新变量（特征坐标）： $$ \\begin{cases} \\xi = x + at \\\\ \\eta = x - at \\end{cases} $$2. 化简方程 利用链式法则将关于 $x, t$ 的导数转换为关于 $\\xi, \\eta$ 的导数，原方程化为标准型： $$ \\frac{\\partial^2 u}{\\partial \\xi \\partial \\eta} = 0 $$3. 积分求通解 对 $\\xi$ 和 $\\eta$ 分别积分，得到达朗贝尔通解： $$ u(x, t) = f(x + at) + g(x - at) $$ 其中 $f$ 和 $g$ 是任意二阶可微函数。\n4. 物理含义：行波 $g(x - at)$：代表波形保持不变，向 $x$ 轴正方向（右） 传播的波（右行波）。 $f(x + at)$：代表波形保持不变，向 $x$ 轴负方向（左） 传播的波（左行波）。 结论：一维波动方程的解是由两列形状不变、方向相反的行波叠加而成的。 三、 达朗贝尔公式 (D\u0026rsquo;Alembert\u0026rsquo;s Formula) 行波法给出了通解结构，达朗贝尔公式则是利用初始条件确定具体函数 $f$ 和 $g$，从而得到定解。\n1. 推导过程 利用初始条件 $t=0$ 时：\n位移：$f(x) + g(x) = \\phi(x)$ 速度：$a f\u0026rsquo;(x) - a g\u0026rsquo;(x) = \\psi(x)$ 对速度式在 $[0, x]$ 上积分，联立解出 $f(x)$ 和 $g(x)$，最后代回通解表达式。\n2. 公式形式 (核心考点) $$ u(x, t) = \\frac{1}{2}[\\phi(x - at) + \\phi(x + at)] + \\frac{1}{2a} \\int_{x - at}^{x + at} \\psi(\\tau) d\\tau $$3. 公式的物理分解 解由两部分组成：\n第一部分 $\\frac{1}{2}[\\phi(x - at) + \\phi(x + at)]$： 由初始位移 $\\phi(x)$ 引起。 初始波形一分为二，高度减半，分别向左右传播。 第二部分 $\\frac{1}{2a} \\int_{x - at}^{x + at} \\psi(\\tau) d\\tau$： 由初始速度 $\\psi(x)$ 引起。 代表初始冲量对波动的影响，是一个积分累积效应。 四、 物理意义与特征几何 (重点理解) 理解达朗贝尔公式不仅要会背，还要理解其背后的时空几何意义。\n1. 依赖区域 (Domain of Dependence) 问题：$M(x_0, t_0)$ 点的解 $u(x_0, t_0)$ 由哪些初始数据决定？ 结论：由 $x$ 轴上区间 $[x_0 - at_0, x_0 + at_0]$ 内的初始数据决定。 几何：过 $M$ 点作两条特征线，与 $x$ 轴围成的三角形称为特征三角形。解完全取决于该三角形底边上的初始值。 物理意义：波速是有限的，远处的扰动还没传过来，不会影响当前点。 2. 决定区域 / 影响区域 (Domain of Influence) 问题：$x$ 轴上一点 $P(x_0, 0)$ 的初始扰动会影响时空中的哪些区域？ 结论：会影响由两条特征线 $x - at = x_0$ 和 $x + at = x_0$ 夹角内的扇形区域。 物理意义：扰动以速度 $a$ 向两侧传播，凡是波前扫过的区域都会受到影响。 五、 扩展应用 (考试常见变体) 虽然达朗贝尔公式针对的是无界弦，但常用于解决以下变体问题：\n半无界弦 ($x \u0026gt; 0$) 问题：\n方法：延拓法 (Method of Reflection)。 固定端 ($u|_{x=0} = 0$)：对 $\\phi(x)$ 和 $\\psi(x)$ 进行奇延拓到 $(-\\infty, \\infty)$，然后套用达朗贝尔公式。 自由端 ($u_x|_{x=0} = 0$)：对 $\\phi(x)$ 和 $\\psi(x)$ 进行偶延拓。 非齐次方程 ($u_{tt} = a^2 u_{xx} + f(x,t)$)：\n方法：齐次化原理 (Duhamel\u0026rsquo;s Principle / 杜哈梅原理)。 将非齐次项 $f(x,t)$ 看作在不同时刻加入的“外力”或“初速度”，利用积分叠加达朗贝尔公式求解。 解的形式： $$u(x,t) = \\text{齐次通解} + \\frac{1}{2a}\\int_0^t \\int_{x-a(t-\\tau)}^{x+a(t-\\tau)} f(\\xi, \\tau) d\\xi d\\tau$$ 六、 总结记忆表 概念 核心内容 方程 $u_{tt} = a^2 u_{xx}$ 行波变量 $\\xi = x+at, \\quad \\eta = x-at$ 通解 $u = f(x+at) + g(x-at)$ 达朗贝尔公式 $u = \\frac{1}{2}[\\phi(x-at) + \\phi(x+at)] + \\frac{1}{2a}\\int_{x-at}^{x+at}\\psi(\\tau)d\\tau$ 核心性质 叠加性、有限传播速度、依赖区域、影响区域 适用范围 一维、无界、波动方程 ","date":"2025-11-28T15:52:53+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E6%95%B0%E7%90%86%E6%96%B9%E7%A8%8B%E8%BE%BE%E6%9C%97%E8%B4%9D%E5%B0%94%E5%85%AC%E5%BC%8F/","title":"数理方程达朗贝尔公式"},{"content":"这张PPT展示了留数定理在计算实积分时的三种最经典应用场景。这三类积分在复变函数考试中是必考内容。\n为了方便你理解和记忆，我将这三类积分的核心思路、变换公式和记忆口诀总结如下：\n一、 三角函数积分 (单位圆法) 形式：$\\displaystyle \\int_0^{2\\pi} R(\\cos \\theta, \\sin \\theta) d\\theta$ （特点：积分区间是 $0$ 到 $2\\pi$，被积函数是有理三角函数）\n核心逻辑： 把实数积分转化为复平面单位圆 ($|z|=1$) 上的围道积分。\n变换公式 (背诵)： 令 $z = e^{i\\theta}$，则：\n微分换元：$d\\theta = \\frac{dz}{iz}$ 余弦换元：$\\cos \\theta = \\frac{z + z^{-1}}{2} = \\frac{z^2+1}{2z}$ 正弦换元：$\\sin \\theta = \\frac{z - z^{-1}}{2i} = \\frac{z^2-1}{2iz}$ 计算公式： $$ \\text{原积分} = 2\\pi i \\sum \\text{Res}[f(z), z_k] $$ 注意：这里的 $z_k$ 必须是位于单位圆内部 ($|z_k|\u0026lt;1$) 的极点。\n记忆口诀：\n区间二派做代换，单位圆内找极点。 $d\\theta$ 变 $dz$ 除 $iz$，三角全变 $z$ 分式。\n二、 无穷区间有理积分 (上半平面法) 形式：$\\displaystyle \\int_{-\\infty}^{+\\infty} R(x) dx = \\int_{-\\infty}^{+\\infty} \\frac{P(x)}{Q(x)} dx$ （特点：上下限是无穷，且 $R(x)$ 是分式）\n收敛条件：分母次数比分子至少高 2 次 ($n \\ge m+2$)，且实轴上无奇点。\n核心逻辑： 补上一个上半平面的大半圆，利用大圆弧积分趋于 0 (大圆引理)，将实轴积分转化为闭合回路积分。\n计算公式： $$ \\int_{-\\infty}^{+\\infty} R(x) dx = 2\\pi i \\sum \\text{Res}[R(z), z_k] $$ 注意：这里的 $z_k$ 必须是位于上半平面 ($\\text{Im } z \u0026gt; 0$) 的极点。\n记忆口诀：\n上下无穷做有理，分母高二无顾虑。 只取上半平面点，二派 $i$ 乘留数和。\n三、 傅里叶型积分 (若丹引理法) 形式：$\\displaystyle \\int_{-\\infty}^{+\\infty} R(x) e^{iax} dx \\quad (a\u0026gt;0)$ 或者 $\\int_{-\\infty}^{+\\infty} R(x) \\cos(ax) dx$ 及 $\\int_{-\\infty}^{+\\infty} R(x) \\sin(ax) dx$\n收敛条件：分母次数比分子至少高 1 次 ($n \\ge m+1$)。这是比第二类更宽松的条件，因为 $e^{iax}$ 提供了衰减。\n核心逻辑： 利用 $e^{iaz}$ 在上半平面的衰减特性（若丹引理），同样补上半圆。如果是求 $\\cos$ 或 $\\sin$ 的积分，最后取实部或虚部即可。\n计算公式： $$ \\int_{-\\infty}^{+\\infty} R(x) e^{iax} dx = 2\\pi i \\sum \\text{Res}[R(z)e^{iaz}, z_k] $$ 注意：\n只找上半平面的极点。 计算留数时，千万别忘了把 $e^{iaz}$ 带进去算！ 记忆口诀：\n震荡因子 $e$ 指数，若丹引理来相助。 分母高一就能积，千万别忘乘 $e^{iz}$。\n总结对比表 (考前必看) 类型 积分区间 关键代换/方法 极点选择范围 结果系数 三角型 $[0, 2\\pi]$ $z=e^{i\\theta}$ 单位圆内 ($ z 有理型 $(-\\infty, +\\infty)$ 大圆围道 上半平面 ($\\text{Im } z \u0026gt; 0$) $2\\pi i$ 震荡型 $(-\\infty, +\\infty)$ 乘 $e^{iax}$ + 若丹引理 上半平面 ($\\text{Im } z \u0026gt; 0$) $2\\pi i$ 特别提醒： 如果是 $\\int_{-\\infty}^{+\\infty} R(x) \\cos(ax) dx$，做题时要先计算 $\\int_{-\\infty}^{+\\infty} R(x) e^{iax} dx$，算出复数结果后，取实部 (Re) 才是最终答案。\n","date":"2025-11-26T20:37:36+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E7%94%A8%E7%95%99%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%89%E7%B1%BB%E5%AE%9A%E7%A7%AF%E5%88%86/","title":"用留数计算三类定积分"},{"content":"没问题，听你的建议！既然儒可夫斯基变换超纲，那我们就把它删掉，把火力集中在分式线性映射这个“绝对核心”上，并辅以幂函数和指数函数。\n分式线性映射是复变函数考试中最灵活、考法最多的部分，确实值得“深挖”。这里为你整理一份加强版的总结：\n一、 绝对核心：分式线性映射 (Möbius Transformation) 通式：\n$$w = \\frac{az+b}{cz+d} \\quad (ad-bc \\neq 0)$$核心性质（保圆性）：它将扩充复平面上的**“广义圆”（圆或直线）映射为“广义圆”**。\n1. 两个“必背”的标准映射公式 考试中，如果题目没有强制要求用三点法，直接套用这两个公式最快。\n(1) 上半平面 $\\leftrightarrow$ 单位圆 （最常考） 将上半平面 $\\text{Im}(z) \u0026gt; 0$ 映射为单位圆 $|w| \u0026lt; 1$。 $$ w = e^{i\\theta} \\frac{z - z_0}{z - \\bar{z}_0} $$ 参数含义： $z_0$：上半平面内的一点，它被映射为圆心 $w=0$（即 $f(z_0)=0$）。 $\\theta$：旋转因子，由边界上的点的对应关系确定。 特例：最常用的简单形式是把 $i \\to 0$： $$ w = \\frac{z-i}{z+i} $$ (2) 单位圆 $\\leftrightarrow$ 单位圆 （圆内自同构） 将单位圆 $|z| \u0026lt; 1$ 映射为单位圆 $|w| \u0026lt; 1$。 $$ w = e^{i\\theta} \\frac{z - a}{1 - \\bar{a}z} $$ 参数含义： $a$：圆内的一点 ($|a|\u0026lt;1$)，它被映射为圆心 $w=0$。 易错点：注意分母是 $1-\\bar{a}z$，不要和上面的公式记混。 2. “万能钥匙”：三点定型法（交比公式） 当题目明确给出边界上的三个点映射到另外三个点（如 $z_1, z_2, z_3 \\to w_1, w_2, w_3$）时，使用此公式。\n公式： $$ \\frac{w-w_1}{w-w_2} \\cdot \\frac{w_3-w_2}{w_3-w_1} = \\frac{z-z_1}{z-z_2} \\cdot \\frac{z_3-z_2}{z_3-z_1} $$处理 $\\infty$ 的规则（重要）： 如果某个点是 $\\infty$，则包含该点的分子和分母的那一项直接划掉（视为1）。\n例子：如果 $z_1 = \\infty$，右边变为 $\\frac{z_3-z_2}{z-z_2}$。 例子：如果 $w_2 = \\infty$，左边变为 $\\frac{w-w_1}{w_3-w_1}$。 3. 判断映射方向的“神器”：保域性与定向原则 算出解析式后，如何确定是映射到了圆内还是圆外？\n定向原则（右手定则/左手定则）： 当你沿着边界的正方向走时，如果区域在你的左边，那么映射后，区域依然在边界的左边。 应用：比如把 $z$ 平面实轴上的 $-1, 0, 1$ 映射为 $w$ 平面单位圆上的 $-i, 1, i$。你在 $z$ 轴上从左向右走（$-1 \\to 0 \\to 1$），上半平面在左边。看 $w$ 平面，$-i \\to 1 \\to i$ 是逆时针，圆内也在左边。说明映射的是内部。 4. 对称点原理（Symmetry Principle） 这是解高难度题的捷径。 原理：关于边界对称的两个点 $z_1, z_2$，映射后 $w_1, w_2$ 依然关于新边界对称。\n直线的对称点：就是几何镜面对称（共轭）。\n圆的对称点：$z$ 和 $z^$ 关于圆心为 $a$、半径为 $R$ 的圆对称，满足 $(z-a)(\\overline{z^-a}) = R^2$。特别地，关于单位圆，对称点互为倒数的共轭 $z^* = 1/\\bar{z}$。\n考题应用： 如果题目说把上半平面映射成单位圆，且 $f(i) = 0$。\n因为 $i$ 映射到圆心 $0$。 $i$ 关于实轴（边界）的对称点是 $-i$。 所以 $-i$ 必须映射到 $0$ 关于单位圆（边界）的对称点 $\\infty$。 立刻就能写出因子：分子有 $(z-i)$，分母有 $(z+i)$。 二、 辅助工具：幂函数与指数函数 这两类函数主要负责**“整形”，把不规则区域变成可以用分式线性映射处理的上半平面**。\n1. 幂函数 $w = z^\\mu$ （调整角度） 功能：把顶点在原点的角形域（扇形）张开或合拢。 公式：若区域为角 $\\alpha \u0026lt; \\arg z \u0026lt; \\beta$（张角为 $\\varphi = \\beta-\\alpha$），想把它变成上半平面（张角 $\\pi$）。 $$ w = e^{-i\\alpha \\cdot \\frac{\\pi}{\\varphi}} \\cdot z^{\\frac{\\pi}{\\varphi}} $$ (通常只要旋转到第一边与实轴重合，然后直接乘倍数即可) 常用速查： 第一象限 $\\to$ 上半平面：$w = z^2$ 上半圆（半圆盘） $\\to$ 第一象限：先用分式线性映射把半圆变直角，再用幂函数。 2. 指数函数 $w = e^{\\lambda z}$ （带形变半面） 功能：把平行带形区域映射为角形域或半平面。 公式：对于宽度为 $h$ 的带形域。 $$ w = e^{\\frac{\\pi}{h} z} $$ 常用速查： 带形 $0 \u0026lt; \\text{Im}(z) \u0026lt; \\pi$ $\\to$ 上半平面：$w = e^z$ 带形 $0 \u0026lt; \\text{Im}(z) \u0026lt; h$ $\\to$ 上半平面：$w = e^{\\frac{\\pi z}{h}}$ 考试通用解题流程 看形状：\n是扇形？ $\\to$ 用幂函数 $z^\\mu$ 变成上半平面。 是带子？ $\\to$ 用指数 $e^z$ 变成上半平面。 是两个圆弧围成的月牙/眼睛？ $\\to$ 用分式线性映射，把两个交点分别送到 $0$ 和 $\\infty$，把它变成角形域，再用幂函数。 最后一步（定型）：\n现在你手里一定是上半平面了。 如果题目要上半平面，收工。 如果题目要单位圆，用标准公式 $w = \\frac{z-z_0}{z-\\bar{z}_0}$ 收工。 ","date":"2025-11-26T20:16:58+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E5%85%B1%E5%BD%A2%E5%8F%98%E6%8D%A2/","title":"共形变换"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;chrono\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int sum_factor(int n) { int sum = 0; for (int i = 1; i \u0026lt; std::sqrt(n); i++) { if (i == 1) { sum += 1; } else { if (n % i == 0) { sum += i + n / i; } } } return sum; } bool is_perfect(int n) { return (n == sum_factor(n)) \u0026amp;\u0026amp; (n != 0); } std::vector\u0026lt;int\u0026gt; find_perfect(int stop) { std::vector\u0026lt;int\u0026gt; perfect; for (int i = 0; i \u0026lt;= stop; i++) { if (is_perfect(i)) { perfect.push_back(i); } } return perfect; } long test_time_perfect(int stop) { auto begin_time = std::chrono::high_resolution_clock::now(); find_perfect(stop); auto end_time = std::chrono::high_resolution_clock::now(); auto duration = std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;( end_time - begin_time); long duration_time = duration.count(); std::cout \u0026lt;\u0026lt; \u0026#34;N=\u0026#34; \u0026lt;\u0026lt; stop \u0026lt;\u0026lt; \u0026#34;,time:\u0026#34; \u0026lt;\u0026lt; duration_time \u0026lt;\u0026lt; \u0026#34;ms\\n\u0026#34;; return duration_time; } int main(int argc, char *argv[]) { // std::cout \u0026lt;\u0026lt; \u0026#34;sum_factor(1)=\u0026#34; \u0026lt;\u0026lt; sum_factor(1) \u0026lt;\u0026lt; std::endl; // std::cout \u0026lt;\u0026lt; is_perfect(1) \u0026lt;\u0026lt; std::endl; test_time_perfect(1000); test_time_perfect(10000); test_time_perfect(100000); test_time_perfect(1000000); std::vector\u0026lt;int\u0026gt; perfect_100000 = find_perfect(100000); for (const auto \u0026amp;i : perfect_100000) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // std::print(\u0026#34;{}\u0026#34;, perfect_100000); // std::cout\u0026lt;\u0026lt;perfect_100000\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; return 0; } 反思 这是我原本的代码，有什么问题呢？\n算法逻辑问题 对于循环中的完全平方数，是否存在漏算？\n分支预测（Branch Prediction）的代价 问题： 在 sum_factor 的循环中，if (i == 1) 这行代码在每次循环都会执行，但只有第一次是真的。 深度思考： 现代 CPU 依赖流水线和分支预测。这种极其倾斜的分支（99.9% 为 false）虽然 CPU 能预测对，但仍有指令开销。如果把 1 的处理提到循环外面，循环从 2 开始，对性能会有微小的提升吗？更深层地，if (n % i == 0) 这种无法预测的取模分支，是算法性能的最大杀手，有没有办法消除它？ std的隐形开销和类型转换 编译器是否足够聪明，把sqrt移到循环外面？ sqrt对应的浮点数运算慢，能否用i*i \u0026lt;=n代替sqrt运算 内存分配策略：std::vector 的扩容机制 vector的内存结构是怎么样的，算法中是先分配空间再填入还是挨个push back.vector的扩容倍数一般是多少 类型系统的安全性：int 够用吗？ cpp中溢出会报错吗？函数返回类型是选择auto还是long，int这些显示类型。无符号和有符号类型有哪些，有哪些区别 软件工程思考(gemini提供的思路) 接口设计的通用性：高阶函数与 Lambda 问题： test_time_perfect 目前不仅负责计时，还负责打印，甚至硬编码了调用 find_perfect。如果我想测试 sum_factor 函数的耗时呢？甚至测试另一个完全不同的排序算法的耗时呢？你需要复制粘贴代码吗？ 深度思考： 如何修改 test_time_perfect，使其接受一个**函数对象（Function Object）**或 Lambda 表达式作为参数？这就涉及到将“计时逻辑”与“业务逻辑”解耦，是函数式编程在 C++ 中的体现。 并行计算（Concurrency）：榨干多核 CPU 问题： 你的 find_perfect 是单线程的，依次检查 0 到 stop。现在的 CPU 都是多核的。检查 i=100 和检查 i=200 是否完美是完全独立的。 深度思考： 这是一个“尴尬并行（Embarrassingly Parallel）”的问题。如何利用 std::async、std::thread 甚至 C++17 的 std::execution::par 来并行化这个循环？并行化后的性能瓶颈会从 CPU 计算转移到内存写入（vector 的线程安全写入）上吗？ 现代 C++ 的表达力：Ranges 与 View 问题： 代码中 find_perfect 先计算出所有结果存入 vector，再由 main 打印。如果 stop 是 10亿，vector 会占用巨大内存，尽管我们只需要打印出来看看。 深度思考： 是否可以设计一个“生成器（Generator）”或使用 C++20 的 std::ranges？这种模式下，程序是“惰性（Lazy）”的：你需要打印下一个，我才去计算下一个。这种**管道（Pipeline）**式的抽象如何改变数据的流动方式？ ","date":"2025-11-23T21:23:00+08:00","permalink":"https://demo.stack.jimmycai.com/post/cs106-assignment1-perfect_number/","title":"Cs106 Assignment1 Perfect_number"},{"content":"这是一份为你定制的 CMake 极简实战指南。\n针对你的背景（C 基础 + LazyVim + WSL），我剔除了那些复杂的、过时的写法，只保留现代 C++ (Modern CMake) 的核心用法。\n1. 核心概念：它是个“生成器” CMake 不会编译代码，它只是指挥别的工具去编译。\n输入：CMakeLists.txt（你写的脚本） 动作：cmake 命令 输出：Makefile（或者 Ninja 文件） 你只需要维护 CMakeLists.txt，然后让 CMake 帮你生成那个让你头疼的 Makefile。\n2. 最小可行配置 (Boilerplate) 在你的项目根目录下创建一个名为 CMakeLists.txt 的文件（文件名大小写敏感，必须完全一致）。\n场景 A：只有几个源文件（作业常用） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 1. 指定 CMake 最低版本 (3.10 是一个安全的基准) cmake_minimum_required(VERSION 3.10) # 2. 定义项目名称 project(CS106B_Assignment1) # 3. 设置 C++ 标准 (C++17 或 C++20) set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED ON) # 强制要求，不支持就报错 # 4. 开启常用警告 (类似 gcc -Wall -Wextra)，C 程序员的好习惯 add_compile_options(-Wall -Wextra) # 5. 生成 compile_commands.json (给 LazyVim/Clangd 用的，极其重要！) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # 6. 定义要生成的可执行文件 # 语法：add_executable(程序名 源文件1 源文件2 ...) add_executable(main main.cpp utils.cpp logic.cpp) 3. 进阶场景：源文件很多，分目录管理 如果你想像真正的 C++ 项目那样组织文件：\n1 2 3 4 5 6 7 Project/ ├── CMakeLists.txt ├── src/ │ ├── main.cpp │ └── helper.cpp └── include/ └── helper.h 对应的 CMakeLists.txt 写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 cmake_minimum_required(VERSION 3.10) project(MyProject) set(CMAKE_CXX_STANDARD 17) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # 自动查找 src 目录下所有的 .cpp 文件，存入变量 SOURCES 中 # 注意：如果添加新文件，需要重新运行 cmake file(GLOB SOURCES \u0026#34;src/*.cpp\u0026#34;) # 告诉编译器去哪里找 .h 头文件 include_directories(include) # 生成可执行文件，使用上面找到的 SOURCES 列表 add_executable(app ${SOURCES}) 4. 标准构建流程 (CLI) 在 WSL 终端中，永远遵循 \u0026ldquo;Out-of-source Build\u0026rdquo;（外部构建）原则。不要把生成的临时文件和你的源码混在一起。\n步骤 1：配置 (Configure) 告诉 CMake 在 build 文件夹下生成构建文件。\n1 cmake -S . -B build -S . : Source 在当前目录。 -B build : Build artifacts 放在 build 目录（如果没有会自动创建）。 步骤 2：构建 (Build) 这一步相当于执行了 make。\n1 cmake --build build 如果你想利用多核 CPU 加速编译（比如 8 核）： cmake --build build -- -j8 步骤 3：运行\n1 2 3 ./build/main # 或者 ./build/app 5. 给 LazyVim 用户的特别提示 你在 CMakeLists.txt 里加了 set(CMAKE_EXPORT_COMPILE_COMMANDS ON) 后，CMake 会在 build 目录下生成一个 compile_commands.json。\n这是 LSP (Clangd) 的“圣经”。 有了它，Clangd 才知道你的项目包含了哪些头文件路径、用了什么标准。\n为了让 LazyVim 自动读取它： 通常 LazyVim 足够智能可以去 build 目录找。如果它找不到（表现为头文件报错 file not found），你可以做一个软链接到根目录：\n1 ln -s build/compile_commands.json . 6. 常用语法速查表 变量： 1 2 set(MY_VAR \u0026#34;Hello\u0026#34;) message(${MY_VAR}) # 打印变量 列表（其实就是用空格或分号隔开的字符串）： 1 set(MY_FILES a.cpp b.cpp c.cpp) 条件判断： 1 2 3 4 5 if(WIN32) # Windows 专用配置 elseif(UNIX) # Linux/Mac 配置 endif() 注释：使用 #。 总结 对于你现在的阶段，记住这三板斧就够了：\ncmake_minimum_required \u0026amp; project (开头仪式) set(CMAKE_CXX_STANDARD 17) (现代化) add_executable(main file1.cpp file2.cpp) (干正事) 遇到新文件，就往 add_executable 后面加；遇到头文件找不到，就加 include_directories。就这么简单。\n","date":"2025-11-21T21:47:58+08:00","permalink":"https://demo.stack.jimmycai.com/post/cmake/","title":"Cmake"},{"content":"cgdb 是 GDB 的一个轻量级前端，它在终端中提供了一个分屏界面：上半部分显示代码（类似 Vim），下半部分是 GDB 命令窗口。\n使用 cgdb 调试 C 程序时，指令分为两类：CGDB 界面快捷键（操作源代码窗口）和 GDB 原生指令（操作命令窗口）。\n0. 准备工作 在编译代码时，必须加上 -g 选项，否则无法调试。\n1 2 gcc -g main.c -o main cgdb ./main 1. 核心概念：模式切换 (Mode Switching) 这是新手最容易混淆的地方：\nCGDB 模式 (代码窗口)：按下 ESC 键。此时你可以像用 Vim 一样浏览代码。 GDB 模式 (命令窗口)：按下 i 键 (insert)。此时你可以输入 run, next 等调试命令。 2. CGDB 界面快捷键 (需在 ESC 模式下) 当你在代码窗口时（按 ESC 后），可以使用以下快捷键：\n按键 功能 备注 Space 设置/取消断点 光标所在行切换断点（最常用） k / j 上/下移动光标 同 Vim / 搜索代码内容 同 Vim，输入关键字回车 n 查找下一个匹配项 同 Vim gg / G 跳到文件头 / 文件尾 同 Vim :15 跳到第 15 行 Vim 风格跳转 o 打开文件选择器 当有多个源文件时切换文件 - 缩小代码窗口 调整分屏比例 + 增大代码窗口 调整分屏比例 Ctrl + w 切换屏幕焦点 也可以直接按 i 进下屏，ESC 进上屏 3. GDB 常用指令 (需在 i 模式下) 当你在命令窗口时（按 i 后），输入的指令与原生 GDB 完全一致。\n3.1 运行与停止 r (run): 开始运行程序。如果有参数，跟在后面（如 r arg1 arg2）。 q (quit): 退出 cgdb。 kill: 停止当前正在运行的程序。 3.2 断点管理 (Breakpoint) b main: 在 main 函数入口打断点。 b 20: 在第 20 行打断点。 b file.c:15: 在 file.c 的第 15 行打断点。 info b: 查看所有断点信息（编号、位置等）。 d 1 (delete): 删除编号为 1 的断点。 d: 删除所有断点。 3.3 单步调试 (Stepping) n (next): 单步执行（不进入函数内部）。 s (step): 单步执行（进入函数内部）。 c (continue): 继续运行，直到遇到下一个断点。 finish: 执行直到当前函数返回（跳出函数）。 until 50: 运行直到第 50 行。 3.4 查看变量与内存 p var (print): 打印变量 var 的值。 p *ptr: 打印指针指向的值。 p/x var: 以十六进制格式打印。 display var: 每次停顿时自动显示 var 的值（监视）。 info display: 查看当前的监视列表。 undisplay 1: 取消编号为 1 的监视。 ptype var: 查看变量类型。 x/10dw array: 查看内存。x 是 examine，查看 array 地址开始的 10 个十进制(d)字(w)。 3.5 查看堆栈 bt (backtrace): 查看函数调用栈（程序崩了查 Core Dump 时最有用）。 f 1 (frame): 切换到栈帧 1（查看上层函数的变量上下文）。 4. 常用调试流程示例 启动：cgdb ./my_program 设断点：按 i 确保在 GDB 模式，输入 b main；或者按 ESC，移动光标到某一行，按 Space。 运行：按 i 回到命令窗口，输入 r。 单步：程序停下后，输入 n 下一行，或 s 进函数。 观察：发现某变量 cnt 只有，输入 p cnt 查看值。 修正：如果发现逻辑错误，按 q 退出，修改代码，重新编译。 技巧 回车键：在 GDB 模式下，直接按回车会重复执行上一条指令（例如一直按回车等于一直 n）。 Tab 补全：GDB 命令支持自动补全函数名和变量名。 ","date":"2025-11-21T21:25:57+08:00","permalink":"https://demo.stack.jimmycai.com/post/cgdb/","title":"Cgdb"},{"content":"这是一份非常系统的总结需求。掌握这四种情况，基本上就覆盖了本科数理方程考试中分离变量法 90% 的考点。\n核心逻辑是：\n边界条件决定了**固有函数（基底）**的形式（是 $\\sin$ 还是 $\\cos$）。 方程类型决定了时间/另一维度函数的形式（是振荡、衰减还是双曲）。 第一部分：一维演化方程（弦振动 vs 热传导） 这两种方程的空间部分（$x$）处理方式完全一样，区别仅在于时间部分（$t$）。\n弦振动 (Wave): $u_{tt} = a^2 u_{xx}$ $\\rightarrow$ 时间是振荡的 ($\\sin \\omega t, \\cos \\omega t$)，甚至有线性增长 ($t$)。 热传导 (Heat): $u_t = a^2 u_{xx}$ $\\rightarrow$ 时间是衰减的 ($e^{-k^2 t}$)，或者是常数。 1. 两端固定 (Dirichlet-Dirichlet) BC: $u(0)=0, u(l)=0$ 基底: $\\sin \\frac{n\\pi x}{l}$ 弦振动解: $$ u = \\sum_{n=1}^\\infty \\left( C_n \\cos \\frac{n\\pi a t}{l} + D_n \\sin \\frac{n\\pi a t}{l} \\right) \\sin \\frac{n\\pi x}{l} $$ 热传导解: $$ u = \\sum_{n=1}^\\infty C_n e^{-\\left(\\frac{n\\pi a}{l}\\right)^2 t} \\sin \\frac{n\\pi x}{l} $$ 2. 两端自由 (Neumann-Neumann) —— 高频考点 BC: $u_x(0)=0, u_x(l)=0$ 基底: $1$ (对应 $n=0$) 和 $\\cos \\frac{n\\pi x}{l}$ 弦振动解 (含刚体位移): $$ u = \\underbrace{C_0 + D_0 t}_{\\color{red}{n=0 \\text{项}}} + \\sum_{n=1}^\\infty \\left( C_n \\cos \\dots + D_n \\sin \\dots \\right) \\cos \\frac{n\\pi x}{l} $$ 热传导解 (含稳态解): $$ u = \\underbrace{C_0}_{\\color{red}{\\text{最终平衡温度}}} + \\sum_{n=1}^\\infty C_n e^{-\\left(\\frac{n\\pi a}{l}\\right)^2 t} \\cos \\frac{n\\pi x}{l} $$ 3. 一固一游 (Mixed) BC: $u(0)=0, u_x(l)=0$ 基底: $\\sin \\frac{(2n+1)\\pi x}{2l}$ (半奇数倍) 弦振动解: $$ u = \\sum_{n=0}^\\infty (T_n(t)) \\sin \\frac{(2n+1)\\pi x}{2l} $$ 热传导解: $$ u = \\sum_{n=0}^\\infty C_n e^{-\\left(\\frac{(2n+1)\\pi a}{2l}\\right)^2 t} \\sin \\frac{(2n+1)\\pi x}{2l} $$ 第二部分：二维拉普拉斯方程（直角坐标） 方程：$u_{xx} + u_{yy} = 0$\n解题铁律：\n看边界：哪两个平行的边界条件是 0（齐次）？ 齐次方向选三角函数 ($\\sin, \\cos$) $\\rightarrow$ 产生固有值 $\\lambda_n$。 非齐次方向选双曲函数 ($\\sinh, \\cosh$) 或指数函数 ($e^y, e^{-y}$) $\\rightarrow$ 为了凑边界。 情形 A：左右为 0 ($x=0, x=a$ 是齐次) $X(x)$ 方向：$\\sin \\frac{n\\pi x}{a}$ $Y(y)$ 方向：$A_n \\cosh \\frac{n\\pi y}{a} + B_n \\sinh \\frac{n\\pi y}{a}$ (或者 $C_n e^{\\dots} + D_n e^{-\\dots}$) 解的形式： $$ u(x,y) = \\sum_{n=1}^\\infty \\left( A_n \\cosh \\frac{n\\pi y}{a} + B_n \\sinh \\frac{n\\pi y}{a} \\right) \\sin \\frac{n\\pi x}{a} $$ (系数 $A_n, B_n$ 由上下两边的非齐次条件定) 情形 B：上下为 0 ($y=0, y=b$ 是齐次) $Y(y)$ 方向：$\\sin \\frac{n\\pi y}{b}$ $X(x)$ 方向：双曲函数 解的形式： $$ u(x,y) = \\sum_{n=1}^\\infty \\left( A_n \\cosh \\frac{n\\pi x}{b} + B_n \\sinh \\frac{n\\pi x}{b} \\right) \\sin \\frac{n\\pi y}{b} $$ 情形 C：四周都有值 (叠加原理) 如果矩形四边都不是 0，必须把问题拆成两个子问题（A + B），分别求解后再相加。 第三部分：二维拉普拉斯方程（极坐标） 方程：$\\Delta u = 0$ 通用原料：$r^n, r^{-n}, \\ln r, \\text{const}$ 和 $\\sin n\\theta, \\cos n\\theta$。\n分类依据：区域是否包含圆心 ($0$) 和无穷远 ($\\infty$)。\n1. 圆内问题 ($r \u0026lt; a$) 去除项： $\\ln r$ (在0处无穷), $r^{-n}$ (在0处无穷) 解的形式： $$ u(r,\\theta) = \\frac{A_0}{2} + \\sum_{n=1}^\\infty r^n (A_n \\cos n\\theta + B_n \\sin n\\theta) $$ (这是最常用的泊松积分公式的前身) 2. 圆外问题 ($r \u0026gt; a$) 去除项： $r^n$ (在$\\infty$处发散), $\\ln r$ (通常去除，除非有源) 解的形式： $$ u(r,\\theta) = \\frac{A_0}{2} + \\sum_{n=1}^\\infty \\frac{1}{r^n} (A_n \\cos n\\theta + B_n \\sin n\\theta) $$ 3. 圆环问题 ($a \u0026lt; r \u0026lt; b$) 去除项： 无。所有项都保留。 解的形式： $$ u(r,\\theta) = A_0 + B_0 \\ln r + \\sum_{n=1}^\\infty (C_n r^n + D_n r^{-n})(A_n \\cos n\\theta + B_n \\sin n\\theta) $$ 终极速查表 (Cheat Sheet) 方程与坐标 关键特征 解的主要形式 (级数项) 备注 弦振动 (1D) 波动 $T(t) \\cdot X(x)$ $X(x)$ 定基底，$T(t)$ 是正余弦 热传导 (1D) 扩散 $T(t) \\cdot X(x)$ $X(x)$ 定基底，$T(t)$ 是指数衰减 拉普拉斯 (直角) 稳态 Trig(齐次向) $\\cdot$ Hyperbolic(非齐次向) 一边 $\\sin$，另一边 $\\sinh/\\cosh$ 拉普拉斯 (圆内) 极坐标 $r^n \\cdot (A\\cos + B\\sin)$ 去掉 $r^{-n}$ 和 $\\ln r$ 拉普拉斯 (圆外) 极坐标 $r^{-n} \\cdot (A\\cos + B\\sin)$ 去掉 $r^n$ 做题套路总结：\n定方程： 决定了时间项 ($T$) 还是双曲项 ($Y$)。 看边界 (x/齐次方向)： $0, 0 \\rightarrow \\sin$ $0\u0026rsquo;, 0\u0026rsquo; \\rightarrow \\cos$ (注意 $n=0$ 常数项) $0, 0\u0026rsquo; \\rightarrow \\sin((n+0.5)\\dots)$ 看区域 (极坐标)： 有圆心 $\\rightarrow$ 留 $r^n$ 有无穷 $\\rightarrow$ 留 $r^{-n}$ ","date":"2025-11-21T15:47:53+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E6%95%B0%E7%90%86%E6%96%B9%E7%A8%8B%E5%88%86%E7%A6%BB%E5%8F%98%E9%87%8F%E6%B3%95/","title":"数理方程分离变量法"},{"content":"q1:利用结构体实现分数的抽象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 // abstraction of rational // #include \u0026#34;math.h\u0026#34; #include \u0026#34;stdint.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; typedef struct { int numerator; // 分子 int denominator; // 分母 } rational; rational make_rational(int a, int b) { if ((a * b \u0026lt; 0)) { a = -abs(a); b = abs(b); } else { a = abs(a); b = abs(b); } rational r = {a, b}; return r; } int gcd(int a, int b) { a = abs(a); b = abs(b); int max_ab = a \u0026gt; b ? a : b; int min_ab = a \u0026gt; b ? b : a; if (min_ab == 0) { return max_ab; } else { return gcd(min_ab, max_ab % min_ab); } } rational reduction(rational r) { int a = r.numerator; int b = r.denominator; int gcd_ab = gcd(a, b); rational k = {a / gcd_ab, b / gcd_ab}; return k; } void printf_rational(rational r) { if (r.denominator == 0) { printf(\u0026#34;infinity\\n\u0026#34;); } else if (r.denominator == 1) { printf(\u0026#34;%d\\n\u0026#34;, r.numerator); } else { printf(\u0026#34;%d/%d\\n\u0026#34;, r.numerator, r.denominator); } } rational mux_rational(rational r1, rational r2) { int a = r1.numerator * r2.denominator + r2.numerator * r1.denominator; int b = r1.denominator * r2.denominator; rational r = {a, b}; return reduction(r); } rational sub_rational(rational r1, rational r2) { int a = r1.numerator * r2.denominator - r2.numerator * r1.denominator; int b = r1.denominator * r2.denominator; rational r = {a, b}; return reduction(r); } rational mul_rational(rational r1, rational r2) { int a = r1.numerator * r2.numerator; int b = r1.denominator * r2.denominator; rational r = {a, b}; return reduction(r); } rational div_rational(rational r1, rational r2) { int a = r1.numerator * r2.denominator; int b = r1.denominator * r2.numerator; rational r = {a, b}; return reduction(r); } int main(int argc, char *argv[]) { rational r1 = make_rational(1, -8); rational r2 = make_rational(1, 8); printf_rational(mux_rational(r1, r2)); printf_rational(sub_rational(r1, r2)); printf_rational(mul_rational(r1, r2)); printf_rational(div_rational(r1, r2)); return EXIT_SUCCESS; } q2: 预测一下两段代码结果，思考enum与宏定义的差异 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //code1 #include \u0026lt;stdio.h\u0026gt; enum coordinate_type { RECTANGULAR = 1, POLAR }; int main(void) { int RECTANGULAR; printf(\u0026#34;%d %d\\n\u0026#34;, RECTANGULAR, POLAR); return 0; } //输出： 垃圾值，2 //解释：enum在全局定义，会以局部变量定义 //code2 #include \u0026lt;stdio.h\u0026gt; int main(void) { enum coordinate_type { RECTANGULAR = 1, POLAR }; // int RECTANGULAR; printf(\u0026#34;%d %d\\n\u0026#34;, RECTANGULAR, POLAR); return 0; } //结果：报错 //解释:命名冲突 枚举：在编译阶段处理，有定义域，枚举值存在于编译器的符号表里，编译后直接变成了机器指令里的数字，不占用数据内存空间。 宏：在预处理阶段处理，直接替换 ","date":"2025-11-19T15:17:54+08:00","permalink":"https://demo.stack.jimmycai.com/post/linuxc-7.%E7%BB%93%E6%9E%84%E4%BD%93/","title":"LinuxC 7.结构体"},{"content":"这是用iflow的glm模型生成的数据作图模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 import numpy as np import matplotlib.pyplot as plt from scipy.interpolate import make_interp_spline from typing import List, Dict, Tuple, Optional # --- 设置Matplotlib支持中文显示 --- plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;WenQuanYi Zen Hei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def plot_multiple_datasets_non_monotonic( datasets: List[Dict], x_label: str, y_label: str, title: str, smooth_method: str = \u0026#39;spline\u0026#39;, poly_degree: int = 3, save_path: str = None, figsize: Tuple[int, int] = (10, 6), colors: Optional[List[str]] = None, markers: Optional[List[str]] = None ): \u0026#34;\u0026#34;\u0026#34; 一个支持多组数据同时绘制的函数，可以在同一张图上显示多组实验数据。 此版本支持非递增（非单调）的x轴数据。 参数: datasets (List[Dict]): 数据集列表，每个字典包含: - \u0026#39;x_data\u0026#39;: x轴数据 - \u0026#39;y_data\u0026#39;: y轴数据 - \u0026#39;label\u0026#39;: 该组数据的标签名称 - \u0026#39;smooth_method\u0026#39;: (可选) 该组数据使用的平滑方法，默认使用全局设置 - \u0026#39;poly_degree\u0026#39;: (可选) 该组数据的多项式阶数，默认使用全局设置 x_label (str): x轴的标签名称（包含单位） y_label (str): y轴的标签名称（包含单位） title (str): 图表的标题 smooth_method (str): 默认平滑曲线的方法 (\u0026#39;spline\u0026#39;, \u0026#39;polyfit\u0026#39; 或 \u0026#39;univariate_spline\u0026#39;) poly_degree (int): 默认多项式阶数 save_path (str): 图片保存路径 figsize (Tuple[int, int]): 图表大小，默认 (10, 6) colors (List[str]): 自定义颜色列表 markers (List[str]): 自定义标记样式列表 \u0026#34;\u0026#34;\u0026#34; # 设置默认颜色和标记样式 if colors is None: colors = [\u0026#39;blue\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;purple\u0026#39;, \u0026#39;brown\u0026#39;, \u0026#39;pink\u0026#39;, \u0026#39;gray\u0026#39;, \u0026#39;olive\u0026#39;, \u0026#39;cyan\u0026#39;] if markers is None: markers = [\u0026#39;o\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;^\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;h\u0026#39;] # 创建图表 plt.figure(figsize=figsize) for i, dataset in enumerate(datasets): # 获取数据 x = np.array(dataset[\u0026#39;x_data\u0026#39;]) y = np.array(dataset[\u0026#39;y_data\u0026#39;]) label = dataset[\u0026#39;label\u0026#39;] # 使用该组数据的设置或全局设置 method = dataset.get(\u0026#39;smooth_method\u0026#39;, smooth_method) degree = dataset.get(\u0026#39;poly_degree\u0026#39;, poly_degree) # 选择颜色和标记 color = colors[i % len(colors)] marker = markers[i % len(markers)] # 绘制原始数据点 plt.scatter(x, y, label=f\u0026#39;{label} (原始数据)\u0026#39;, color=color, marker=marker, zorder=5) # 生成平滑曲线 x_smooth = np.linspace(x.min(), x.max(), 300) if method == \u0026#39;spline\u0026#39;: # 检查x轴数据是否单调递增 is_monotonic = np.all(np.diff(x) \u0026gt; 0) if is_monotonic: # 如果数据是单调递增的，使用原始方法 try: spline = make_interp_spline(x, y, k=3) y_smooth = spline(x_smooth) plt.plot(x_smooth, y_smooth, color=color, linewidth=2, linestyle=\u0026#39;--\u0026#39;, alpha=0.8) except: # 如果样条插值失败，回退到多项式拟合 print(f\u0026#34;警告: {label}的样条插值失败，使用多项式拟合代替\u0026#34;) coeffs = np.polyfit(x, y, deg=degree) poly_func = np.poly1d(coeffs) y_smooth = poly_func(x_smooth) plt.plot(x_smooth, y_smooth, color=color, linewidth=2, linestyle=\u0026#39;--\u0026#39;, alpha=0.8) else: # 如果数据不是单调递增的，使用UnivariateSpline try: from scipy.interpolate import UnivariateSpline # 首先对x轴数据进行排序 sort_indices = np.argsort(x) x_sorted = x[sort_indices] y_sorted = y[sort_indices] # 使用UnivariateSpline处理非单调数据 spline = UnivariateSpline(x_sorted, y_sorted, s=0) y_smooth = spline(x_smooth) plt.plot(x_smooth, y_smooth, color=color, linewidth=2, linestyle=\u0026#39;--\u0026#39;, alpha=0.8) except: # 如果UnivariateSpline也失败，回退到多项式拟合 print(f\u0026#34;警告: {label}的UnivariateSpline插值失败，使用多项式拟合代替\u0026#34;) coeffs = np.polyfit(x, y, deg=degree) poly_func = np.poly1d(coeffs) y_smooth = poly_func(x_smooth) plt.plot(x_smooth, y_smooth, color=color, linewidth=2, linestyle=\u0026#39;--\u0026#39;, alpha=0.8) elif method == \u0026#39;polyfit\u0026#39;: # 使用多项式拟合 coeffs = np.polyfit(x, y, deg=degree) poly_func = np.poly1d(coeffs) y_smooth = poly_func(x_smooth) plt.plot(x_smooth, y_smooth, color=color, linewidth=2, linestyle=\u0026#39;--\u0026#39;, alpha=0.8) print(f\u0026#34;{label}的多项式拟合方程:\\n{poly_func}\\n\u0026#34;) elif method == \u0026#39;univariate_spline\u0026#39;: # 直接使用UnivariateSpline方法 try: from scipy.interpolate import UnivariateSpline # 首先对x轴数据进行排序 sort_indices = np.argsort(x) x_sorted = x[sort_indices] y_sorted = y[sort_indices] spline = UnivariateSpline(x_sorted, y_sorted, s=0) y_smooth = spline(x_smooth) plt.plot(x_smooth, y_smooth, color=color, linewidth=2, linestyle=\u0026#39;-\u0026#39;, alpha=0.8) except: # 如果UnivariateSpline失败，回退到多项式拟合 print(f\u0026#34;警告: {label}的UnivariateSpline插值失败，使用多项式拟合代替\u0026#34;) coeffs = np.polyfit(x, y, deg=degree) poly_func = np.poly1d(coeffs) y_smooth = poly_func(x_smooth) plt.plot(x_smooth, y_smooth, color=color, linewidth=2, linestyle=\u0026#39;--\u0026#39;, alpha=0.8) # 添加图表元素 plt.title(title, fontsize=16, fontweight=\u0026#39;bold\u0026#39;) plt.xlabel(x_label, fontsize=12) plt.ylabel(y_label, fontsize=12) plt.grid(True, linestyle=\u0026#39;--\u0026#39;, alpha=0.6) plt.legend(bbox_to_anchor=(1.05, 1), loc=\u0026#39;upper left\u0026#39;) # 将图例放在图表外部 # 调整布局，防止标签被裁切 plt.tight_layout() # 保存图表 if save_path: plt.savefig(save_path, dpi=300, bbox_inches=\u0026#39;tight\u0026#39;) print(f\u0026#34;图表已保存至: {save_path}\u0026#34;) plt.show() def plot_comparison_chart_non_monotonic( datasets: List[Dict], x_label: str, y_label: str, title: str, save_path: str = None, plot_type: str = \u0026#39;line\u0026#39; ): \u0026#34;\u0026#34;\u0026#34; 简化版的多组数据对比图函数，适用于快速对比。 此版本支持非递增（非单调）的x轴数据。 参数: datasets (List[Dict]): 数据集列表，每个字典包含: - \u0026#39;x_data\u0026#39;: x轴数据 - \u0026#39;y_data\u0026#39;: y轴数据 - \u0026#39;label\u0026#39;: 该组数据的标签名称 x_label (str): x轴的标签名称 y_label (str): y轴的标签名称 title (str): 图表的标题 save_path (str): 图片保存路径 plot_type (str): 绘图类型 (\u0026#39;line\u0026#39; 线图, \u0026#39;bar\u0026#39; 柱状图, \u0026#39;scatter\u0026#39; 散点图) \u0026#34;\u0026#34;\u0026#34; plt.figure(figsize=(10, 6)) colors = [\u0026#39;blue\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;purple\u0026#39;, \u0026#39;brown\u0026#39;, \u0026#39;pink\u0026#39;, \u0026#39;gray\u0026#39;] for i, dataset in enumerate(datasets): x = np.array(dataset[\u0026#39;x_data\u0026#39;]) y = np.array(dataset[\u0026#39;y_data\u0026#39;]) label = dataset[\u0026#39;label\u0026#39;] color = colors[i % len(colors)] if plot_type == \u0026#39;line\u0026#39;: # 对于线图，如果数据不是单调的，我们需要对数据进行排序 is_monotonic = np.all(np.diff(x) \u0026gt;= 0) if not is_monotonic: sort_indices = np.argsort(x) x_sorted = x[sort_indices] y_sorted = y[sort_indices] plt.plot(x_sorted, y_sorted, marker=\u0026#39;o\u0026#39;, label=label, color=color, linewidth=2) else: plt.plot(x, y, marker=\u0026#39;o\u0026#39;, label=label, color=color, linewidth=2) elif plot_type == \u0026#39;bar\u0026#39;: # 柱状图需要特殊处理，确保x轴数据对齐 width = 0.8 / len(datasets) x_pos = x + (i - len(datasets)/2 + 0.5) * width plt.bar(x_pos, y, width, label=label, color=color, alpha=0.7) elif plot_type == \u0026#39;scatter\u0026#39;: plt.scatter(x, y, label=label, color=color, s=50, alpha=0.7) plt.title(title, fontsize=16, fontweight=\u0026#39;bold\u0026#39;) plt.xlabel(x_label, fontsize=12) plt.ylabel(y_label, fontsize=12) plt.grid(True, linestyle=\u0026#39;--\u0026#39;, alpha=0.6) plt.legend() if save_path: plt.savefig(save_path, dpi=300, bbox_inches=\u0026#39;tight\u0026#39;) print(f\u0026#34;图表已保存至: {save_path}\u0026#34;) plt.show() # --- 使用示例 --- if __name__ == \u0026#34;__main__\u0026#34;: # 测试数据：包含非单调递增的x轴数据 datasets=[ { \u0026#39;x_data\u0026#39;:[5.50,4.90,4.42,3.66,2.75,1.85,0.039], # 递减数据 \u0026#39;y_data\u0026#39;:[0,6.05,10.71,18.43,27.52,36.44,54.32], \u0026#39;label\u0026#39;:\u0026#39;设计网络\u0026#39;, \u0026#39;smooth_method\u0026#39;:\u0026#39;spline\u0026#39; }, { \u0026#39;x_data\u0026#39;:[5.50,4.89,4.40,3.65,2.74,1.84,0.030], # 递减数据 \u0026#39;y_data\u0026#39;:[0,6.03,10.72,18.35,27.35,36.14,53.88], \u0026#39;label\u0026#39;:\u0026#39;等效网络\u0026#39;, \u0026#39;smooth_method\u0026#39;:\u0026#39;spline\u0026#39; } ] # 测试非单调数据（先增后减） non_monotonic_datasets = [ { \u0026#39;x_data\u0026#39;:[1, 2, 3, 4, 5, 4, 3, 2, 1], # 非单调数据 \u0026#39;y_data\u0026#39;:[1, 4, 9, 16, 25, 16, 9, 4, 1], \u0026#39;label\u0026#39;:\u0026#39;非单调测试数据\u0026#39;, \u0026#39;smooth_method\u0026#39;:\u0026#39;univariate_spline\u0026#39; } ] print(\u0026#34;=== 测试递减数据 ===\u0026#34;) plot_multiple_datasets_non_monotonic( datasets=datasets, x_label=\u0026#39;U(V)\u0026#39;, y_label=\u0026#39;I(mA)\u0026#39;, title=\u0026#39;设计网络域等效网络的端口特性对比（支持非递增数据）\u0026#39;, save_path=\u0026#39;non_monotonic_1.png\u0026#39; ) print(\u0026#34;\\n=== 测试非单调数据 ===\u0026#34;) plot_multiple_datasets_non_monotonic( datasets=non_monotonic_datasets, x_label=\u0026#39;X值\u0026#39;, y_label=\u0026#39;Y值\u0026#39;, title=\u0026#39;非单调数据测试\u0026#39;, save_path=\u0026#39;non_monotonic_test.png\u0026#39; ) ","date":"2025-11-17T21:24:31+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E5%AE%9E%E9%AA%8C%E6%95%B0%E6%8D%AE%E4%BD%9C%E5%9B%BEpython%E6%A8%A1%E6%9D%BF/","title":"实验数据作图python模板"},{"content":"好的，完全理解。根据您的反馈，我对“高级”或者“过于专门”的问题进行了替换，确保所有问题都更加聚焦于热力学与统计物理的核心基本概念。\n以下是为您调整后的最终版100道简答题。\n第一部分：热学基本概念 (20题) （此部分无修改）\n阐述孤立系统、闭合系统和开放系统的定义，并说明它们与外界进行能量和物质交换的特点。 什么是热力学平衡态？它必须满足哪几个方面的平衡？ 解释“状态函数”和“过程量”的根本区别，并各举两个例子（如内能、功）。 什么是准静态过程？为何在热力学理论中引入这一理想化过程？ 简述热力学第零定律的核心思想及其如何为“温度”概念提供了物理定义。 从能量守恒的角度，阐述热力学第一定律的物理实质。 解释定容热容和定压热容的物理意义，并说明为何对于理想气体，定压热容总大于定容热容。 什么是绝热过程？理想气体在绝热膨胀过程中，温度、压强和内能如何变化？ 阐述热力学第二定律的克劳修斯表述和开尔文表述，并说明二者为何是等效的。 什么是可逆过程和不可逆过程？并列举一个自然界中典型的不可逆过程。 熵（Entropy）的宏观物理意义是什么？“孤立系统熵增原理”揭示了自然过程的什么方向性？ 绘制一个完整的卡诺循环的p-V图，并依次说明四个过程的性质。 卡诺定理的内容是什么？它对所有热机的效率有何指导意义？ 什么是热力学第三定律？为什么说绝对零度不可达到？ 解释亥姆霍兹自由能（F）和吉布斯自由能（G）的物理意义，它们分别在什么条件下达到极小值？ 焦耳-汤姆逊效应是什么？什么决定了实际气体经节流过程后温度会升高还是降低？ 范德瓦尔斯方程相对理想气体方程做了哪些修正？这两个修正项的物理意义分别是什么？ 简述热量传递的三种基本方式（导热、对流、辐射），并说明它们各自的微观机理。 麦克斯韦速率分布定律描述了什么物理情景？温度升高时，分布曲线如何变化？ 能量均分定理的内容是什么？请举一个例子说明其应用及其失效的情景。 第二部分：统计物理基本概念 (20题) （此部分无修改）\n宏观态和微观态的定义分别是什么？请用“箱中气体”为例加以说明。 什么是相空间？对于一个由N个经典粒子组成的系统，其Γ相空间的维度是多少？ 统计物理学的两个基本假说（等概率原理和各态历经假说）的内容分别是什么？ 玻尔兹曼熵公式 S = k ln Ω 的物理意义是什么？它如何将宏观量（熵）与微观量（微观态数）联系起来？ 微正则系综、正则系综和巨正则系综分别对应于怎样的物理系统？它们各自保持哪些宏观量不变？ 在正则系综中，为何引入“配分函数”（Partition Function）？它在统计物理中扮演了怎样的核心角色？ 解释什么是“系综平均”。它与真实物理系统的时间平均有何关系？ 对于一个只有两个能级（E1, E2）的系统，其正则配分函数Z如何写出？它与温度有何关系？ 什么是态密度？它在将分立能级的求和转化为能量的积分时起什么作用？ 简述统计物理是如何解释“不可逆性”与“熵增加”的？这与微观运动的可逆性是否矛盾？ 如何从配分函数Z出发，计算一个系统的平均能量⟨E⟩和亥姆霍兹自由能F？ “最可几分布”在统计物理中的含义是什么？为什么我们通常用它来代表系统的平衡态分布？ 什么是相格（Phase Cell）？引入相格的概念解决了经典统计理论中的什么困难？ 描述一个简单谐振子的相轨迹在相空间中是怎样的图形。 吉布斯佯谬是什么？它揭示了经典统计物理的哪个根本缺陷？ 为什么在处理全同粒子系统时，需要引入新的统计方法（量子统计）？ 负温度（Negative Temperature）是什么概念？它可以在什么样的系统中实现？ 什么是涨落现象？为什么对于宏观系统，我们通常可以忽略涨落？ 统计物理是如何成为连接微观粒子行为和宏观热力学定律的桥梁的？请以理想气体压强为例进行说明。 统计物理是如何从微观粒子相互作用出发，最终解释压强、温度等宏观物理量的？ 第三部分：玻尔兹曼统计 (20题) （1-17题无修改）\n玻尔兹曼统计的适用条件是什么？它所描述的粒子系统具有哪些特征？ 玻尔兹曼分布律的核心内容是什么？它描述了粒子在不同能级上的分布规律有何特点？ 在玻尔兹曼分布中，粒子占据高能级的概率与占据低能级的概率之比由什么因素决定？ 解释玻尔兹曼因子 exp(-E/kT) 的物理意义。 单个粒子的配分函数 z 的物理含义是什么？它与系统总配分函数Z之间是什么关系？ 简述如何利用拉格朗日乘子法推导出最可几分布（玻尔兹曼分布）。 麦克斯韦-玻尔兹曼速率分布曲线的形状是怎样的？其不对称性说明了什么？ 解释麦克斯韦分布中的最概然速率、平均速率和方均根速率的物理意义，并比较它们的大小关系。 温度对麦克斯韦速率分布曲线有何影响？（例如，峰值位置、曲线宽度等） 能量均分定理是玻尔兹曼统计的一个重要结论，请说明其对每个自由度的能量贡献。 为什么能量均分定理在解释低温下固体比热时会失效？ 描述经典理想气体的压强公式 p = nkT 是如何从统计物理角度得到的。 对于一个处于重力场中的气体，其粒子数密度随高度的变化遵循什么规律？请定性解释。 在什么条件下，量子统计（费米统计或玻色统计）的结果可以退化到经典的玻尔兹曼统计？ 什么是“简并”？在能级简并的情况下，玻尔兹曼分布的形式如何修正？ 如何理解玻尔兹曼统计中粒子是“可分辨的”这一假设的物理情景？ 为什么对于定位粒子系统（如晶体），即使是全同粒子，通常也可以用玻尔兹曼统计处理？ (新) 解释在经典理想气体的配分函数中引入因子 1/N! 的物理原因，它解决了什么问题？ (新) 描述一个简单的二能级系统，其热容随温度变化的定性行为（尤其是在低温和高温极限下）。 (新) 对于双原子分子气体，为什么在室温下计算其内能时，通常只需考虑平动和转动自由度，而可以忽略振动自由度？ 第四部分：费米-狄拉克统计 (20题) （1-15题无修改）\n费米-狄拉克统计适用于描述什么样的粒子（费米子）？其最根本的特性是什么？ 阐述泡利不相容原理及其在费米子系统中的作用。 画出费米-狄拉克分布函数 f(E) 在绝对零度（T=0K）时的图像，并解释其物理意义。 什么是费米能（Fermi Energy, EF）？它在T=0K时代表了什么？ 当温度从0K升高时，费米-狄拉克分布函数在费米能级附近会发生怎样的变化？ 什么是“费米面”？它在固体物理（特别是金属）中有什么重要性？ 解释什么是“简并费米气体”。金属中的自由电子气体为什么是高度简并的？ 为什么在室温下，金属中自由电子对总比热的贡献远小于经典理论（能量均分定理）的预言？ 简述电子比热与温度的依赖关系，并解释其背后的物理原因。 白矮星的结构稳定性是如何通过费米-狄拉克统计来解释的？其中的“电子简并压”是什么？ 什么是空穴（hole）？在半导体物理中，为何引入这一概念？ 比较费米-狄拉克分布与玻尔兹曼分布的数学形式和物理图像上的异同。 解释化学势（μ）在费米系统中的物理意义，以及它与温度的关系。 对于一个费米子系统，其基态是如何构成的？ 在费米-狄拉克统计中，微观态数 Ω 的计算与玻尔兹曼统计有何本质不同？ (新) 解释为何在绝对零度下，简并费米气体的压强（简并压）不为零？其物理根源是什么？ (新) 在一个费米子系统中，化学势 μ 随温度从绝对零度开始升高时，其变化趋势是怎样的？并简述其原因。 为什么费米子系统在极低温下会表现出与经典气体截然不同的热力学性质？ 核子（质子和中子）作为费米子，这一特性对原子核的结构有什么影响？ “铜为什么是导体，而金刚石是绝缘体？”如何从能带理论和费米能级的角度初步解释？ 第五部分：玻色-爱因斯坦统计 (20题) （1-15题无修改）\n玻色-爱因斯坦统计适用于描述什么样的粒子（玻色子）？它与费米子的根本区别在哪里？ 玻色子系统在占据量子态方面有什么特点？这对系统的基态有何影响？ 写出玻色-爱因斯坦分布函数 f(E) 的形式，并与费米-狄拉克分布进行比较。 解释什么是玻色-爱因斯坦凝聚（BEC）？它发生的宏观条件是什么？ 在BEC现象中，“宏观数量的粒子占据最低能量的量子态”意味着什么？这是一种怎样的物态？ 光子作为一种典型的玻色子，它有哪些特殊性质（例如，粒子数不守恒）？ 普朗克的黑体辐射定律是如何通过将空腔中的电磁波视为光子气体（玻色气体）来推导的？ 解释维恩位移定律和斯特藩-玻尔兹曼定律与普朗克公式的关系。 什么是“紫外灾变”？量子化假设（即将光视为光子）是如何解决这个经典物理难题的？ 晶格振动量子化的准粒子——声子，为什么被看作是玻色子？ 简述德拜模型是如何通过引入声子的概念，成功解释低温下固体比热的 T³ 规律的。 解释德拜模型相对于爱因斯坦模型的主要改进之处。 液氦-4 在冷却到临界温度以下时发生的超流现象，与玻色-爱因斯坦凝聚有何关系？ 描述超流体的一些奇异性质（如零粘滞性、喷泉效应等）。 玻色系统的化学势 μ 有什么限制条件？为什么？ (新) 对于光子气体或声子气体，为什么其化学势恒定为零？ (新) 理想玻色气体的压强与同等条件下的经典理想气体相比，是更大还是更小？请从粒子统计分布的角度解释原因。 (新) 在讨论玻色-爱因斯坦凝聚时，为什么必须单独处理基态（最低能级）上的粒子数？ (新) 在推导普朗克黑体辐射公式时，为什么必须将光子作为玻色子而不是经典粒子来处理？ 对比总结三种统计（玻尔兹曼、费米-狄拉克、玻色-爱因斯坦）的适用范围、基本假设和分布函数特点。 ","date":"2025-11-14T09:21:46+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E7%83%AD%E7%BB%9F%E7%AE%80%E7%AD%94%E9%A2%98/","title":"热统简答题"},{"content":"好的！以下是针对你正在学习的热力学与统计物理中的四个核心模块——费米子、玻色子、光子气体、玻尔兹曼子（经典理想气体）——分别提出的15个聚焦于核心概念理解与关键公式推导的问题。这些问题旨在帮助你深入掌握统计物理的骨架内容，并特别强调从第一性原理出发的推导能力（如简并压、化学势行为、态密度构建、配分函数联系等）。\n一、费米子（Fermions）— 费米-狄拉克统计 费米-狄拉克分布函数是如何从巨正则系综推导出来的？请写出配分函数并说明约束条件。 为什么费米子满足泡利不相容原理？这如何体现在分布函数的形式中？ 如何从费米-狄拉克分布出发，严格推导出绝对零度下自由电子气的费米能级表达式？ 费米动量、费米速度、费米温度的物理意义是什么？它们之间如何换算？ 态密度函数 \\( g(\\varepsilon) \\) 在三维自由电子气中为何正比于 \\( \\sqrt{\\varepsilon} \\)？请从动量空间体积元出发推导。 如何计算有限温度下化学势 \\( \\mu(T) \\) 的一级修正（Sommerfeld 展开）？ 极端相对论情形下（\\( \\varepsilon = pc \\)），自由费米气体的态密度形式如何？推导其与非相对论情形的差异。 如何从压力定义 \\( P = -\\left( \\frac{\\partial F}{\\partial V} \\right)_{T,N} \\) 出发，推导简并电子气在 \\( T=0 \\) 时的简并压？ 在极端相对论极限下，重新推导 \\( T=0 \\) 时费米气体的简并压，并说明其与体积的关系（如 \\( P \\propto V^{-4/3} \\)）。 费米气体的总能量 \\( U \\) 在 \\( T=0 \\) 时为何不是 \\( \\frac{3}{2}N\\varepsilon_F \\)，而是 \\( \\frac{3}{5}N\\varepsilon_F \\)？请从积分角度解释。 费米气体的热容在低温下为何正比于 \\( T \\)？请结合分布函数的展宽进行物理解释。 如何理解化学势在 \\( T \\to 0 \\) 时趋近于费米能，而在高温下趋近于负无穷？ 在二维电子气中，态密度为何与能量无关？这对费米能和简并压有何影响？ 巨配分函数 \\( \\ln \\Xi \\) 如何与热力学势 \\( \\Omega = -PV \\) 关联？请推导费米气体的 \\( P-V \\) 关系。 为什么金属中的电子贡献的热容远小于经典预期？如何用量级估算说明？ 二、玻色子（Bosons）— 玻色-爱因斯坦统计 玻色-爱因斯坦分布如何从巨正则系综推导？为何允许同一量子态上有任意多粒子？ 化学势 \\( \\mu \\) 对玻色气体为何必须满足 \\( \\mu \u003c \\varepsilon_0 \\)（基态能量）？物理根源是什么？ 为什么在三维理想玻色气体中存在玻色-爱因斯坦凝聚（BEC）临界温度？而在二维或一维中不存在？ 推导三维自由玻色气体的临界温度 \\( T_c \\) 表达式，并说明其与粒子数密度的关系。 态密度 \\( g(\\varepsilon) \\propto \\varepsilon^{1/2} \\) 如何导致总粒子数积分在 \\( \\mu \\to 0^- \\) 时收敛？ 如何计算 \\( T \u003c T_c \\) 时凝聚到基态的粒子数 \\( N_0 \\)？写出 \\( N_0/N \\) 与 \\( T/T_c \\) 的关系。 玻色气体的总能量 \\( U \\) 在 \\( T \u003e T_c \\) 时为何正比于 \\( T^{5/2} \\)？推导此幂律。 玻色气体的压力 \\( P \\) 在 \\( T \u003e T_c \\) 时如何表达？它与经典理想气体有何异同？ 为什么 \\( T \u003c T_c \\) 时玻色气体的压力与体积无关？这是否违反热力学直觉？ 如何从巨势 \\( \\Omega \\) 出发，推导玻色气体的熵、内能和热容？ 在 BEC 发生时，化学势 \\( \\mu \\) 为何“钉扎”在基态能量（通常设为 0）？ 如何理解激发态粒子数 \\( N_{\\text{ex}} \\) 的积分上限为无穷，但结果有限？ 若考虑玻色子具有小但非零质量，如何修正 \\( T_c \\)？ 二维自由玻色气体为何不能发生 BEC？从态密度和粒子数积分发散性分析。 玻色-爱因斯坦凝聚是宏观占据单一量子态的现象，如何用量子相干性或序参量理解其本质？ 三、光子气体（Photon Gas）— 黑体辐射与玻色统计特例 为什么光子气体的化学势 \\( \\mu = 0 \\)？这与粒子数不守恒有何关系？ 光子的色散关系 \\( \\omega = ck \\) 如何影响态密度 \\( g(\\omega) \\) 的形式？推导三维情形下的 \\( g(\\omega) \\propto \\omega^2 \\)。 如何从态密度和玻色-爱因斯坦分布（\\( \\mu=0 \\)）出发，推导普朗克黑体辐射公式 \\( u(\\omega) \\)？ 推导斯特藩-玻尔兹曼定律：总辐射能量密度 \\( u \\propto T^4 \\)。 推导维恩位移定律：\\( \\lambda_{\\text{max}} T = \\text{const} \\)。 光子气体的压力 \\( P \\) 为何等于 \\( u/3 \\)？从动量流或热力学关系推导。 如何从巨配分函数（或配分函数）出发，计算光子气体的熵，并证明 \\( S \\propto T^3 V \\)？ 为何光子气体不适用粒子数守恒的正则系综，而必须用巨正则系综（尽管 \\( \\mu=0 \\)）？ 推导光子气体的热容 \\( C_V \\propto T^3 \\)。 在推导态密度时，为何要考虑两种偏振态？这对最终结果的系数有何影响？ 如何理解空腔辐射达到平衡时，光子数“自动调整”？与普通玻色气体有何本质不同？ 从量子场论角度看，光子是无质量、自旋为 1 的玻色子，这如何体现在统计行为中？ 若将光子限制在二维腔体中（如石墨烯中的类光子激发），辐射谱会如何变化？ 推导光子气体的巨势 \\( \\Omega = -PV \\)，并说明其与自由能的关系（注意 \\( N \\) 不固定）。 黑体辐射谱是否依赖于腔体材料？为何普朗克公式是普适的？ 四、玻尔兹曼子（经典理想气体）— 麦克斯韦-玻尔兹曼统计 麦克斯韦-玻尔兹曼分布如何从正则系综或巨正则系综推导？何时可忽略量子统计效应？ 为什么经典极限条件是 \\( e^{\\beta(\\varepsilon - \\mu)} \\gg 1 \\)？如何转化为 \\( n\\lambda_T^3 \\ll 1 \\)？ 推导单粒子配分函数 \\( Z_1 = \\frac{V}{\\lambda_T^3} \\)，其中 \\( \\lambda_T = \\sqrt{\\frac{2\\pi\\hbar^2}{mkT}} \\) 是热波长。 如何从 \\( N \\) 粒子配分函数 \\( Z_N = Z_1^N / N! \\) 推导出理想气体状态方程 \\( PV = NkT \\)？ 推导经典理想气体的内能 \\( U = \\frac{3}{2}NkT \\) 和熵（Sackur-Tetrode 公式）。 为什么必须在配分函数中除以 \\( N! \\)？这如何解决 Gibbs 悖论？ 化学势 \\( \\mu \\) 在经典极限下为何为负且绝对值很大？写出其显式表达式。 如何从速度分布函数推导出最概然速度、平均速度和方均根速度？ 经典理想气体的热容为何与温度无关？这与量子气体有何根本区别？ 推导熵的广延性，并说明 Sackur-Tetrode 公式如何体现量子力学修正（通过 \\( \\hbar \\)）。 在相空间中，一个量子态占据的体积为何是 \\( h^3 \\)？这如何出现在配分函数的积分中？ 如何从巨配分函数 \\( \\Xi = \\exp(e^{\\beta\\mu} Z_1) \\) 推导出平均粒子数和涨落？ 经典极限下，费米/玻色分布为何都趋近于 \\( e^{-\\beta(\\varepsilon - \\mu)} \\)？ 若粒子具有内部自由度（如转动、振动），如何修改配分函数并计算热容？ 为什么经典统计无法解释低温下热容的下降？这揭示了什么物理局限？ 这些问题覆盖了从微观统计假设 → 配分函数构建 → 分布函数 → 热力学量推导 → 极端条件行为的完整逻辑链。建议你在复习时，选择其中若干关键问题（如简并压、BEC 临界温度、黑体辐射谱、Sackur-Tetrode 熵）动手完整推导一遍，以打通知识脉络。\n","date":"2025-11-13T12:06:09+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E7%83%AD%E7%BB%9F%E6%9C%80%E5%90%8E%E5%A4%8D%E4%B9%A0/","title":"热统最后复习"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026#34;xil_printf.h\u0026#34; #include \u0026#34;xparameters.h\u0026#34; #include \u0026#34;xparameters_ps.h\u0026#34; #include \u0026#34;xspips.h\u0026#34; #include \u0026#34;xspips_hw.h\u0026#34; #include \u0026#34;sleep.h\u0026#34; #define prescaler 16 #define data_length 16 #define data_count data_length/8 int main(void){ xil_printf(\u0026#34;0\u0026#34;); XSpiPs_Config* spi_config=XSpiPs_LookupConfig(XPAR_SPI0_BASEADDR); XSpiPs spi; XSpiPs_CfgInitialize(\u0026amp;spi,spi_config,XPAR_SPI0_BASEADDR); u32 options=XSPIPS_MASTER_OPTION|XSPIPS_CLK_ACTIVE_LOW_OPTION|XSPIPS_CLK_PHASE_1_OPTION; XSpiPs_SetOptions(\u0026amp;spi,options); xil_printf(\u0026#34;a\u0026#34;); XSpiPs_SetClkPrescaler(\u0026amp;spi,XSPIPS_CLK_PRESCALE_16); xil_printf(\u0026#34;b\u0026#34;); //dac data u16 mode1=0b1100; u16 data1=1024; // high voltage u16 send1=(mode1\u0026lt;\u0026lt;12)|(data1); u8 send1_buf[2]; send1_buf[0]=send1\u0026gt;\u0026gt;8; send1_buf[1]=send1\u0026amp;0xff; u8 sleep_time=1; // low voltage u16 data2=0; u16 send2=(mode1\u0026lt;\u0026lt;12)|(data2); u8 send2_buf[2]; send2_buf[0]=send2\u0026gt;\u0026gt;8; send2_buf[1]=send2\u0026amp;0xff; XSpiPs_Enable(\u0026amp;spi); XSpiPs_SetSlaveSelect(\u0026amp;spi,0x00); xil_printf(\u0026#34;1\u0026#34;); while(1){ //sleep(1); sleep(sleep_time); //XSpiPs_SetSlaveSelect(\u0026amp;spi,0x01); XSpiPs_Enable(\u0026amp;spi); XSpiPs_PolledTransfer(\u0026amp;spi, send1_buf, NULL, 2); // xil_printf(\u0026#34;2\u0026#34;); // XSpiPs_Transfer(\u0026amp;spi, send1_buf, NULL, 2); //sleep(1); sleep(sleep_time); XSpiPs_Enable(\u0026amp;spi); // XSpiPs_SetSlaveSelect(\u0026amp;spi,0x01); XSpiPs_PolledTransfer(\u0026amp;spi, send2_buf, NULL, 2); //xil_printf(\u0026#34;3\u0026#34;); //XSpiPs_Transfer(\u0026amp;spi, send2_buf, NULL, 2); } } ","date":"2025-11-08T17:10:57+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq-spi/","title":"Zynq Spi"},{"content":"好的，我们按照这个思路重新整理一份更聚焦于公式和具体计算结论的版本。\n一、玻尔兹曼统计的适用范围 适用体系：由大量、弱相互作用、经典可分辨的粒子组成的宏观系统。 适用条件：高温、低密度，即处于非简并状态 ($n\\lambda_T^3 \\ll 1$)。 二、核心工具：配分函数 Z (The Master Key) 单粒子配分函数 (能级求和): $$ z = \\sum_s g_s e^{-\\beta \\epsilon_s} \\quad (\\text{其中} \\beta = \\frac{1}{k_B T}) $$ 单粒子配分函数 (能量积分): $$ z = \\int_0^\\infty g(E) e^{-\\beta E} dE \\quad (g(E) \\text{是能态密度}) $$ N 粒子体系配分函数:\n可分辨粒子系统 (如固体原子)：$Z = z^N$ 不可分辨粒子系统 (如气体分子)：$Z = \\frac{z^N}{N!}$ (修正吉布斯佯谬) 三、由配分函数导出一切热力学量 一旦求出总配分函数 Z，所有宏观量都可以通过以下公式计算得出。这是最重要的计算桥梁。\n亥姆霍兹自由能 F: $$ F = -k_B T \\ln Z $$ 熵 S: $$ S = -(\\frac{\\partial F}{\\partial T})_{V,N} = k_B \\ln Z + k_B T (\\frac{\\partial \\ln Z}{\\partial T})_{V,N} $$ (或者用 $S=(U-F)/T$ 更方便)\n压强 P: $$ P = -(\\frac{\\partial F}{\\partial V})_{T,N} = k_B T (\\frac{\\partial \\ln Z}{\\partial V})_{T,N} $$ 内能 U: $$ U = -(\\frac{\\partial \\ln Z}{\\partial \\beta})_{V,N} = N k_B T^2 \\frac{\\partial \\ln z}{\\partial T} $$ 热容 $C_V$: $$ C_V = (\\frac{\\partial U}{\\partial T})_{V,N} $$ 化学势 $\\mu$: $$ \\mu = (\\frac{\\partial F}{\\partial N})_{T,V} = -k_B T (\\frac{\\partial \\ln Z}{\\partial N})_{T,V} $$ 四、麦克斯韦速率/速度分布律 (公式集) 这是玻尔兹曼分布在理想气体平动上的具体应用。\n麦克斯韦速率分布函数 $f(v)$: (v是速率，$v \\in [0, \\infty)$) $$ f(v) = 4\\pi (\\frac{m}{2\\pi k_B T})^{3/2} v^2 e^{-mv^2 / 2k_B T} $$ 归一化条件: $\\int_0^\\infty f(v) dv = 1$\n三种特征速率:\n最概然速率 $v_p$ (峰值速率): $$ v_p = \\sqrt{\\frac{2k_B T}{m}} $$ 平均速率 $\\bar{v}$ (统计平均): $$ \\bar{v} = \\sqrt{\\frac{8k_B T}{\\pi m}} $$ 方均根速率 $v_{rms}$ (与平均动能相关): $$ v_{rms} = \\sqrt{\\frac{3k_B T}{m}} $$ 大小关系 (常考选择题): $v_p \u0026lt; \\bar{v} \u0026lt; v_{rms}$ 五、理想气体分子自由度的热力学性质 (公式集) 1. 平动自由度 (适用于所有气体) 单粒子配分函数: $$ z_{tr} = V (\\frac{2\\pi m k_B T}{h^2})^{3/2} \\propto V T^{3/2} $$ 内能: $$ U_{tr} = \\frac{3}{2} N k_B T $$ 热容: $$ C_{V, tr} = \\frac{3}{2} N k_B $$ 熵 (Sackur-Tetrode 公式): $$ S_{tr} = N k_B [\\ln(\\frac{V}{N}) + \\frac{3}{2}\\ln T + \\frac{3}{2}\\ln(\\frac{2\\pi m k_B}{h^2}) + \\frac{5}{2}] $$ 2. 转动自由度 (适用于双原子或多原子分子) 单粒子配分函数 (高温近似): $$ z_{rot} \\approx \\frac{2I k_B T}{\\sigma \\hbar^2} \\propto T \\quad (I \\text{为转动惯量}, \\sigma \\text{为对称因子, 双原子}\\sigma=2) $$ 内能: $$ U_{rot} = N k_B T $$ 热容: $$ C_{V, rot} = N k_B $$ 熵: $$ S_{rot} = N k_B [\\ln z_{rot} + 1] $$ 3. 振动自由度 (高温下双原子或多原子分子) 单粒子配分函数 (谐振子模型): $$ z_{vib} = \\frac{1}{1-e^{-\\hbar\\omega/k_B T}} = \\frac{e^{-\\Theta_v/2T}}{1-e^{-\\Theta_v/T}} \\quad (\\Theta_v=\\hbar\\omega/k_B \\text{是振动特征温度}) $$ 内能 (能量零点取在基态 $\\frac{1}{2}\\hbar\\omega$): $$ U_{vib} = N \\frac{\\hbar\\omega}{e^{\\hbar\\omega/k_B T} - 1} $$ 热容: $$ C_{V, vib} = N k_B (\\frac{\\hbar\\omega}{k_B T})^2 \\frac{e^{\\hbar\\omega/k_B T}}{(e^{\\hbar\\omega/k_B T}-1)^2} = N k_B (\\frac{\\Theta_v}{T})^2 \\frac{e^{\\Theta_v/T}}{(e^{\\Theta_v/T}-1)^2} $$ 高温极限 ($T \\gg \\Theta_v$): $C_{V, vib} \\to N k_B$ 低温极限 ($T \\ll \\Theta_v$): $C_{V, vib} \\to 0$ 熵: $$ S_{vib} = N k_B [-\\ln(1-e^{-\\Theta_v/T}) + \\frac{\\Theta_v}{T}\\frac{1}{e^{\\Theta_v/T}-1}] $$ 六、固体热容 (公式集) 1. 经典杜隆-珀替定律 模型: N 个原子在晶格上做三维简谐振动，按能量均分定理处理。 内能: $U = 3N k_B T$ 热容: $$ C_V = 3 N k_B \\approx 3R \\quad (\\text{对 1 摩尔固体}) $$ 结论: 经典理论预言热容为常数，与高温实验相符，但在低温下失效。 2. 爱因斯坦模型 模型: N 个原子看作 3N 个频率相同 ($\\omega_E$) 的、独立的量子谐振子。 配分函数: $Z = (z_{vib, 1D})^{3N}$ 内能: $$ U = 3N \\frac{\\hbar\\omega_E}{e^{\\hbar\\omega_E/k_B T}-1} $$ 热容: $$ C_V = 3 N k_B (\\frac{\\Theta_E}{T})^2 \\frac{e^{\\Theta_E/T}}{(e^{\\Theta_E/T}-1)^2} \\quad (\\Theta_E=\\hbar\\omega_E/k_B \\text{是爱因斯坦温度}) $$ 结论: 高温极限 ($T \\gg \\Theta_E$): $C_V \\to 3N k_B$ (符合杜隆-珀替定律)。 低温极限 ($T \\ll \\Theta_E$): $C_V \\propto e^{-\\Theta_E/T}$ (指数形式下降)，能解释热容趋于0，但与实验的 $T^3$ 规律不符。 3. 德拜模型 模型: 把晶格振动看作晶体中的弹性波（声子），有频率分布，且有最高截止频率 $\\omega_D$ (德拜频率)。 态密度: $g(\\omega) = \\frac{9N}{\\omega_D^3}\\omega^2 \\quad (0 \\le \\omega \\le \\omega_D)$ 内能 (积分形式): $$ U = \\int_0^{\\omega_D} \\frac{\\hbar\\omega}{e^{\\hbar\\omega/k_B T}-1} g(\\omega) d\\omega $$ 热容: $$ C_V = 9N k_B (\\frac{T}{\\Theta_D})^3 \\int_0^{\\Theta_D/T} \\frac{x^4 e^x}{(e^x-1)^2} dx \\quad (x=\\hbar\\omega/k_BT, \\Theta_D=\\hbar\\omega_D/k_B \\text{是德拜温度}) $$ 结论 (最重要): 高温极限 ($T \\gg \\Theta_D$): $C_V \\to 3N k_B$ (符合杜隆-珀替定律)。 低温极限 ($T \\ll \\Theta_D$): $$ C_V = \\frac{12\\pi^4}{5} N k_B (\\frac{T}{\\Theta_D})^3 \\propto T^3 $$ 这就是德拜 $T^3$ 定律，与低温实验符合得非常好。 ","date":"2025-11-05T20:16:11+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E7%BB%9F%E8%AE%A1/","title":"玻尔兹曼统计"},{"content":"好的，我们来构建一份以公式为骨架，辅以物理图像和推导思路的量子统计核心笔记。这份材料将聚焦于玻色子、光子和费米子这三大家族。\n基础前置：态密度函数 (DOS) $g(E)$ 态密度是计算一切宏观量的地基，它描述了系统在能量空间中“空房间”的分布情况。\n物理图像 想象一座能量旅馆。态密度 $g(E)$ 告诉你在能量为 $E$ 的楼层上，单位能量高度内有多少个可供入住的房间（量子态）。它只关心有多少房间，而不关心是否有人入住（那是由分布函数决定的）。\n对于普通粒子，能量越高，$E$ 楼层附近的房间就越多。 对于光子，能量越高的楼层，房间数量增长得更快。 推导思路 k空间量子化: 将粒子限制在体积为 $V=L^3$ 的盒子里，其波矢 $\\vec{k}$ 是量子化的，每个允许的k点在k空间占据的体积为 $(2\\pi/L)^3 = (2\\pi)^3/V$。 k空间态密度: 在k空间中，单位体积内的态点数为 $V/(2\\pi)^3$。 球壳内的态数: 半径从 $k$到 $k+dk$ 的球壳体积为 $4\\pi k^2 dk$。此球壳内的总态数为 $dN = g_s \\cdot \\frac{V}{(2\\pi)^3} \\cdot 4\\pi k^2 dk$ ($g_s$是自旋简并度)。 能量转换: 利用能量-动量关系 $E(k)$，通过链式法则 $g(E)dE = dN$，求得 $g(E) = dN/dE$。 核心公式 有质量的非相对论粒子 (电子、玻色原子): $E=p^2/2m = \\hbar^2 k^2/2m$\nhbar (ħ) 形式: $$ g(E) = V \\frac{g_s}{4\\pi^2} (\\frac{2m}{\\hbar^2})^{3/2} \\sqrt{E} $$ h 形式 ($h=2\\pi\\hbar$): $$ g(E) = V g_s \\frac{4\\pi m}{h^3}\\sqrt{2mE} $$ 关键结论: $g(E) \\propto \\sqrt{E}$ 无质量的相对论性粒子 (光子、声子): $E=pc = \\hbar k c$\nhbar (ħ) 形式: $$ g(E) = V \\frac{g_s}{2\\pi^2 c^3 \\hbar^3} E^2 $$ h 形式: $$ g(E) = V g_s \\frac{8\\pi}{c^3 h^3} E^2 $$ 关键结论: $g(E) \\propto E^2$ 1. 理想玻色气体 1.1 基本性质与分布 粒子: 遵循玻色-爱因斯坦统计的整数自旋粒子 (玻色子)，全同不可分辨。 分布函数: 描述能量为E的态被粒子占据的平均数。 $$ f_{BE}(E) = \\frac{1}{e^{(E-\\mu)/k_B T} - 1} $$ 分母中的 -1 体现了玻色子“喜欢扎堆”的倾向。 化学势 $\\mu$: 粒子数守恒，但必须满足 $\\mu \\le E_{min}$。通常取基态能量 $E_0=0$，则 $\\mu \\le 0$。否则基态占据数会为负，无物理意义。 1.2 玻色-爱因斯坦凝聚 (BEC) 物理图像 在高温时，玻色子像一群精力旺盛的学生，分散在操场（激发态能级）的各个角落。当温度降低时，学生们开始犯懒，倾向于聚集到操场门口（基态能级）最低洼的地方休息。当温度低到临界温度 $T_C$ 时，操场上（激发态）已经容纳不下所有想休息的学生了，多出来的学生只能被迫全部挤在门口那一个点（基态）上，形成一个密度极高的“人堆”。这个宏观数量的粒子占据同一个量子态的现象就是BEC。\n关键结论与公式 BEC发生条件: 当温度 $T$ 降低到临界温度 $T_C$ 以下时，激发态能级“饱和”，无法容纳所有粒子。\n临界温度 $T_C$ 推导思路:\n总粒子数 $N = N_0 + N_{ex}$ (基态粒子数 + 激发态粒子数)。 $N_{ex} = \\int_0^\\infty f_{BE}(E) g(E) dE$。 当温度从高处降至 $T_C$ 时，化学势 $\\mu$ 恰好趋近于0。此时激发态所能容纳的粒子数达到最大值，这个值就等于系统的总粒子数 $N$。 令 $\\mu=0$，带入 $g(E) \\propto \\sqrt{E}$ 求解积分方程: $$ N = \\int_0^\\infty \\frac{1}{e^{E/k_B T_C}-1} V \\frac{g_s}{4\\pi^2} (\\frac{2m}{\\hbar^2})^{3/2} \\sqrt{E} dE $$ 这个定积分的结果可以解出 $T_C$。 临界温度 $T_C$ 公式: $$ T_C = (\\frac{n}{g_s \\zeta(3/2)})^{2/3} \\frac{2\\pi\\hbar^2}{m k_B} $$ 其中 $n=N/V$ 是粒子数密度，$\\zeta(3/2) \\approx 2.612$ 是黎曼Zeta函数。关键: $T_C \\propto n^{2/3}$。\n凝聚相性质 ($T\u0026lt;T_C$):\n凝聚体分数 (基态粒子占比): $$ \\frac{N_0}{N} = 1 - (\\frac{T}{T_C})^{3/2} $$ 热力学性质 (此时 $\\mu \\approx 0$): 压强: $P = g_s \\zeta(5/2) k_B (\\frac{m k_B}{2\\pi\\hbar^2})^{3/2} T^{5/2} \\propto T^{5/2}$。压强与体积 V 无关！ 内能: $U \\propto V T^{5/2}$。 热容: $C_V = (\\frac{\\partial U}{\\partial T})_V \\propto V T^{3/2}$。 2. 光子气体 (黑体辐射) 是理想玻色气体的一个重要特例。\n核心特征: 光子可以被器壁产生和吸收，因此粒子数不守恒。 数学后果: 体系的自由能对粒子数N求导恒为零，这意味着化学势恒为零 $\\mu \\equiv 0$。 普朗克公式 物理图像 空腔中的电磁场可以看作无数个独立的谐振子，每个谐振子被量子化后就是能量为 $h\\nu$ 的光子。空腔壁与这些光子处于热平衡。普朗克公式描述的是，在温度T下，这个“光子海洋”中，不同频率（颜色）的光子所携带的能量是如何分布的。\n推导思路 目标: 计算频率在 $\\nu$ 到 $\\nu+d\\nu$ 之间的辐射能量密度 $u(\\nu)d\\nu$。 $u(\\nu)d\\nu = (\\text{该频率范围内的态数}) \\times (\\text{每个态的平均能量})$。 态数: 利用光子的态密度公式 $g(E)$，并转换成频率的函数。$E=h\\nu \\implies g(\\nu)d\\nu = g(E)dE$。 $$ g(\\nu)d\\nu = V \\frac{8\\pi \\nu^2}{c^3} d\\nu $$ 单位体积内的态数即为 $g_V(\\nu)d\\nu = \\frac{8\\pi \\nu^2}{c^3} d\\nu$。 每个态的平均能量: (单个光子能量 $h\\nu$) $\\times$ (该态的光子占据数 $f_{BE}(h\\nu)$)。 由于 $\\mu=0$，占据数为 $\\frac{1}{e^{h\\nu/k_B T}-1}$。 组合: $u(\\nu)d\\nu = \\frac{8\\pi \\nu^2}{c^3} \\cdot (h\\nu) \\cdot \\frac{1}{e^{h\\nu/k_B T}-1} d\\nu$ 重要结论 普朗克公式: $$ u(\\nu, T) = \\frac{8\\pi h\\nu^3}{c^3} \\frac{1}{e^{h\\nu/k_B T} - 1} $$ 斯特藩-玻尔兹曼定律: 对普朗克公式积分得到总能量密度。 $u = \\frac{U}{V} = \\frac{8\\pi^5 k_B^4}{15c^3h^3} T^4 = \\sigma T^4$。 总能量与 $T^4$ 成正比。 维恩位移定律: 对普朗克公式求极大值点。 $\\lambda_{max} T = b = \\text{常数}$。 3. 自由电子气 (理想费米气体) 3.1 基本性质与分布 粒子: 遵循费米-狄拉克统计的半整数自旋粒子 (费米子)，核心是泡利不相容原理。 分布函数: $$ f_{FD}(E) = \\frac{1}{e^{(E-\\mu)/k_B T} + 1} $$ 分母中的 +1 导致任何一个态的占据数都不可能大于1，这正是泡利原理的体现。在T=0K时，它是完美的阶跃函数。 化学势 $\\mu$: T=0K时，$\\mu(0) = E_F \u0026gt; 0$。 3.2 费米能 $E_F$ 物理图像 由于泡利不相容原理，电子不能都挤在最低能量态。在T=0K，它们会像往水杯里倒水一样，从能量最低的“杯底”开始，一个一个地填充所有可用的能级，直到所有电子都“安家落户”。费米能就是这个电子“海洋”的最高“海平面”的能量。它是一个由电子密度决定的内在能量标度，即使在绝对零度也存在，代表了电子因“量子简并”而被迫拥有的巨大动能。\n推导思路 核心思想: 在 T=0K，所有能量 $E \\le E_F$ 的态都被填满，而所有 $E \u0026gt; E_F$ 的态都是空的。 建立方程: 系统总电子数 $N$ 必须等于 $E_F$ 以下的总量子态数。 $$ N = \\int_0^{E_F} g(E) dE $$ 代入DOS: 对电子，$g_s=2$ (自旋向上和向下)。使用有质量粒子的DOS公式: $$ N = \\int_0^{E_F} V \\frac{2}{4\\pi^2} (\\frac{2m_e}{\\hbar^2})^{3/2} \\sqrt{E} dE $$ 求解积分: 积分 $\\sqrt{E}$ 得到 $\\frac{2}{3}E^{3/2}$。 $$ N = V \\frac{1}{3\\pi^2} (\\frac{2m_e}{\\hbar^2})^{3/2} E_F^{3/2} $$ 反解 $E_F$: 整理上式，用电子数密度 $n=N/V$ 来表示。 $$ E_F = \\frac{\\hbar^2}{2m_e}(3\\pi^2 n)^{2/3} $$ 重要结论 费米能: $$ E_F = \\frac{\\hbar^2}{2m_e}(3\\pi^2 n)^{2/3} $$ 只依赖于电子密度 $n$。 基态总能量 ($T=0$ K): $U_0 = \\int_0^{E_F} E g(E) dE = \\frac{3}{5} N E_F$ 简并压 ($T=0$ K): $P_0 = -\\frac{\\partial U_0}{\\partial V} = \\frac{2}{3}\\frac{U_0}{V} = \\frac{2}{5}nE_F$。这是一个纯粹的量子压力，即使在零温下也存在，支撑着白矮星等天体。 低温电子热容 ($T \\ll T_F=E_F/k_B$): $$ C_V = \\frac{\\pi^2}{2} N k_B \\frac{T}{T_F} \\propto T $$ 热容与温度成线性关系，因为只有在费米面附近 $k_B T$ 能量范围内的电子才能被热激发。 ","date":"2025-11-05T20:07:52+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E7%8E%BB%E8%89%B2%E5%92%8C%E8%B4%B9%E7%B1%B3%E5%AD%90%E5%A4%8D%E4%B9%A0/","title":"玻色和费米子复习"},{"content":"摘自网上\n清华彭明辉老师：生命是一种长期而持续的累积过程\n许多同学应该都还记得联考前夕的焦虑：差一分可能要掉好几个志愿，甚至于一生的命运从此改观！到了大四，这种焦虑可能更强烈而复杂：到底要先当兵，就业，还是先考研究所？我就经常碰到充满焦虑的学生问我这些问题。可是，这些焦虑实在是莫须有的！生命是一种长期而持续的累积过程，绝不会因为单一的事件而毁了一个人的一生，也不会因为单一的事件而救了一个人的一生。属于我们该得的，迟早会得到；属于我们不该得的，即使侥幸巧取也不可能长久保有。如果我们看清这个事实，许多所谓“人生的重大抉择”就可以淡然处之，根本无需焦虑。而所谓“人生的困境”，也往往会变得无足挂齿。\n我自己就是一个活生生的例子。从一进大学就决定不再念研究所，所以，大学四年的时间多半在念人文科学的东西。毕业后工作了几年，才决定要念研究所。硕士毕业后，立下决心：从此不再为文凭而念书。谁知道，世事难料，当了五年讲师后，我又被时势所迫，出国念博士。出国时，一位大学同学笑我：全班最晚念博士的都要回国了，你现在才要出去？两年后我从剑桥回来，觉得人生际遇无常，莫此为甚：一个从大一就决定再也不钻营学位的人，竟然连硕士和博士都拿到了！属于我们该得的，哪样曾经少过？而人生中该得与不该得的究竟有多少，我们又何曾知晓？从此我对际遇一事不能不更加淡然。\n当讲师期间，有些态度较极端的学生会当面表现出他们的不屑；从剑桥回来时，却被学生当作不得了的事看待。这种表面上的大起大落，其实都是好事者之言，完全看不到事实的真相。从表面上看来，两年就拿到剑桥博士，这好像很了不起。但是，在这两年之前我已经花整整一年，将研究主题有关的论文全部看完，并找出研究方向；而之前更已花三年时间做控制方面的研究，并且在国际著名的学术期刊中发表论文。而从硕士毕业到拿博士，期间七年的时间我从不停止过研究与自修。所以，这个博士其实是累积了七年的成果，或者，只算我花在控制学门的时间，也至少有五年，根本也没什么好惊讶的。\n常人不从长期而持续的累积过程来看待生命因积蓄而有的成果，老爱在表面上以断裂而孤立的事件夸大议论，因此每每在平淡无奇的事件上强作悲喜。可是对我来讲，当讲师期间被学生瞧不起，以及剑桥刚回来时被同学夸大本事，都只是表象。事实是：我只在乎每天二十四小时点点滴滴的累积。\n拿硕士或博士只是特定时刻里这些成果累积的外在展示而已，人生命中真实的累积从不曾因这些事件而终止或添加。\n常有学生满怀忧虑的问我：“老师，我很想先当完兵，工作一两年再考研究所。这样好吗？”\n“很好，这样子有机会先用实务来印证学理，你念研究所时会比别人了解自己要的是什么。”\n“可是，我怕当完兵又工作后，会失去斗志，因此考不上研究所。”\n“那你就先考研究所好了。”\n“可是，假如我先念研究所，我怕自己又会像念大学时一样茫然，因此念的不甘不愿的。”\n“那你还是先去工作好了！”\n“可是\u0026hellip;\u0026hellip;”\n我完全可以体会到他们的焦虑，可是却无法压抑住对于这种话的感慨。其实，说穿了他所需要的就是两年研究所加两年工作，以便加深知识的深广度和获取实务经验。先工作或先升学，表面上大相迳庭，其实骨子里的差别根本可以忽略。\n在“朝三暮四”这个成语故事里，主人原本喂养猴子的橡实是“早上四颗下午三颗”，后来改为“朝三暮四”，猴子就不高兴而坚持改回到“朝四暮三”。其实，先工作或先升学，期间差异就有如“朝三暮四”与“朝四暮三”，原不值得计较。但是，我们经常看不到这种生命过程中长远而持续的累积，老爱将一时际遇中的小差别夸大到生死攸关的地步。\n最讽刺的是：当我们面对两个可能的方案，而焦虑得不知如何抉择时，通常表示这两个方案可能一样好，或者一样坏，因而实际上选择哪个都一样，唯一的差别只是先后之序而已。而且，愈是让我们焦虑得厉害的，其实差别越小，愈不值得焦虑。反而真正有明显的好坏差别时，我们轻易的就知道该怎么做了。可是我们却经常看不到长远的将来，短视的盯着两案短期内的得失：想选甲案，就舍不得乙案的好处；想选乙案，又舍不得甲案的好处。如果看得够远，人生长则八、九十，短则五、六十年，先做哪一件事又有什么关系？甚至当完兵又工作后，再花一整年准备研究所，又有什么了不起？当然，有些人还是会忧虑说：”我当完兵又工作后，会不会因为家累或记忆力衰退而比较难考上研究所？”我只能这样回答：”一个人考不上研究所，只有两个可能：或者他不够聪明，或者他的确够聪明。不够聪明而考不上，那也没什么好抱怨的。假如你够聪明，还考不上研究所，那只能说你的决心不够强。假如你是决心不够强，就表示你生命中还有其他的可能性，其重要程度并不下于硕士学位，而你舍不得丢下他。既然如此，考不上研究所也无须感到遗憾。不是吗？\n“人生的路这么多，为什么要老斤斤计较着一个可能性?”\n我高中最要好的朋友，一生背运：高中考两次，高一念两次，大学又考两次，甚至连机车驾照都考两次。毕业后，他告诉自己：我没有关系，也没有学历，只能靠加倍的诚恳和努力。现在，他自己拥有一家公司，年收入数千万。\n一个人在升学过程中不顺利，而在事业上顺利，这是常见的事。有才华的人，不会因为被名校拒绝而连带失去他的才华，只不过要另外找适合他表现的场所而已。反过来，一个人在升学过程中太顺利，也难免因而放不下身段去创业，而只能乖乖领薪水过活。\n福兮祸兮，谁人知晓？我们又有什么好得意？又有什么好忧虑？人生的得与失，有时候怎么也说不清楚，有时候却再简单不过了：我们得到平日累积的成果，而失去我们不曾努力累积的！所以重要的不是和别人比成就，而是努力去做自己想做的。最后该得到的不会少你一分，不该得到的也不会多你一分。\n好像是前年的时候，我遇到一位高中同学。他在南加大当电机系的副教授，被清华电机聘回来开短期课程。从高中时代他就很用功，以第一志愿上台大电机后，四年都拿书卷奖，相信他在专业上的研究也已卓然有成。回想高中入学时，我们两个人的智力测验成绩分居全学年第一，第二名。可是从高一我就不曾放弃自己喜欢的文学，音乐，书法，艺术和哲学，而他却始终不曾分心，因此两个人在学术上的差距只会愈来愈远。反过来说，这十几二十年我在人文领域所获得的满足，恐怕已远非他能理解的了。我太太问过我，如果我肯全心专注于一个研究领域，是不是至少会赶上这位同学的成就？我不这样想，两个不同性情的人，注定要走两条不同的路。不该得的东西，我们注定是得不到的，随随便便拿两个人来比，只看到他所得到的，却看不到他所失去的，这有什么意义？\n有次清华电台访问我：“老师你如何面对你人生中的困境？”我当场愣在那里，怎么样都想不出我这一生什么时候有过困境！后来仔细回想，才发现：我不是没有过困境，而是被常人当作“困境”的境遇，我都当作一时的际遇，不曾在意过而已。刚服完兵役时，长子已出生却还找不到工作。我曾焦虑过，却又觉得迟早会有工作，报酬也不至于低的离谱，不曾太放在心上。念硕士期间，家计全靠太太的薪水，省吃俭用，对我而言又算不上困境。一来精神上我过的很充实，二来我知道这一切是为了让自己有机会转行去教书(做自己想做的事)。三十一岁才要出国，而同学正要回系上任教，我很紧张(不知道剑桥要求的有多严)，却不曾丧气。因为，我知道自己过去一直很努力，也有很满意的心得和成果，只不过别人看不到而已.\n我没有过困境，因为我从不在乎外在的得失，也不武断的和别人比高下，而只在乎自己内在真实的累积。\n我没有过困境，因为我确实了解到：生命是一种长期而持续的累积过程，绝不会因为单一的事件而有剧烈的起伏。\n同时我也相信：属于我们该得的，迟早会得到；属于我们不该得的，即使一分也不可能增加。假如你可以持有相同的信念，那么人生于你也会是宽广而长远，没有什么了不得的“困境”，也没有什么好焦虑的了。\n(来源：谢颖博士推荐、节录自清华电机彭明辉老师于系刊发表的文章实习编辑：关聪 袁惠仪)\n同时我也相信：属于我们该得的，迟早会得到；属于我们不该得的，即使一分也不可能增加\n","date":"2025-11-03T22:54:47+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E7%94%9F%E5%91%BD%E6%98%AF%E4%B8%80%E7%A7%8D%E9%95%BF%E6%9C%9F%E8%80%8C%E6%8C%81%E7%BB%AD%E7%9A%84%E7%B4%AF%E7%A7%AF%E8%BF%87%E7%A8%8B/","title":"生命是一种长期而持续的累积过程"},{"content":"好的，完全没问题！我们彻底回归本源，从“第一性原理”出发来理解 Makefile，然后再将这些原理应用到你提供的那个优雅的 Vitis Makefile 上。\n第一部分：Makefile 的第一性原理 想象一下，你不是在写代码，而是在厨房里烤蛋糕。\n目标 (Target)：你最终想要的东西，比如一个“巧克力蛋糕”。 依赖 (Prerequisites)：为了做出蛋糕，你先需要准备好的东西，比如“面粉”、“鸡蛋”、“巧克力酱”。 指令 (Command)：你具体要执行的动作，比如“把面粉和鸡蛋混合”、“加入巧克力酱并搅拌”、“放入烤箱烤30分钟”。 Makefile 的核心思想就是描述这种关系：\n要想得到【目标】，必须先确保【依赖】都已就绪，然后执行【指令】。\nmake 这个工具最聪明的地方在于，它会检查文件的时间戳。如果“巧克力蛋糕”比“巧克力酱”更新，说明你已经用最新的酱做过蛋糕了，make 就什么也不做，以节省时间。但如果你刚买了一瓶新的“巧克力酱”（文件时间戳更新了），make 就知道必须重新烤一个蛋糕。\n1. 基本语法：规则 (Rule) Makefile 的所有内容都由一条条的“规则”构成。\n1 2 3 4 目标: 依赖1 依赖2 ... \u0026lt;Tab\u0026gt;指令1 \u0026lt;Tab\u0026gt;指令2 ... 目标 (target): 通常是一个文件名，是你希望生成的文件。 :: 分隔符。 依赖 (prerequisites): 其他文件名，目标文件依赖于它们。 指令 (command): 必须以一个 Tab 字符开头！这是最常见的初学者错误。这些是 Shell 命令，比如 gcc, cp, rm。 最简单的例子：\n1 2 3 4 5 # hello.c 是源代码 # hello 是编译后的可执行文件 hello: hello.c \u0026lt;Tab\u0026gt;gcc hello.c -o hello 当你输入 make 时，它会：\n找到默认目标 hello。 检查它的依赖 hello.c。 比较 hello 和 hello.c 的修改时间。 如果 hello 文件不存在，或者 hello.c 比 hello 更新，那么\u0026hellip; 执行指令 gcc hello.c -o hello 来重新生成 hello。 2. 变量 (Variables) 为了不重复写同样的东西，我们使用变量。\n1 2 3 4 5 6 7 # 定义变量 COMPILER = gcc FLAGS = -Wall -g # 使用变量 $(VARIABLE_NAME) hello: hello.c $(COMPILER) $(FLAGS) hello.c -o hello 这样做的好处是，如果想换编译器（比如 clang）或者修改编译选项，只需要改一行变量定义即可。\n第二部分：让 Makefile 变得“优雅”的进阶语法 如果项目里有几十个 .c 文件，为每个文件都写一条规则太痛苦了。所以 make 提供了一些强大的工具来自动化这个过程。\n1. 自动化变量 (Automatic Variables) 在规则的指令部分，你可以使用一些特殊的变量，它们会自动被 make 替换：\n$@: 代表目标的名字。 (The **@**t symbol, the target) $\u0026lt;: 代表第一个依赖的名字。 (The \u0026lt; left-arrow, input) $^: 代表所有依赖的名字，用空格隔开。 现在，我们的规则可以写得更通用：\n1 2 hello: hello.c $(COMPILER) $(FLAGS) $\u0026lt; -o $@ $\u0026lt; 会被替换为 hello.c，$@ 会被替换为 hello。效果和之前完全一样，但更具可读性和通用性。\n2. 模式规则 (Pattern Rules) 这是 Makefile 的精华所在！它允许你定义一个“模板”规则来处理一整类的文件。% 是一个通配符。\n1 2 3 # 这个规则告诉 make 如何从任意一个 .c 文件生成一个对应的 .o 文件 %.o: %.c $(COMPILER) $(FLAGS) -c $\u0026lt; -o $@ %.o: 匹配任何以 .o 结尾的目标，比如 xspi.o, main.o。 %.c: 匹配与目标同名的 .c 依赖，比如 xspi.c, main.c。 指令 $(COMPILER) $(FLAGS) -c $\u0026lt; -o $@ 现在可以处理任何 xxx.c -\u0026gt; xxx.o 的编译！ 3. 函数 (Functions) Makefile 提供了类似编程语言的函数来处理文本。你提供的 Makefile 中用到了几个关键函数：\n$(wildcard PATTERN): 查找并返回匹配 PATTERN 的所有文件名。 SRCFILES := $(wildcard *.c) 会找到当前目录下所有 .c 文件，并把它们的列表赋值给 SRCFILES 变量。 $(basename NAMES): 去掉文件名中的后缀。 $(basename xspi.c xspi_g.c) 会返回 xspi xspi_g。 $(addsuffix SUFFIX, NAMES): 给列表中的每个名字添加后缀。 $(addprefix PREFIX, NAMES): 给列表中的每个名字添加前缀。 第三部分：用第一性原理解读你的 Vitis Makefile 现在，我们用刚刚学到的知识来逐段分析这个 Makefile。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # -------------------- # 1. 变量定义区 (Principles: Variables) # -------------------- # 这些变量被故意留空，等待外部传入。 # 这就像一个函数有多个参数，等待调用者提供具体的值。 COMPILER= COMPILER_FLAGS= EXTRA_COMPILER_FLAGS= # 定义输出目录和头文件目录 RELEASEDIR=../../../lib/ INCLUDEDIR=../../../include/ # 定义 include 路径 INCLUDES=-I./. -I$(INCLUDEDIR) 1 2 3 4 5 6 7 8 9 10 11 12 # -------------------- # 2. 自动化文件处理 (Principles: Functions, Variables) # -------------------- # 自动查找当前目录下所有 .c 文件 SRCFILES:=$(wildcard *.c) # 这是一行优雅的核心代码，我们来分解它： # 假设 SRCFILES 是 \u0026#34;xspi.c xspi_options.c\u0026#34; # 1. $(basename $(SRCFILES)) -\u0026gt; \u0026#34;xspi xspi_options\u0026#34; # 2. $(addsuffix .o, ...) -\u0026gt; \u0026#34;xspi.o xspi_options.o\u0026#34; # 3. $(addprefix $(RELEASEDIR), ...) -\u0026gt; \u0026#34;../../../lib/xspi.o ../../../lib/xspi_options.o\u0026#34; OBJECTS = $(addprefix $(RELEASEDIR), $(addsuffix .o, $(basename $(wildcard *.c)))) 这一行代码就自动计算出了所有需要生成的目标文件（.o 文件）以及它们应该存放的位置。\n1 2 3 4 5 6 # -------------------- # 3. 定义最终目标 (Principles: Rules) # -------------------- # 定义了一个叫 libs 的目标，它依赖于所有我们刚刚计算出的 .o 文件。 # 当你运行 `make` 或 `make libs` 时，make 会确保所有 $(OBJECTS) 都被生成。 libs: $(OBJECTS) 这是一个“聚合目标”，它本身没有指令，它的作用就是触发所有依赖项的构建。\n1 2 3 4 5 6 7 8 # -------------------- # 4. 定义核心编译规则 (Principles: Pattern Rules, Automatic Variables) # -------------------- # 这条模式规则是整个 Makefile 的“引擎”。 # 它告诉 make 如何从一个 .c 文件（在当前目录） # 生成一个 .o 文件（在 RELEASEDIR 目录）。 $(RELEASEDIR)%.o: %.c ${COMPILER} $(CC_FLAGS) $(ECC_FLAGS) $(INCLUDES) $(DEPENDENCY_FLAGS) $\u0026lt; -o $@ $(RELEASEDIR)%.o: %.c: 模式。例如，为了生成目标 ../../../lib/xspi.o，make 会自动寻找依赖 xspi.c。 $\u0026lt;: 自动替换为依赖，即 xspi.c。 $@: 自动替换为目标，即 ../../../lib/xspi.o。 $(COMPILER) 等都是外部传入的变量，提供了极大的灵活性。 1 2 3 4 5 6 7 8 9 10 11 12 # -------------------- # 5. 定义头文件安装规则 (Principles: Rules, Pattern Rules) # -------------------- # .PHONY: include \u0026lt;-- 告诉make，\u0026#34;include\u0026#34; 不是一个文件名，而是一个动作的名称。 .PHONY: include # \u0026#39;make include\u0026#39; 这个动作，依赖于所有头文件被拷贝到目标目录。 include: $(addprefix $(INCLUDEDIR),$(wildcard *.h)) # 这是拷贝头文件的模式规则： # 如何生成一个在 INCLUDEDIR 里的 .h 文件？从当前目录的同名 .h 文件拷贝。 $(INCLUDEDIR)%.h: %.h $(CP) $\u0026lt; $@ 第四部分：如何具体使用这个 Makefile 这个 Makefile 被设计成一个“组件”，由一个更上层的系统来调用和配置。\n配置变量: 你不会直接修改这个 Makefile。而是在调用 make 命令时，从命令行传入变量的值。 执行目标: 你告诉 make 你想要什么目标。 一个典型的使用场景会是这样：\n在一个终端里，cd 到这个 src 目录下，然后执行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 编译所有 .o 文件 make \\ COMPILER=\u0026#34;arm-none-eabi-gcc\u0026#34; \\ COMPILER_FLAGS=\u0026#34;-O2 -c\u0026#34; \\ DEPENDENCY_FLAGS=\u0026#34;-MMD -MP\u0026#34; \\ libs # 安装所有头文件到 include 目录 make \\ INCLUDEDIR=../../../include \\ include # 清理所有生成的文件 make \\ RELEASEDIR=../../../lib/ \\ clean COMPILER=\u0026quot;arm-none-eabi-gcc\u0026quot;: 为变量 COMPILER 赋值，指定了交叉编译器。 COMPILER_FLAGS=\u0026quot;-O2 -c\u0026quot;: 传入了编译选项（优化等级2，只编译不链接）。 libs: 告诉 make 我们想要的目标是 libs。make 就会自动找到 libs 规则，然后去构建它的所有依赖（即所有的 .o 文件）。 总结起来，这个 Makefile 的优雅之处在于：\n声明式: 你只描述了“什么依赖什么”以及“如何生成”，而不是一步步的命令。 自动化: 自动发现源文件、自动计算目标文件、自动应用编译规则。 可配置和可复用: 通过外部变量进行配置，使得这个 Makefile 本身可以被用在任何 C 语言库的编译中，无需修改一个字。 ","date":"2025-11-02T12:01:24+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E4%BB%A5vitis%E7%9A%84makefile%E4%B8%BA%E4%BE%8B%E5%AD%A6%E4%B9%A0/","title":"以vitis的makefile为例学习"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include \u0026#34;xil_io.h\u0026#34; #include \u0026#34;xparameters.h\u0026#34; #include \u0026#34;xparameters_ps.h\u0026#34; #include \u0026#34;xil_printf.h\u0026#34; #include \u0026#34;xgpio.h\u0026#34; #include \u0026#34;xgpiops.h\u0026#34; #include \u0026#34;xuartps.h\u0026#34; #include \u0026#34;xuartps_hw.h\u0026#34; void PL_SW_INIT(); void PS_GPIO_INIT(); void delay_1s(); void led_on_off(u32 on); void uart_init(); XGpio pl_sw; XGpioPs ps_gpio; XGpioPs_Config ps_gpio_config; XUartPs uart; XUartPs_Config uart_config; void main() { print(\u0026#34;hello world\\n\u0026#34;); PL_SW_INIT(); PS_GPIO_INIT(); u32 pin12,pin13,pin14,pin15,pin47; u32 sw_cur,sw_last=0; u32 pl_sw_state; XGpio_DiscreteSet(\u0026amp;pl_sw,2,0xff); while(1) { /* led_on_off(1); delay_1s(); led_on_off(0); delay_1s();*/ pl_sw_state=XGpio_DiscreteRead(\u0026amp;pl_sw,1); XGpio_DiscreteWrite(\u0026amp;pl_sw,2,pl_sw_state); pin12=XGpioPs_ReadPin(\u0026amp;ps_gpio, 12); pin13=XGpioPs_ReadPin(\u0026amp;ps_gpio, 13); pin14=XGpioPs_ReadPin(\u0026amp;ps_gpio, 14); pin15=XGpioPs_ReadPin(\u0026amp;ps_gpio, 15); pin47=XGpioPs_ReadPin(\u0026amp;ps_gpio, 47); XGpioPs_WritePin(\u0026amp;ps_gpio, 7, pin47); XGpioPs_WritePin(\u0026amp;ps_gpio, 8, pin12); XGpioPs_WritePin(\u0026amp;ps_gpio, 9, pin14); XGpioPs_WritePin(\u0026amp;ps_gpio, 10, pin15); XGpioPs_WritePin(\u0026amp;ps_gpio, 11, pin13); sw_cur=XGpio_DiscreteRead(\u0026amp;pl_sw, 1); /* if(sw_cur\u0026amp;0x1==0x1) { led_on_off(1); } else { led_on_off(0); }*/ if(sw_cur!=sw_last) { xil_printf(\u0026#34;pl key is %x\\n\u0026#34;,sw_cur); sw_last=sw_cur; } } } void PL_SW_INIT() { //初始化结构体 XGpio_Initialize(\u0026amp;pl_sw, XPAR_AXI_GPIO_1_BASEADDR); //设置通道1，8位为输入模式 XGpio_SetDataDirection(\u0026amp;pl_sw, 1,0xff);//1输入，0输出 XGpio_SetDataDirection(\u0026amp;pl_sw, 2,0); } void PS_GPIO_INIT() { XGpioPs_CfgInitialize(\u0026amp;ps_gpio, \u0026amp;ps_gpio_config,XPAR_XGPIOPS_0_BASEADDR); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 12, 0);//0输入，1输出 XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 13, 0); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 14, 0); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 15, 0); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 47, 0); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 7, 1); XGpioPs_SetOutputEnablePin(\u0026amp;ps_gpio,7,1); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 8, 1); XGpioPs_SetOutputEnablePin(\u0026amp;ps_gpio,8,1); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 9, 1); XGpioPs_SetOutputEnablePin(\u0026amp;ps_gpio,9,1); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 10, 1); XGpioPs_SetOutputEnablePin(\u0026amp;ps_gpio,10,1); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 11, 1); XGpioPs_SetOutputEnablePin(\u0026amp;ps_gpio,11,1); } void delay_1s() { for(int i=0;i\u0026lt;1000000;i++) for(int j=0;j\u0026lt;100;j++); } void led_on_off(u32 on) { XGpioPs_WritePin(\u0026amp;ps_gpio, 7, on); XGpioPs_WritePin(\u0026amp;ps_gpio, 8, on); XGpioPs_WritePin(\u0026amp;ps_gpio, 9, on); XGpioPs_WritePin(\u0026amp;ps_gpio, 10, on); XGpioPs_WritePin(\u0026amp;ps_gpio, 11, on); } void uart_init() { XUartPs_CfgInitialize(\u0026amp;uart,\u0026amp;uart_config,XPS_UART1_BASEADDR); XUartPs_SetBaudRate(\u0026amp;uart,115200); } ","date":"2025-11-01T15:51:42+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq-gpio/","title":"Zynq Gpio"},{"content":"vitis code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026#34;xparameters.h\u0026#34; #include \u0026#34;xspi.h\u0026#34; #include \u0026#34;xspi_i.h\u0026#34; #include \u0026#34;xspi_l.h\u0026#34; #include \u0026#34;xil_io.h\u0026#34; #include \u0026#34;sleep.h\u0026#34; XSpi spi_dac; u8 dac_send[2]; u8 dac_recv[2]={0}; // spi_dac:CPOL=1;CPHA=0 u32 dac_option=XSP_MASTER_OPTION|XSP_CLK_ACTIVE_LOW_OPTION|XSP_MANUAL_SSELECT_OPTION; //u32 dac_option=XSP_MASTER_OPTION|XSP_CLK_ACTIVE_LOW_OPTION; int main(void){ XSpi_Initialize(\u0026amp;spi_dac, XPAR_DAC_SPI_BASEADDR); XSpi_SetOptions(\u0026amp;spi_dac, dac_option); XSpi_Start(\u0026amp;spi_dac); while(1){ sleep(1); XSpi_SetSlaveSelect(\u0026amp;spi_dac,0x01); //XSpi_SetSlaveSelectReg(\u0026amp;spi_dac, 0x01); u16 dac_mode=(0x00); u16 dac_value=1000; u16 dac_data=dac_value|(dac_mode \u0026lt;\u0026lt;12); dac_send[0]=dac_data\u0026gt;\u0026gt;8; dac_send[1]=dac_data\u0026amp;0xff; XSpi_Transfer(\u0026amp;spi_dac, dac_send, dac_recv,2); XSpi_SetSlaveSelect(\u0026amp;spi_dac,0x00); //XSpi_SetSlaveSelectReg(\u0026amp;spi_dac, 0x00); sleep(1); XSpi_SetSlaveSelect(\u0026amp;spi_dac,0x01); //XSpi_SetSlaveSelectReg(\u0026amp;spi_dac, 0x01); dac_mode=(0x00); dac_value=0; dac_data=dac_value|(dac_mode \u0026lt;\u0026lt;12); dac_send[0]=dac_data\u0026gt;\u0026gt;8; dac_send[1]=dac_data\u0026amp;0xff; XSpi_Transfer(\u0026amp;spi_dac, dac_send, dac_recv,2); XSpi_SetSlaveSelect(\u0026amp;spi_dac,0x00); //XSpi_SetSlaveSelectReg(\u0026amp;spi_dac, 0x00); } } 总结 烦的第一大错误：忘记在vivado中设置ddr 胡言乱语 在学习zynq时，我一直试图通过第一性原理来学习，一开始我以为函数库已经相对底层，是对底层函数的封装。到了今天，我发现寄存器是更底层的。高屋建瓴的讲，一个嵌入式系统就是一个工作在while中的fsm，根据外部设备获得的信息修改对应的寄存器，然后传递信息。一方面，寄存器是信息的储存者，用来读写传输。另一方面，寄存器是整个系统的中转站，中断，初始化等等都有对应的寄存器，靠着这一套寄存器系统配合cpu这个大脑协调运转。一言以蔽之，写c语言就是在操纵寄存器\n","date":"2025-11-01T14:41:55+08:00","permalink":"https://demo.stack.jimmycai.com/post/spi-dac/","title":"Spi Dac"},{"content":"generate for generate for 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module generate_for1( input logic clk, input logic in, output logic [3:0]out ); genvar i; generate for(i=1;i\u0026lt;=3;i=i+1) begin always_ff@(posedge clk) begin out[0]\u0026lt;=in; out[i]\u0026lt;=out[i-1]; end end endgenerate endmodule generate for2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module generate_for1( input logic clk, input logic in, output logic [3:0]out ); genvar i; generate for(i=0;i\u0026lt;=3;i=i+1) begin always_ff@(posedge clk) begin //out[0]\u0026lt;=in; out[i]\u0026lt;=out[i-1]; end end endgenerate endmodule 草率了，忘记数组不能负索引了，但是负索引竟然可以综合\ngenerate for3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module generate_for1( input logic clk, input logic in, output logic [3:0]out ); genvar i; generate for(i=1;i\u0026lt;=3;i=i+1) begin always_ff@(posedge clk) begin //out[0]\u0026lt;=in; out[i]\u0026lt;=out[i-1]; end always_ff@(posedge clk) begin out[0]\u0026lt;=in; end end endgenerate endmodule generate for 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 module generate_for1( input logic clk, input logic in, output logic [3:0]out ); genvar i; generate for(i=1;i\u0026lt;=3;i=i+1) begin always_ff@(posedge clk) begin //out[0]\u0026lt;=in; out[i]\u0026lt;=out[i-1]; end end endgenerate always_ff@(posedge clk) begin out[0]\u0026lt;=in; end endmodule for for1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module for1( input logic clk, input logic in, output logic [3:0]out ); integer i; always_ff@(posedge clk) begin out[0]\u0026lt;=in; for(i=1;i\u0026lt;=3;i=i+1) begin out[i]\u0026lt;=out[i-1]; end end endmodule for2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module for1( input logic clk, input logic in, output logic [3:0]out ); integer i; always_ff@(posedge clk) begin out[0]\u0026lt;=in; for(i=0;i\u0026lt;=3;i=i+1) begin out[i]\u0026lt;=out[i-1]; end end endmodule 草率了，忘记数组不能负索引了，但是负索引竟然可以综合\n","date":"2025-10-29T15:50:08+08:00","permalink":"https://demo.stack.jimmycai.com/post/generate-for/","title":"Generate For vs. For"},{"content":"下面我为你总结一套工业级、学术界都广泛使用的Matplotlib作图“套路”，以及与之配合的NumPy常用函数。这套流程能覆盖你80%以上的作图需求，并让你的图表清晰、美观、信息量丰富。\n核心理念：“面向对象”的作图范式 忘掉零散的plt.plot()、plt.title()。从现在开始，拥抱“Figure与Axes”的面向对象范式。这是最重要的一步。\n基本模板（所有作图的起点）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import matplotlib.pyplot as plt import numpy as np # --- 1. 创建画布(Figure)和子图(Axes) --- # fig是整个画布，ax是具体的绘图区域 # nrows=1, ncols=1 表示创建一个1x1的网格，即只有一个子图 fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(10, 6)) # figsize控制画布大小 # --- 2. 在Axes上绘图 --- # 所有绘图操作都通过ax对象完成，而不是plt # x_data, y_data = ... (你的数据) # ax.plot(x_data, y_data, label=\u0026#39;My Data\u0026#39;) # --- 3. 精细化定制Axes --- ax.set_title(\u0026#34;This is the Title\u0026#34;, fontsize=16) ax.set_xlabel(\u0026#34;X-axis Label\u0026#34;, fontsize=12) ax.set_ylabel(\u0026#34;Y-axis Label\u0026#34;, fontsize=12) ax.grid(True, linestyle=\u0026#39;--\u0026#39;, alpha=0.6) # 添加网格线 ax.legend(fontsize=10) # 显示图例 # --- 4. 调整布局并显示 --- plt.tight_layout() # 自动调整子图参数，使之填充整个图像区域 plt.show() 记住这个模板，你就掌握了套路的精髓。\nNumPy \u0026amp; Matplotlib 常用函数与作图套路 下面我将作图需求分为几大类，每一类都提供一个“套路”和相关的常用函数。\n套路一：单线/多线对比图 (最常用) 场景：对比滤波前后的信号、不同参数下的模型性能、理论值与实际值。\n流程：\n用np.linspace或np.arange创建统一的X轴数据。 在同一个ax对象上多次调用plot()。 通过label参数区分不同曲线，最后用ax.legend()显示图例。 代码范例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # --- 数据准备 (NumPy) --- fs = 1000 t = np.linspace(0, 1, fs, endpoint=False) # 0到1秒的时间轴 signal_clean = np.sin(2 * np.pi * 5 * t) noise = 0.5 * np.random.randn(len(t)) signal_noisy = signal_clean + noise # --- Matplotlib 套路 --- fig, ax = plt.subplots(figsize=(12, 6)) ax.plot(t, signal_noisy, label=\u0026#39;Noisy Signal\u0026#39;, color=\u0026#39;blue\u0026#39;, alpha=0.5) ax.plot(t, signal_clean, label=\u0026#39;Clean Signal\u0026#39;, color=\u0026#39;red\u0026#39;, linewidth=2, linestyle=\u0026#39;-\u0026#39;) # 精细化控制 ax.set_title(\u0026#34;Comparison of Signals\u0026#34;) ax.set_xlabel(\u0026#34;Time [s]\u0026#34;) ax.set_ylabel(\u0026#34;Amplitude\u0026#34;) ax.set_xlim(0, 0.5) # 常用：放大X轴的某个区域 ax.grid(True) ax.legend() plt.tight_layout() plt.show() 常用NumPy函数：\nnp.linspace(start, stop, num): 创建等差数列，常用于时间轴或平滑的X轴。 np.arange(start, stop, step): 按步长创建数组，常用于离散序列。 np.sin, np.cos, np.exp: 生成各种数学函数波形。 np.random.randn(size): 生成标准正态分布（高斯）噪声。 套路二：多子图布局 (信息维度扩展) 场景：同时展示时域和频域、输入和输出、多个实验结果。\n流程：\n在plt.subplots()中指定nrows和ncols。 subplots会返回一个**axes数组**。通过索引（如ax[0], ax[1]或ax[0, 1]）来选择要在哪个子图上绘图。 可以设置sharex=True或sharey=True来共享坐标轴，使对比更直观。 代码范例 (时域 vs 频域)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from scipy.fft import fft, fftfreq # --- 数据准备 (NumPy \u0026amp; SciPy) --- fs = 1000 t = np.linspace(0, 1, fs, endpoint=False) signal = np.sin(2 * np.pi * 50 * t) + 0.5 * np.sin(2 * np.pi * 120 * t) # FFT计算 N = len(signal) yf = fft(signal) xf = fftfreq(N, 1 / fs)[:N//2] # 获取频率轴 # --- Matplotlib 套路 (1行2列) --- fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(10, 8), sharex=False) # 在第一个子图 (axes[0]) 上画时域图 axes[0].plot(t, signal) axes[0].set_title(\u0026#34;Time Domain\u0026#34;) axes[0].set_xlabel(\u0026#34;Time [s]\u0026#34;) axes[0].set_ylabel(\u0026#34;Amplitude\u0026#34;) axes[0].grid(True) axes[0].set_xlim(0, 0.2) # 在第二个子图 (axes[1]) 上画频域图 axes[1].plot(xf, 2.0/N * np.abs(yf[0:N//2])) axes[1].set_title(\u0026#34;Frequency Domain (FFT)\u0026#34;) axes[1].set_xlabel(\u0026#34;Frequency [Hz]\u0026#34;) axes[1].set_ylabel(\u0026#34;Amplitude\u0026#34;) axes[1].grid(True) axes[1].set_xlim(0, 200) plt.tight_layout() plt.show() 套路三：数据分布与统计图 (直方图/散点图) 场景：分析噪声分布、变量之间的相关性。\n流程：\n直方图使用ax.hist()，可以直观地看到数据分布的形状。 散点图使用ax.scatter()，用于观察两个变量之间的关系。 代码范例 (直方图)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # --- 数据准备 (NumPy) --- # 生成均值为5，标准差为2的高斯分布数据 data = 5 + 2 * np.random.randn(1000) # --- Matplotlib 套路 --- fig, ax = plt.subplots(figsize=(8, 5)) # bins控制柱子的数量，density=True表示归一化为概率密度 ax.hist(data, bins=30, density=True, alpha=0.7, label=\u0026#39;Histogram\u0026#39;) # 常用：在直方图上叠加理论分布曲线 from scipy.stats import norm xmin, xmax = plt.xlim() x = np.linspace(xmin, xmax, 100) p = norm.pdf(x, 5, 2) # 理论概率密度函数 ax.plot(x, p, \u0026#39;k\u0026#39;, linewidth=2, label=\u0026#39;Theoretical PDF\u0026#39;) ax.set_title(\u0026#34;Data Distribution\u0026#34;) ax.set_xlabel(\u0026#34;Value\u0026#34;) ax.set_ylabel(\u0026#34;Density\u0026#34;) ax.legend() ax.grid(True) plt.tight_layout() plt.show() 常用NumPy函数：\nnp.mean(data), np.std(data): 计算均值和标准差。 np.random.rand(size): [0, 1)均匀分布。 np.corrcoef(x, y): 计算相关系数矩阵。 套路四：添加辅助线与注释 (让图表“说话”) 场景：标记阈值、截止频率、特定事件点、理论极限。\n流程：\nax.axvline(): 画垂直线。 ax.axhline(): 画水平线。 ax.axvspan(): 垂直区域着色。 ax.text() 或 ax.annotate(): 添加文字注释。 代码范例 (频率响应图标注)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 假设 freq_hz, magnitude_db 是频率响应数据 # ... fig, ax = plt.subplots(figsize=(10, 6)) ax.plot(freq_hz, magnitude_db) ax.set_title(\u0026#34;Filter Frequency Response\u0026#34;) ax.set_xlabel(\u0026#34;Frequency [Hz]\u0026#34;) ax.set_ylabel(\u0026#34;Magnitude [dB]\u0026#34;) # --- 添加辅助线 --- cutoff_freq = 50 # 标记-3dB线（半功率点） ax.axhline(-3, color=\u0026#39;red\u0026#39;, linestyle=\u0026#39;--\u0026#39;, label=\u0026#39;-3 dB Cutoff\u0026#39;) # 标记名义截止频率 ax.axvline(cutoff_freq, color=\u0026#39;green\u0026#39;, linestyle=\u0026#39;:\u0026#39;, label=f\u0026#39;Nominal Cutoff = {cutoff_freq} Hz\u0026#39;) # 标记通带区域 ax.axvspan(0, 40, color=\u0026#39;gray\u0026#39;, alpha=0.2, label=\u0026#39;Passband Region\u0026#39;) ax.set_ylim(-60, 5) ax.grid(True) ax.legend() plt.tight_layout() plt.show() 总结：你的“作图武器库” 需求分类 核心Matplotlib函数 常用NumPy函数 套路精髓 基础框架 fig, ax = plt.subplots() np.array 面向对象，分离画布与绘图区 曲线对比 ax.plot(), ax.legend() np.linspace, np.arange 同一ax多次plot，用label区分 多维展示 plt.subplots(nrows, ncols) fft (from scipy) 索引axes数组，用sharex/y联动 数据分布 ax.hist(), ax.scatter() np.random, np.mean, np.std 选择合适的图表类型展示数据内在结构 信息高亮 ax.axvline, ax.axhline, ax.axvspan - 用辅助线和注释引导读者关注重点 全局美化 plt.tight_layout() - 自动调整布局，防止标签重叠 将这套流程和范例代码保存在你的笔记中，每次作图时，先思考你的“故事”需要哪种套路，然后填充数据和细节。很快，你就能随心所欲地创作出专业且富有洞察力的图表了。\n","date":"2025-10-27T16:23:21+08:00","permalink":"https://demo.stack.jimmycai.com/post/matplotlib_numpy/","title":"Matplotlib_numpy(created by gemini)"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 //通过串口输入数字点亮对应的小灯 #include \u0026#34;xparameters.h\u0026#34; #include \u0026#34;xuartlite.h\u0026#34; #include \u0026#34;xuartlite_l.h\u0026#34; #include \u0026#34;xil_io.h\u0026#34; #include \u0026#34;xil_printf.h\u0026#34; #include \u0026lt;xil_types.h\u0026gt; #include \u0026#34;xgpio.h\u0026#34; XUartLite puart_lite; XGpio pl_sw; void PL_SW_INIT(); u8 status; u8 recv_package[8]; u8 send_package[8]={\u0026#39;i\u0026#39;,\u0026#39;n\u0026#39;}; u8 count; int main() { PL_SW_INIT(); XUartLite_Initialize(\u0026amp;puart_lite,XPAR_XUARTLITE_0_BASEADDR); XGpio_DiscreteSet(\u0026amp;pl_sw,2,0); XUartLite_Send(\u0026amp;puart_lite,send_package,2); while(1) { count=0; XUartLite_Send(\u0026amp;puart_lite,send_package,2); //XUartLite_Recv(\u0026amp;puart_lite,recv_package,2); //while (count\u0026lt;2) //{ // if(count==0){XUartLite_Recv(\u0026amp;puart_lite,recv_package,2);}} // if(count==1){XUartLite_Recv(\u0026amp;puart_lite,recv_package,1);} // XUartLite_Send(\u0026amp;puart_lite,recv_package,2); // 等待并接收第一个字节 recv_package[0] = XUartLite_RecvByte(XPAR_XUARTLITE_0_BASEADDR); // 等待并接收第二个字节 recv_package[1] = XUartLite_RecvByte(XPAR_XUARTLITE_0_BASEADDR); //XUartLite_Send(\u0026amp;puart_lite,recv_package,2); u32 led_control=10*(recv_package[0]-\u0026#39;0\u0026#39;)+(recv_package[1]-\u0026#39;0\u0026#39;); //xil_printf(\u0026#34;%u\u0026#34;,led_control); XGpio_DiscreteWrite(\u0026amp;pl_sw,2,0); XGpio_DiscreteWrite(\u0026amp;pl_sw,2,led_control); //XUartLite_Send(\u0026amp;puart_lite,recv_package,2); //XUartLite_Send(\u0026amp;puart_lite,send_package,2); } } void PL_SW_INIT() { //初始化结构体 XGpio_Initialize(\u0026amp;pl_sw, XPAR_AXI_GPIO_1_BASEADDR); //设置通道1，8位为输入模式 XGpio_SetDataDirection(\u0026amp;pl_sw, 1,0xff);//1输入，0输出 XGpio_SetDataDirection(\u0026amp;pl_sw, 2,0); } ","date":"2025-10-25T14:33:53+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq-xuartlite/","title":"Zynq Xuartlite"},{"content":"zynq有着完备以及强大的文档辅助学习，本文将记录阅读过的zynq文档，简单评价或是剖析精彩的章节\nUG585-Zynq 7000 SoC Technical Reference Manual UG585\n当之无愧最重要的文档\n","date":"2025-10-24T23:56:42+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93/","title":"Zynq文档总结"},{"content":"Vivado 中的约束（Constraints）主要通过 Xilinx Design Constraints (XDC) 文件来定义，其语法基于 Tcl（Tool Command Language），并扩展了用于时序、管脚分配、物理约束等的专用命令。以下是 Vivado 约束的基本语法和常用命令分类：\n1. 管脚分配（Pin Assignment） 指定顶层模块端口对应的 FPGA 引脚：\n1 2 set_property PACKAGE_PIN \u0026lt;pin_name\u0026gt; [get_ports \u0026lt;port_name\u0026gt;] set_property IOSTANDARD LVCMOS33 [get_ports \u0026lt;port_name\u0026gt;] 示例：\n1 2 set_property PACKAGE_PIN D18 [get_ports clk] set_property IOSTANDARD LVCMOS33 [get_ports clk] 2. 时钟约束（Clock Constraints） 定义主时钟、生成时钟或虚拟时钟。\n主时钟（Primary Clock）： 1 create_clock -name \u0026lt;clk_name\u0026gt; -period \u0026lt;period_ns\u0026gt; [get_ports \u0026lt;port_name\u0026gt;] 示例（100 MHz 时钟）：\n1 create_clock -name sys_clk -period 10.000 [get_ports clk] 生成时钟（Generated Clock）： 用于 PLL/MMCM 输出或分频/倍频时钟：\n1 create_generated_clock -name \u0026lt;gen_clk_name\u0026gt; -source [get_pins \u0026lt;source_pin\u0026gt;] -divide_by \u0026lt;N\u0026gt; [get_pins \u0026lt;output_pin\u0026gt;] 示例（2 分频）：\n1 create_generated_clock -name clk_div2 -source [get_pins clk] -divide_by 2 [get_pins clk_div2_reg/Q] 3. 输入/输出延迟约束（I/O Delay） 用于指定外部器件与 FPGA 之间的时序关系。\n输入延迟： 1 set_input_delay -clock \u0026lt;clk_name\u0026gt; \u0026lt;delay_ns\u0026gt; [get_ports \u0026lt;input_port\u0026gt;] 输出延迟： 1 set_output_delay -clock \u0026lt;clk_name\u0026gt; \u0026lt;delay_ns\u0026gt; [get_ports \u0026lt;output_port\u0026gt;] 示例：\n1 2 set_input_delay -clock sys_clk 2.0 [get_ports data_in] set_output_delay -clock sys_clk 1.5 [get_ports data_out] 4. 时序例外（Timing Exceptions） 用于覆盖默认时序分析，如多周期路径、伪路径等。\n伪路径（False Path）： 1 set_false_path -from [get_pins \u0026lt;start_point\u0026gt;] -to [get_pins \u0026lt;end_point\u0026gt;] 或针对端口：\n1 set_false_path -from [get_ports async_in] 多周期路径（Multicycle Path）： 1 2 set_multicycle_path \u0026lt;num_cycles\u0026gt; -setup -from [get_clocks clk1] -to [get_clocks clk2] set_multicycle_path \u0026lt;num_cycles\u0026gt; -hold -from [get_clocks clk1] -to [get_clocks clk2] 5. 物理约束（Physical Constraints） 如区域约束（Pblock）、布局锁定等（较少在 XDC 中直接写，但支持）：\n1 set_property LOC SLICE_X10Y20 [get_cells my_reg] 注意事项： 顺序敏感：XDC 文件按顺序执行，后面的约束可能覆盖前面的。 对象获取：常用 [get_ports ...]、[get_pins ...]、[get_cells ...]、[get_clocks ...] 来定位设计对象。 单位：时间单位默认为纳秒（ns），可省略。 注释：使用 # 开头。 示例完整 XDC 片段： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Clock create_clock -name clk -period 10.000 [get_ports clk] # Pin assignment set_property PACKAGE_PIN E3 [get_ports clk] set_property IOSTANDARD LVCMOS33 [get_ports clk] set_property PACKAGE_PIN D9 [get_ports reset_n] set_property IOSTANDARD LVCMOS33 [get_ports reset_n] # Input delay set_input_delay -clock clk 2.0 [get_ports data_in] # False path for async reset set_false_path -from [get_ports reset_n] 如果你正在编写状态机并关注复位信号（如 rst），通常建议：\n若为同步复位，无需特殊约束； 若为异步复位，需用 set_false_path 或 set_input_delay 明确其时序不参与分析，或使用 create_clock + set_false_path 组合处理。 需要更具体的约束示例（比如针对你的状态机复位）可以告诉我。\n","date":"2025-10-24T20:19:58+08:00","permalink":"https://demo.stack.jimmycai.com/post/vivado-constraint/","title":"Vivado Constraint(created by gemini)"},{"content":"zynq ps端有一圈信号端口，本文将逐一拆解\n","date":"2025-10-24T19:59:11+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq-ps-port/","title":"Zynq Ps Port"},{"content":"好的，这是一个关于 fzf、fd 和 rg 这三个现代命令行神器（俗称“命令行三剑客”）的用法梗概。它们各自独立时已经非常强大，但组合使用更能发挥出惊人的效率。\n核心思想 fd: 替代 find，用来 找文件。 rg (ripgrep): 替代 grep，用来 找文件内容。 fzf (fuzzy finder): 模糊搜索器，用来 从列表中交互式地选择。 它们的共同优点是：快、智能、用户友好。\n1. fzf - 命令行模糊搜索器 一句话总结：一个交互式的过滤器，可以从任何文本输入中快速筛选并选择一项或多项。\nfzf 是这三者中的“粘合剂”，能与各种命令无缝配合。\n核心功能 模糊匹配：你不需要输入完整的词，只需输入几个关键字母，它就能找到匹配项。 交互式界面：实时反馈，上下键选择，回车确认。 高度可定制：可以自定义外观、快捷键和预览窗口。 与 Shell 深度集成：可以极大地增强 Ctrl+R（历史命令搜索）、Ctrl+T（文件路径补全）等功能。 常用场景与示例 基础用法：查找当前目录下的文件 直接运行 fzf，它会列出所有文件和目录，你可以模糊搜索并按回车，它会将你选择的文件名输出到标准输出。\n1 fzf 增强命令历史搜索 (Ctrl+R) 这是 fzf 最受欢迎的功能。安装后，按 Ctrl+R 会调出 fzf 的交互式历史记录搜索界面，比默认的好用一万倍。\n查找文件并用 Vim 打开 结合命令替换 $(...) 或反引号 `...`。\n1 2 3 4 5 # 查找文件，然后用 vim 打开选中的那个 vim $(fzf) # 查找并选择多个文件打开 vim $(fzf --multi) 作为管道中的过滤器 fzf 可以处理任何通过管道 (|) 传给它的文本。\n1 2 3 4 5 # 从 ps 结果中选择一个进程并结束它 ps -ef | fzf | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 # 模糊搜索并切换 git 分支 git branch | fzf | xargs git checkout 2. fd - 一个更简单、更快速的 find 一句话总结：一个为人类设计的、默认配置极佳的找文件工具。\nfd 在功能上与 find 类似，但语法更简洁，速度更快。\n核心功能 语法简单：fd \u0026lt;模式\u0026gt; 即可，不像 find 需要复杂的 -name 等参数。 智能忽略：默认忽略 .gitignore 中定义的文件、隐藏文件和目录。这在项目开发中非常有用。 速度极快：利用并行处理，搜索速度通常比 find 快得多。 彩色输出：结果按文件类型着色，一目了然。 常用场景与示例 基础用法：查找包含 \u0026ldquo;report\u0026rdquo; 的文件\n1 2 3 4 # 在当前目录及子目录中查找 fd report # 相当于 find . -iname \u0026#34;*report*\u0026#34; 按扩展名查找\n1 2 3 4 5 # 查找所有的 markdown 文件 fd -e md # 查找所有的 jpg 或 png 文件 fd -e jpg -e png 按文件类型查找\n1 2 3 4 5 6 7 8 # 只查找目录 fd -t d # 只查找文件 fd -t f # 只查找符号链接 fd -t l 执行命令 -x 或 --exec 参数可以对每个搜索结果执行一个命令。{} 是占位符，代表找到的文件路径。\n1 2 3 4 5 6 # 查找所有 zip 文件并解压 fd -e zip -x unzip {} # 批量修改文件名（将 .jpeg 改为 .jpg） fd -e jpeg -x mv {} {.}.jpg # {.}` 代表不含扩展名的路径 覆盖智能忽略 如果你想搜索隐藏文件或被 .gitignore 忽略的文件：\n1 2 3 # --hidden: 搜索隐藏文件 # --no-ignore: 不使用 .gitignore 规则 fd --hidden --no-ignore \u0026#39;^\\.bash\u0026#39; 3. rg (ripgrep) - 一个超快的 grep 一句话总结：一个专注于速度和易用性的代码内容搜索工具。\nrg 同样默认尊重 .gitignore，并且会自动跳过二进制文件，是程序员日常搜索代码的利器。\n核心功能 速度极快：通常是 grep 或 ag (The Silver Searcher) 中最快的。 智能忽略：和 fd 一样，默认忽略 .gitignore 和隐藏文件。 优秀输出：彩色高亮、显示行号、自动分组。 跨平台：在 Windows, macOS, Linux 上表现同样出色。 常用场景与示例 基础用法：在当前目录搜索字符串\n1 2 # 搜索包含 \u0026#34;main\u0026#34; 的所有行 rg main 不区分大小写搜索\n1 rg -i \u0026#34;error\u0026#34; (rg 默认使用智能大小写：如果你的搜索词全小写，它就不区分大小写；如果包含大写，它就精确匹配。)\n仅列出包含匹配项的文件名\n1 rg -l \u0026#34;TODO\u0026#34; 在特定类型的文件中搜索\n1 2 3 4 5 # 只在 python 文件中搜索 \u0026#34;import\u0026#34; rg \u0026#34;import\u0026#34; -t py # 不在 javascript 文件中搜索 \u0026#34;console.log\u0026#34; rg \u0026#34;console.log\u0026#34; -g \u0026#39;!*.js\u0026#39; 显示上下文\n1 2 # 显示匹配行的前后各 2 行 rg -C 2 \u0026#34;important_function\u0026#34; 统计匹配数量\n1 rg --count \u0026#34;User\u0026#34; 三者合璧：黄金组合 这三个工具的真正威力在于通过管道 (|) 结合，形成强大的工作流。\n场景1：查找一个项目中的配置文件，然后交互式选择并打开。\nfd 负责快速找出所有 .conf 文件。 fzf 负责提供交互界面让你选择。 vim 负责打开你选择的文件。 1 2 3 4 5 # 1. fd 找到所有以 .conf 结尾的文件 # 2. | 将结果传给 fzf # 3. fzf 让你模糊搜索并选择一个 # 4. vim 打开最终选定的文件 vim $(fd -e conf | fzf) 场景2：在代码库中搜索一个函数，然后交互式地预览并跳转到该行。\n这是最强大的组合之一，需要 fzf 的预览功能。\nrg 负责搜索函数名，并输出 文件名:行号:内容。 fzf 负责交互选择，并使用 --preview 功能实时显示文件上下文。 vim/vscode 等编辑器负责打开文件并跳转到指定行。 1 2 3 4 5 # rg 搜索 \u0026#34;function_name\u0026#34;，--vimgrep 格式化输出 # fzf 读取结果，并使用 bat (一个带高亮的 cat) 来预览文件 # {1} 是文件名, {2} 是行号 rg --vimgrep \u0026#34;function_name\u0026#34; | \\ fzf --preview \u0026#39;bat --color=always --highlight-line {2} {1}\u0026#39; 当你选中一项后，可以进一步处理 fzf 的输出，提取文件名和行号，然后用编辑器打开。例如：\n1 2 3 4 5 # 选中后，提取文件名和行号，用 vim 打开并跳转 ITEM=$(rg --vimgrep \u0026#34;my_api_key\u0026#34; | fzf) FILE=$(echo $ITEM | cut -d: -f1) LINE=$(echo $ITEM | cut -d: -f2) [ -n \u0026#34;$FILE\u0026#34; ] \u0026amp;\u0026amp; vim \u0026#34;$FILE\u0026#34; +$LINE 总结表格 工具 核心功能 经典替代品 关键优势 fzf 交互式选择 (无直接替代) 模糊搜索、万物皆可过滤、高度集成 fd 查找文件/目录 find 语法简单、速度快、智能忽略 rg 搜索文件内容 grep, ack, ag 速度极快、智能忽略、输出友好 ","date":"2025-10-24T09:38:06+08:00","permalink":"https://demo.stack.jimmycai.com/post/fzf-fd-rg/","title":"Fzf Fd Rg"},{"content":"代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 `timescale 1 ns / 1 ps module myip_slave_lite_v1_0_S00_AXI # ( // Users to add parameters here // User parameters ends // Do not modify the parameters beyond this line // Width of S_AXI data bus parameter integer C_S_AXI_DATA_WIDTH\t= 32, // Width of S_AXI address bus parameter integer C_S_AXI_ADDR_WIDTH\t= 4 ) ( // Users to add ports here // User ports ends // Do not modify the ports beyond this line // Global Clock Signal input wire S_AXI_ACLK, // Global Reset Signal. This Signal is Active LOW input wire S_AXI_ARESETN, // Write address (issued by master, acceped by Slave) input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR, // Write channel Protection type. This signal indicates the // privilege and security level of the transaction, and whether // the transaction is a data access or an instruction access. input wire [2 : 0] S_AXI_AWPROT, // Write address valid. This signal indicates that the master signaling // valid write address and control information. input wire S_AXI_AWVALID, // Write address ready. This signal indicates that the slave is ready // to accept an address and associated control signals. output wire S_AXI_AWREADY, // Write data (issued by master, acceped by Slave) input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA, // Write strobes. This signal indicates which byte lanes hold // valid data. There is one write strobe bit for each eight // bits of the write data bus. input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB, // Write valid. This signal indicates that valid write // data and strobes are available. input wire S_AXI_WVALID, // Write ready. This signal indicates that the slave // can accept the write data. output wire S_AXI_WREADY, // Write response. This signal indicates the status // of the write transaction. output wire [1 : 0] S_AXI_BRESP, // Write response valid. This signal indicates that the channel // is signaling a valid write response. output wire S_AXI_BVALID, // Response ready. This signal indicates that the master // can accept a write response. input wire S_AXI_BREADY, // Read address (issued by master, acceped by Slave) input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR, // Protection type. This signal indicates the privilege // and security level of the transaction, and whether the // transaction is a data access or an instruction access. input wire [2 : 0] S_AXI_ARPROT, // Read address valid. This signal indicates that the channel // is signaling valid read address and control information. input wire S_AXI_ARVALID, // Read address ready. This signal indicates that the slave is // ready to accept an address and associated control signals. output wire S_AXI_ARREADY, // Read data (issued by slave) output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA, // Read response. This signal indicates the status of the // read transfer. output wire [1 : 0] S_AXI_RRESP, // Read valid. This signal indicates that the channel is // signaling the required read data. output wire S_AXI_RVALID, // Read ready. This signal indicates that the master can // accept the read data and response information. input wire S_AXI_RREADY ); // AXI4LITE signals reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_awaddr; reg axi_awready; reg axi_wready; reg [1 : 0] axi_bresp; reg axi_bvalid; reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_araddr; reg axi_arready; reg [1 : 0] axi_rresp; reg axi_rvalid; // Example-specific design signals // local parameter for addressing 32 bit / 64 bit C_S_AXI_DATA_WIDTH // ADDR_LSB is used for addressing 32/64 bit registers/memories // ADDR_LSB = 2 for 32 bits (n downto 2) // ADDR_LSB = 3 for 64 bits (n downto 3) localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1; localparam integer OPT_MEM_ADDR_BITS = 1; //---------------------------------------------- //-- Signals for user logic register space example //------------------------------------------------ //-- Number of Slave Registers 4 reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg0; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg1; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg2; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg3; integer\tbyte_index; // I/O Connections assignments assign S_AXI_AWREADY\t= axi_awready; assign S_AXI_WREADY\t= axi_wready; assign S_AXI_BRESP\t= axi_bresp; assign S_AXI_BVALID\t= axi_bvalid; assign S_AXI_ARREADY\t= axi_arready; assign S_AXI_RRESP\t= axi_rresp; assign S_AXI_RVALID\t= axi_rvalid; //state machine varibles reg [1:0] state_write; reg [1:0] state_read; //State machine local parameters localparam Idle = 2\u0026#39;b00,Raddr = 2\u0026#39;b10,Rdata = 2\u0026#39;b11 ,Waddr = 2\u0026#39;b10,Wdata = 2\u0026#39;b11; // Implement Write state machine // Outstanding write transactions are not supported by the slave i.e., master should assert bready to receive response on or before it starts sending the new transaction always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1\u0026#39;b0) begin axi_awready \u0026lt;= 0; axi_wready \u0026lt;= 0; axi_bvalid \u0026lt;= 0; axi_bresp \u0026lt;= 0; axi_awaddr \u0026lt;= 0; state_write \u0026lt;= Idle; end else begin case(state_write) Idle: begin if(S_AXI_ARESETN == 1\u0026#39;b1) begin axi_awready \u0026lt;= 1\u0026#39;b1; axi_wready \u0026lt;= 1\u0026#39;b1; state_write \u0026lt;= Waddr; end else state_write \u0026lt;= state_write; end Waddr: //At this state, slave is ready to receive address along with corresponding control signals and first data packet. Response valid is also handled at this state begin if (S_AXI_AWVALID \u0026amp;\u0026amp; S_AXI_AWREADY) begin axi_awaddr \u0026lt;= S_AXI_AWADDR; if(S_AXI_WVALID) begin axi_awready \u0026lt;= 1\u0026#39;b1; state_write \u0026lt;= Waddr; axi_bvalid \u0026lt;= 1\u0026#39;b1; end else begin axi_awready \u0026lt;= 1\u0026#39;b0; state_write \u0026lt;= Wdata; if (S_AXI_BREADY \u0026amp;\u0026amp; axi_bvalid) axi_bvalid \u0026lt;= 1\u0026#39;b0; end end else begin state_write \u0026lt;= state_write; if (S_AXI_BREADY \u0026amp;\u0026amp; axi_bvalid) axi_bvalid \u0026lt;= 1\u0026#39;b0; end end Wdata: //At this state, slave is ready to receive the data packets until the number of transfers is equal to burst length begin if (S_AXI_WVALID) begin state_write \u0026lt;= Waddr; axi_bvalid \u0026lt;= 1\u0026#39;b1; axi_awready \u0026lt;= 1\u0026#39;b1; end else begin state_write \u0026lt;= state_write; if (S_AXI_BREADY \u0026amp;\u0026amp; axi_bvalid) axi_bvalid \u0026lt;= 1\u0026#39;b0; end end endcase end end // Implement memory mapped register select and write logic generation // The write data is accepted and written to memory mapped registers when // axi_awready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted. Write strobes are used to // select byte enables of slave registers while writing. // These registers are cleared when reset (active low) is applied. // Slave register write enable is asserted when valid address and data are available // and the slave is ready to accept the write address and write data. always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1\u0026#39;b0 ) begin slv_reg0 \u0026lt;= 0; slv_reg1 \u0026lt;= 0; slv_reg2 \u0026lt;= 0; slv_reg3 \u0026lt;= 0; end else begin if (S_AXI_WVALID) begin case ( (S_AXI_AWVALID) ? S_AXI_AWADDR[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] : axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] ) 2\u0026#39;h0: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 0 slv_reg0[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end 2\u0026#39;h1: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 1 slv_reg1[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end 2\u0026#39;h2: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 2 slv_reg2[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end 2\u0026#39;h3: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 3 slv_reg3[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end default : begin slv_reg0 \u0026lt;= slv_reg0; slv_reg1 \u0026lt;= slv_reg1; slv_reg2 \u0026lt;= slv_reg2; slv_reg3 \u0026lt;= slv_reg3; end endcase end end end // Implement read state machine always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1\u0026#39;b0) begin //asserting initial values to all 0\u0026#39;s during reset axi_arready \u0026lt;= 1\u0026#39;b0; axi_rvalid \u0026lt;= 1\u0026#39;b0; axi_rresp \u0026lt;= 1\u0026#39;b0; state_read \u0026lt;= Idle; end else begin case(state_read) Idle: //Initial state inidicating reset is done and ready to receive read/write transactions begin if (S_AXI_ARESETN == 1\u0026#39;b1) begin state_read \u0026lt;= Raddr; axi_arready \u0026lt;= 1\u0026#39;b1; end else state_read \u0026lt;= state_read; end Raddr: //At this state, slave is ready to receive address along with corresponding control signals begin if (S_AXI_ARVALID \u0026amp;\u0026amp; S_AXI_ARREADY) begin state_read \u0026lt;= Rdata; axi_araddr \u0026lt;= S_AXI_ARADDR; axi_rvalid \u0026lt;= 1\u0026#39;b1; axi_arready \u0026lt;= 1\u0026#39;b0; end else state_read \u0026lt;= state_read; end Rdata: //At this state, slave is ready to send the data packets until the number of transfers is equal to burst length begin if (S_AXI_RVALID \u0026amp;\u0026amp; S_AXI_RREADY) begin axi_rvalid \u0026lt;= 1\u0026#39;b0; axi_arready \u0026lt;= 1\u0026#39;b1; state_read \u0026lt;= Raddr; end else state_read \u0026lt;= state_read; end endcase end end // Implement memory mapped register select and read logic generation assign S_AXI_RDATA = (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2\u0026#39;h0) ? slv_reg0 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2\u0026#39;h1) ? slv_reg1 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2\u0026#39;h2) ? slv_reg2 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2\u0026#39;h3) ? slv_reg3 : 0; // Add user logic here // User logic ends endmodule ","date":"2025-10-24T09:13:35+08:00","permalink":"https://demo.stack.jimmycai.com/post/axi4lite/","title":"Axi4lite"},{"content":"太棒了！让我们从绝对的第一性原理出发，彻底搞懂AXI，然后一步步将它与你的PWM设计融合，完成一次工业级的IP封装。\n第一性原理：AXI是什么，它到底解决了什么问题？ 想象一下，你的Zynq芯片里有一个国王（CPU / PS）和很多工匠（你的PWM模块、DMA、GPIO等 / PL）。\n问题：国王只有一个，但他需要同时对很多工匠下达指令（“PWM模块，把周期设为1000”，“DMA，把这段数据搬走”）。如果每个工匠都有一根专线连到国王那里，那国王身上就要插无数根线，这显然不现实。\n解决方案：建立一个**“中央邮政系统”。所有工匠都在这个系统里注册一个唯一的“邮箱地址”**。国王想给谁下指令，只需要写一封信，写上“收件人地址”和“信件内容”，然后扔进邮政系统。邮政系统会负责把信送到正确的工匠手里。\n这个**“中央邮政系统”，在我们的芯片世界里，就是总线（Bus）。 这个“写信、送信、收信的规则”，就是协议（Protocol）**。\nAXI (Advanced eXtensible Interface) 就是ARM公司定义的一套非常流行、非常高效的“邮政系统规则”。\nAXI4-Lite: 轻量级的信件服务 AXI有很多版本，我们封装PWM这样的控制模块，只需要最简单的一种：AXI4-Lite。你可以把它理解为专门用来收发**“短信”或“明信片”**的系统，每次只传递少量（32位/64位）的数据，非常适合用来读写配置寄存器。\nAXI的核心交互：握手（Handshake） AXI协议的灵魂是**“VALID/READY”握手机制**。忘掉所有复杂的信号，只记住这一点：\nVALID (有效信号): 由发送方控制。当发送方把数据/地址准备好后，它就拉高VALID，大声宣布：“我的信息已经准备好了，并且稳定不变！” READY (就绪信号): 由接收方控制。当接收方有能力接收信息时，它就拉高READY，大声回应：“我准备好了，请把信息发给我！” 黄金法则： 只有在一个时钟上升沿，当VALID和READY同时为高时，一次有效的数据传输（或地址传输）才会发生。\n这个机制极其强大，它完美地解决了快慢设备之间的通信问题。快的设备可以等慢的设备READY，慢的设备也可以等快的设备VALID。\nAXI4-Lite的五个“通信渠道” AXI4-Lite把一次完整的读/写操作分成了几个独立的渠道，就像邮局把寄信和收信流程分开一样：\n写地址渠道 (Write Address Channel - AW): 国王（Master）告诉邮局（Interconnect）要把信送到哪个地址（AWADDR）。 写数据渠道 (Write Data Channel - W): 国王把信的内容（WDATA）交给邮局。 写响应渠道 (Write Response Channel - B): 邮局告诉国王，信送到了（BRESP），任务完成。 读地址渠道 (Read Address Channel - AR): 国王告诉邮局，他想从哪个地址取信（ARADDR）。 读数据渠道 (Read Data Channel - R): 邮局把取回来的信的内容（RDATA）交给国王。 每个渠道都有自己的VALID/READY握手信号（例如AWVALID/AWREADY）。\n我们自己设计PWM模块时，只需要扮演“工匠”（Slave）的角色，响应国王的指令。幸运的是，Vivado工具可以自动帮我们生成处理这些复杂握手逻辑的“秘书”，我们只需要和“秘书”对话就行了。\n实战：引导你完成AXI + PWM的IP封装 现在，我们把上面的理论应用到你的pwm.sv上。\n核心思想转变 旧思想：period, duty1, duty2, duty3 是物理输入端口，由外部的GPIO硬连线驱动。 新思想：period, duty1, duty2, duty3 是寄存器，它们是存在于你的IP核内部的“邮箱”。CPU通过AXI总线，使用不同的地址来写入这些“邮箱”。 步骤一：召唤“秘书”——使用IP Packager向导 在Vivado中，Tools -\u0026gt; Create and Package New IP -\u0026gt; Next。 选择 Create a new AXI4 peripheral -\u0026gt; Next。 信息填写： Name: pwm_axi (或者你喜欢的名字) Version: 1.0 Display Name: My PWM Controller with AXI 接口配置 (最关键的一步)： Interface Type: AXI4-Lite (我们的“短信服务”) Interface Mode: Slave (我们是“工匠”，被动接收指令) Data Width: 32 (AXI总线标准宽度) Number of Registers: 我们需要4个参数 (period, duty1, duty2, duty3)。所以这里填 4。这会自动为我们创建4个32位的可读写寄存器（“邮箱”）。 点击Next，然后Finish。Vivado会为你创建一个全新的项目，里面包含了所有AXI接口的“秘书”代码。 步骤二：介绍你的PWM给“秘书” 现在你进入了IP封装项目。\n添加你的代码：在Sources窗口中，右键 Add Sources，把你写好的 pwm.sv 文件添加进来。 打开“秘书”的办公室：在Sources中，找到并打开顶层文件，名字通常是 pwm_axi_v1_0_S00_AXI.v 或 .sv。 步骤三：连接PWM和“秘书” 在这个自动生成的顶层文件中，向下滚动，你会找到这样几行代码，它们就是“秘书”为你准备好的“邮箱”（寄存器）：\n1 2 3 4 5 // User logic registers reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg0; reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg1; reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg2; reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg3; slv_reg0 就是地址 0x00 对应的邮箱。 slv_reg1 就是地址 0x04 对应的邮箱。 \u0026hellip;以此类推。 现在，我们要做的就是在文件的末尾（endmodule之前），把你的PWM模块例化出来，并把这些“邮箱”连接到它的输入端口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 在 ..._S00_AXI.v 文件末尾添加以下代码 // 1. 例化你的PWM模块 pwm pwm_inst ( // .clk(clk), -\u0026gt; 应该连接到AXI总线的时钟 .clk(S_AXI_ACLK), // .rst(rst), -\u0026gt; 应该连接到AXI总线的复位 // 注意：AXI复位通常是低电平有效(ARESETN)，而你的模块可能是高电平有效。 // 如果你的复位是高电平有效，需要加一个非门。 .rst(!S_AXI_ARESETN), // 2. 将寄存器（邮箱）连接到PWM的参数输入 // 我们只关心寄存器的低16位，因为你的参数是16位的 .period(slv_reg0[15:0]), .duty1 (slv_reg1[15:0]), .duty2 (slv_reg2[15:0]), .duty3 (slv_reg3[15:0]), // 3. 将PWM的输出引出到IP核的顶层 .pwm1(pwm1_out), .pwm2(pwm2_out), .pwm3(pwm3_out) ); // 4. 在文件顶部声明这些输出信号，让它们成为IP核的物理端口 // 找到模块的端口声明区域，添加以下几行： /* module pwm_axi_v1_0_S00_AXI # (... ) ( // ... 已有的AXI端口 ... output logic pwm1_out, output logic pwm2_out, output logic pwm3_out, // ... ); */ 画龙点睛（可选但强烈推荐）：实现状态回读\nAXI不仅能写，还能读。我们可以让CPU读回PWM内部的计数器值，这对于调试非常有用。\n修改pwm.sv: 给你的PWM模块增加一个输出端口 output logic [15:0] counter_value，并把内部的counter赋给它。 在..._S00_AXI.v中：找到负责读操作的逻辑。通常会有一段 case 语句，根据读地址 axi_araddr 来选择输出哪个寄存器的数据。你可以在这里添加逻辑，当CPU读取某个特定地址（比如slv_reg0的地址）时，不返回slv_reg0的值，而是返回counter_value。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 示例： always @( posedge S_AXI_ACLK ) begin if (slv_reg_rden) // 如果有读请求 begin case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] ) 2\u0026#39;h0: reg_data_out \u0026lt;= counter_value_from_pwm; // 读地址0时，返回计数器值 2\u0026#39;h1: reg_data_out \u0026lt;= slv_reg1; // 读地址1时，返回duty1的设置值 2\u0026#39;h2: reg_data_out \u0026lt;= slv_reg2; 2\u0026#39;h3: reg_data_out \u0026lt;= slv_reg3; default : reg_data_out \u0026lt;= 0; endcase end end // 你需要先用线把pwm_inst的counter_value输出连接到一个叫counter_value_from_pwm的信号上。 步骤四：打包和发布 切换到 Package IP 标签页。 检查 File Groups，确保你的pwm.sv已经被正确识别并添加。 检查 Customization Parameters 和 Ports and Interfaces，确认一切无误。 点击 Review and Package -\u0026gt; Package IP。 恭喜！ 你已经成功地将一个纯逻辑模块，封装成了一个符合工业标准的、带AXI接口的、可复用的IP核。现在你可以回到你的主项目中，在IP Catalog里找到它，将它拖入Block Design，你会看到一个干净、专业的模块，它有一个AXI接口和三个PWM输出物理端口。\n","date":"2025-10-23T22:40:54+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E4%BB%A5pwm%E4%B8%BA%E4%BE%8B%E5%AE%9E%E7%8E%B0axi%E7%9A%84ip%E5%B0%81%E8%A3%85/","title":"以pwm为例实现axi的ip封装(created by gemini)"},{"content":"优质blog ustc:axi4总线\nustc:cecs2023 计算机综合实验\n状态设计之我见：\n我从你的分析视角看到了我之前缺略的一个思路，就是很好的区分了边界和状态。简而言之，边界之间是状态。然而对于一般的设计，边界是易于表达的，而状态是易于理解的。以周期的计算来说，边界就是counter这个计数器构成了0，1，2\u0026mdash;n-1这个n个边界点，其中存在突变点m。但是边界点却不能直观看出时间，我们将两个边界之间的点定义为状态。一般来说，每个状态的参数是相同的（比如每个状态的时间).然后我们就去计算我们要去讨论的大状态包含的基状态，比如一个周期包含的基状态，一个周期中上升沿包含的基状态。而基状态的研究只需要看大状态对应的边界点就行了\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //pwm.sv // 1个端口控制输出pwm的周期，3个输入端口分别控制3个输出端口的占空比 module pwm ( input logic clk, input logic [15:0] period, input logic [15:0] duty1, input logic [15:0] duty2, input logic [15:0] duty3, input logic rst, output logic pwm1, output logic pwm2, output logic pwm3 ); logic [15:0] counter = 0; always_ff @(posedge clk, negedge rst) begin : pwm_block if (!rst) begin counter \u0026lt;= 0; end else begin if (counter \u0026lt; period - 1) counter \u0026lt;= counter + 1; else counter \u0026lt;= 0; //pmw1 end end always_comb begin if (counter \u0026lt; duty1) begin pwm1 = 0; end else begin pwm1 = 1; end if (counter \u0026lt; duty2) begin pwm2 = 0; end else begin pwm2 = 1; end if (counter \u0026lt; duty3) begin pwm3 = 0; end else begin pwm3 = 1; end end endmodule // 注：这个代码写的并不规范，应该把组合逻辑部分放到时序部分变成同步更新，减少毛刺 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //tb_pwm.sv module tb_pwm (); parameter real CLK_PERIOD = 10; //假设时钟周期为10ns logic clk; logic [15:0] period; logic [15:0] duty1; logic [15:0] duty2; logic [15:0] duty3; logic rst; logic pwm1; logic pwm2; logic pwm3; pwm dut_pwm ( .clk(clk), .period(period), .duty1(duty1), .duty2(duty2), .duty3(duty3), .rst(rst), .pwm1(pwm1), .pwm2(pwm2), .pwm3(pwm3) ); initial begin clk = 0; end always begin #(CLK_PERIOD / 2) clk = ~clk; end initial begin rst = 1; @(posedge clk); period = 10; duty1 = 2; duty2 = 4; duty3 = 6; repeat (1000) @(posedge clk) ; $finish; end endmodule PS 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 //ps 端通过uart控制占空比 //ps 端通过uart控制占空比 #include \u0026#34;xparameters.h\u0026#34; #include \u0026#34;xil_io.h\u0026#34; #include \u0026#34;xuartlite.h\u0026#34; #include \u0026#34;xuartlite_l.h\u0026#34; #include \u0026#34;xuartlite_i.h\u0026#34; #define period_offset 0x00 #define duty1_offset 0x04 #define duty2_offset 0x08 #define duty3_offset 0x0c int main(void){ //uartlite XUartLite uartlite0; XUartLite_Initialize(\u0026amp;uartlite0,XPAR_XUARTLITE_0_BASEADDR); u8 recv_package[8]; u8 send_package[8]={\u0026#39;i\u0026#39;,\u0026#39;n\u0026#39;}; //XUartLite_Send(\u0026amp;uartlite0,send_package,2); // T=period/fclk // 由于设计失误,duty1,2,3分别表示一个周期内低电平的状态数 u32 period=1000; u32 duty1=600; u32 duty2=400; u32 duty3=200; Xil_Out32(XPAR_PWM_IP_0_BASEADDR+period_offset,period); Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty1_offset,duty1); Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty2_offset,duty2); Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty3_offset,duty3); while(1) { XUartLite_Send(\u0026amp;uartlite0,send_package,2); //XUartLite_Send(\u0026amp;uartlite0,send_package,2); recv_package[0]=XUartLite_RecvByte(XPAR_XUARTLITE_0_BASEADDR); XUartLite_Send(\u0026amp;uartlite0,send_package,2); recv_package[1]=XUartLite_RecvByte(XPAR_XUARTLITE_0_BASEADDR); recv_package[2]=XUartLite_RecvByte(XPAR_XUARTLITE_0_BASEADDR); //XUartLite_Recv(\u0026amp;uartlite0,recv_package,3); XUartLite_Send(\u0026amp;uartlite0,send_package,2); u32 sum=10*(recv_package[1]-\u0026#39;0\u0026#39;)+(recv_package[2]-\u0026#39;0\u0026#39;); u32 duty=period-period*sum/100; if(recv_package[0]==\u0026#39;1\u0026#39;) { duty1=duty; Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty1_offset,duty1); } else if(recv_package[0]==\u0026#39;2\u0026#39;) { duty2=duty; Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty2_offset,duty2); } else { duty3=duty; Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty3_offset,duty3); } } } AXI ","date":"2025-10-23T21:46:18+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq-pwm/","title":"Zynq Pwm"},{"content":"参考文章：VHDL whiz\n","date":"2025-10-23T09:56:10+08:00","permalink":"https://demo.stack.jimmycai.com/post/ready-valid/","title":"Ready Valid"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/post/markdown-syntax/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://demo.stack.jimmycai.com/post/image-gallery/2_hu_5b8da187865385db.jpg","permalink":"https://demo.stack.jimmycai.com/post/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://demo.stack.jimmycai.com/post/shortcodes/cover_hu_4b8e0b1c00bd9fd1.jpg","permalink":"https://demo.stack.jimmycai.com/post/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/post/math-typesetting/","title":"Math Typesetting"}]