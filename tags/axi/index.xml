<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Axi on fusang blog</title><link>https://demo.stack.jimmycai.com/tags/axi/</link><description>Recent content in Axi on fusang blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 23 Oct 2025 22:40:54 +0800</lastBuildDate><atom:link href="https://demo.stack.jimmycai.com/tags/axi/index.xml" rel="self" type="application/rss+xml"/><item><title>以pwm为例实现axi的ip封装(created by gemini)</title><link>https://demo.stack.jimmycai.com/post/%E4%BB%A5pwm%E4%B8%BA%E4%BE%8B%E5%AE%9E%E7%8E%B0axi%E7%9A%84ip%E5%B0%81%E8%A3%85/</link><pubDate>Thu, 23 Oct 2025 22:40:54 +0800</pubDate><guid>https://demo.stack.jimmycai.com/post/%E4%BB%A5pwm%E4%B8%BA%E4%BE%8B%E5%AE%9E%E7%8E%B0axi%E7%9A%84ip%E5%B0%81%E8%A3%85/</guid><description>&lt;p&gt;太棒了！让我们从绝对的第一性原理出发，彻底搞懂AXI，然后一步步将它与你的PWM设计融合，完成一次工业级的IP封装。&lt;/p&gt;
&lt;h3 id="第一性原理axi是什么它到底解决了什么问题"&gt;第一性原理：AXI是什么，它到底解决了什么问题？
&lt;/h3&gt;&lt;p&gt;想象一下，你的Zynq芯片里有一个&lt;strong&gt;国王（CPU / PS）&lt;strong&gt;和很多&lt;/strong&gt;工匠（你的PWM模块、DMA、GPIO等 / PL）&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：国王只有一个，但他需要同时对很多工匠下达指令（“PWM模块，把周期设为1000”，“DMA，把这段数据搬走”）。如果每个工匠都有一根专线连到国王那里，那国王身上就要插无数根线，这显然不现实。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：建立一个**“中央邮政系统”&lt;strong&gt;。所有工匠都在这个系统里注册一个唯一的&lt;/strong&gt;“邮箱地址”**。国王想给谁下指令，只需要写一封信，写上“收件人地址”和“信件内容”，然后扔进邮政系统。邮政系统会负责把信送到正确的工匠手里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个**“中央邮政系统”&lt;strong&gt;，在我们的芯片世界里，就是&lt;/strong&gt;总线（Bus）&lt;strong&gt;。
这个&lt;/strong&gt;“写信、送信、收信的规则”&lt;strong&gt;，就是&lt;/strong&gt;协议（Protocol）**。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AXI (Advanced eXtensible Interface) 就是ARM公司定义的一套非常流行、非常高效的“邮政系统规则”。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="axi4-lite-轻量级的信件服务"&gt;AXI4-Lite: 轻量级的信件服务
&lt;/h3&gt;&lt;p&gt;AXI有很多版本，我们封装PWM这样的控制模块，只需要最简单的一种：&lt;strong&gt;AXI4-Lite&lt;/strong&gt;。你可以把它理解为专门用来收发**“短信”或“明信片”**的系统，每次只传递少量（32位/64位）的数据，非常适合用来读写配置寄存器。&lt;/p&gt;
&lt;h4 id="axi的核心交互握手handshake"&gt;AXI的核心交互：握手（Handshake）
&lt;/h4&gt;&lt;p&gt;AXI协议的灵魂是**“VALID/READY”握手机制**。忘掉所有复杂的信号，只记住这一点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;VALID (有效信号)&lt;/strong&gt;: 由&lt;strong&gt;发送方&lt;/strong&gt;控制。当发送方把数据/地址准备好后，它就拉高&lt;code&gt;VALID&lt;/code&gt;，大声宣布：“我的信息已经准备好了，并且稳定不变！”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;READY (就绪信号)&lt;/strong&gt;: 由&lt;strong&gt;接收方&lt;/strong&gt;控制。当接收方有能力接收信息时，它就拉高&lt;code&gt;READY&lt;/code&gt;，大声回应：“我准备好了，请把信息发给我！”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;黄金法则：&lt;/strong&gt; 只有在一个时钟上升沿，&lt;strong&gt;当&lt;code&gt;VALID&lt;/code&gt;和&lt;code&gt;READY&lt;/code&gt;同时为高时&lt;/strong&gt;，一次有效的数据传输（或地址传输）才会发生。&lt;/p&gt;
&lt;p&gt;这个机制极其强大，它完美地解决了快慢设备之间的通信问题。快的设备可以等慢的设备&lt;code&gt;READY&lt;/code&gt;，慢的设备也可以等快的设备&lt;code&gt;VALID&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="axi4-lite的五个通信渠道"&gt;AXI4-Lite的五个“通信渠道”
&lt;/h4&gt;&lt;p&gt;AXI4-Lite把一次完整的读/写操作分成了几个独立的渠道，就像邮局把寄信和收信流程分开一样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;写地址渠道 (Write Address Channel - AW)&lt;/strong&gt;: 国王（Master）告诉邮局（Interconnect）要把信送到哪个地址（&lt;code&gt;AWADDR&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写数据渠道 (Write Data Channel - W)&lt;/strong&gt;: 国王把信的内容（&lt;code&gt;WDATA&lt;/code&gt;）交给邮局。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写响应渠道 (Write Response Channel - B)&lt;/strong&gt;: 邮局告诉国王，信送到了（&lt;code&gt;BRESP&lt;/code&gt;），任务完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读地址渠道 (Read Address Channel - AR)&lt;/strong&gt;: 国王告诉邮局，他想从哪个地址取信（&lt;code&gt;ARADDR&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读数据渠道 (Read Data Channel - R)&lt;/strong&gt;: 邮局把取回来的信的内容（&lt;code&gt;RDATA&lt;/code&gt;）交给国王。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个渠道都有自己的&lt;code&gt;VALID&lt;/code&gt;/&lt;code&gt;READY&lt;/code&gt;握手信号（例如&lt;code&gt;AWVALID&lt;/code&gt;/&lt;code&gt;AWREADY&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们自己设计PWM模块时，只需要扮演“工匠”（Slave）的角色&lt;/strong&gt;，响应国王的指令。幸运的是，Vivado工具可以自动帮我们生成处理这些复杂握手逻辑的“秘书”，我们只需要和“秘书”对话就行了。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="实战引导你完成axi--pwm的ip封装"&gt;实战：引导你完成AXI + PWM的IP封装
&lt;/h3&gt;&lt;p&gt;现在，我们把上面的理论应用到你的&lt;code&gt;pwm.sv&lt;/code&gt;上。&lt;/p&gt;
&lt;h4 id="核心思想转变"&gt;核心思想转变
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;旧思想&lt;/strong&gt;：&lt;code&gt;period&lt;/code&gt;, &lt;code&gt;duty1&lt;/code&gt;, &lt;code&gt;duty2&lt;/code&gt;, &lt;code&gt;duty3&lt;/code&gt; 是物理输入端口，由外部的GPIO硬连线驱动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新思想&lt;/strong&gt;：&lt;code&gt;period&lt;/code&gt;, &lt;code&gt;duty1&lt;/code&gt;, &lt;code&gt;duty2&lt;/code&gt;, &lt;code&gt;duty3&lt;/code&gt; 是&lt;strong&gt;寄存器&lt;/strong&gt;，它们是存在于你的IP核内部的“邮箱”。CPU通过AXI总线，使用不同的地址来&lt;strong&gt;写入&lt;/strong&gt;这些“邮箱”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="步骤一召唤秘书使用ip-packager向导"&gt;步骤一：召唤“秘书”——使用IP Packager向导
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;在Vivado中，&lt;code&gt;Tools -&amp;gt; Create and Package New IP&lt;/code&gt; -&amp;gt; &lt;code&gt;Next&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;选择 &lt;code&gt;Create a new AXI4 peripheral&lt;/code&gt; -&amp;gt; &lt;code&gt;Next&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信息填写&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Name: &lt;code&gt;pwm_axi&lt;/code&gt; (或者你喜欢的名字)&lt;/li&gt;
&lt;li&gt;Version: &lt;code&gt;1.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Display Name: &lt;code&gt;My PWM Controller with AXI&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口配置 (最关键的一步)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Interface Type: &lt;code&gt;AXI4-Lite&lt;/code&gt; (我们的“短信服务”)&lt;/li&gt;
&lt;li&gt;Interface Mode: &lt;code&gt;Slave&lt;/code&gt; (我们是“工匠”，被动接收指令)&lt;/li&gt;
&lt;li&gt;Data Width: &lt;code&gt;32&lt;/code&gt; (AXI总线标准宽度)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Number of Registers&lt;/strong&gt;: 我们需要4个参数 (&lt;code&gt;period&lt;/code&gt;, &lt;code&gt;duty1&lt;/code&gt;, &lt;code&gt;duty2&lt;/code&gt;, &lt;code&gt;duty3&lt;/code&gt;)。所以这里填 &lt;strong&gt;4&lt;/strong&gt;。这会自动为我们创建4个32位的可读写寄存器（“邮箱”）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;Next&lt;/code&gt;，然后&lt;code&gt;Finish&lt;/code&gt;。Vivado会为你创建一个全新的项目，里面包含了所有AXI接口的“秘书”代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="步骤二介绍你的pwm给秘书"&gt;步骤二：介绍你的PWM给“秘书”
&lt;/h4&gt;&lt;p&gt;现在你进入了IP封装项目。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;添加你的代码&lt;/strong&gt;：在Sources窗口中，右键 &lt;code&gt;Add Sources&lt;/code&gt;，把你写好的 &lt;code&gt;pwm.sv&lt;/code&gt; 文件添加进来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;打开“秘书”的办公室&lt;/strong&gt;：在Sources中，找到并打开顶层文件，名字通常是 &lt;code&gt;pwm_axi_v1_0_S00_AXI.v&lt;/code&gt; 或 &lt;code&gt;.sv&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="步骤三连接pwm和秘书"&gt;步骤三：连接PWM和“秘书”
&lt;/h4&gt;&lt;p&gt;在这个自动生成的顶层文件中，向下滚动，你会找到这样几行代码，它们就是“秘书”为你准备好的“邮箱”（寄存器）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-systemverilog" data-lang="systemverilog"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// User logic registers
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;C_S_AXI_DATA_WIDTH&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;slv_reg0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;C_S_AXI_DATA_WIDTH&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;slv_reg1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;C_S_AXI_DATA_WIDTH&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;slv_reg2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;C_S_AXI_DATA_WIDTH&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;slv_reg3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;slv_reg0&lt;/code&gt; 就是地址 &lt;code&gt;0x00&lt;/code&gt; 对应的邮箱。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slv_reg1&lt;/code&gt; 就是地址 &lt;code&gt;0x04&lt;/code&gt; 对应的邮箱。&lt;/li&gt;
&lt;li&gt;&amp;hellip;以此类推。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，我们要做的就是在文件的&lt;strong&gt;末尾&lt;/strong&gt;（&lt;code&gt;endmodule&lt;/code&gt;之前），把你的PWM模块例化出来，并把这些“邮箱”连接到它的输入端口。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;span class="lnt"&gt;28
&lt;/span&gt;&lt;span class="lnt"&gt;29
&lt;/span&gt;&lt;span class="lnt"&gt;30
&lt;/span&gt;&lt;span class="lnt"&gt;31
&lt;/span&gt;&lt;span class="lnt"&gt;32
&lt;/span&gt;&lt;span class="lnt"&gt;33
&lt;/span&gt;&lt;span class="lnt"&gt;34
&lt;/span&gt;&lt;span class="lnt"&gt;35
&lt;/span&gt;&lt;span class="lnt"&gt;36
&lt;/span&gt;&lt;span class="lnt"&gt;37
&lt;/span&gt;&lt;span class="lnt"&gt;38
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-systemverilog" data-lang="systemverilog"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 在 ..._S00_AXI.v 文件末尾添加以下代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 1. 例化你的PWM模块
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;pwm&lt;/span&gt; &lt;span class="n"&gt;pwm_inst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// .clk(clk), -&amp;gt; 应该连接到AXI总线的时钟
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S_AXI_ACLK&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// .rst(rst), -&amp;gt; 应该连接到AXI总线的复位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// 注意：AXI复位通常是低电平有效(ARESETN)，而你的模块可能是高电平有效。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// 如果你的复位是高电平有效，需要加一个非门。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;S_AXI_ARESETN&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 2. 将寄存器（邮箱）连接到PWM的参数输入
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// 我们只关心寄存器的低16位，因为你的参数是16位的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;period&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;slv_reg0&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;duty1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;slv_reg1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;duty2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;slv_reg2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;duty3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;slv_reg3&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 3. 将PWM的输出引出到IP核的顶层
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pwm1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pwm1_out&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pwm2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pwm2_out&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pwm3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pwm3_out&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 4. 在文件顶部声明这些输出信号，让它们成为IP核的物理端口
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 找到模块的端口声明区域，添加以下几行：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;module pwm_axi_v1_0_S00_AXI # (...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; // ... 已有的AXI端口 ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; output logic pwm1_out,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; output logic pwm2_out,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; output logic pwm3_out,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; // ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;画龙点睛（可选但强烈推荐）：实现状态回读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AXI不仅能写，还能读。我们可以让CPU读回PWM内部的计数器值，这对于调试非常有用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;修改&lt;code&gt;pwm.sv&lt;/code&gt;&lt;/strong&gt;: 给你的PWM模块增加一个输出端口 &lt;code&gt;output logic [15:0] counter_value&lt;/code&gt;，并把内部的&lt;code&gt;counter&lt;/code&gt;赋给它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在&lt;code&gt;..._S00_AXI.v&lt;/code&gt;中&lt;/strong&gt;：找到负责读操作的逻辑。通常会有一段 &lt;code&gt;case&lt;/code&gt; 语句，根据读地址 &lt;code&gt;axi_araddr&lt;/code&gt; 来选择输出哪个寄存器的数据。你可以在这里添加逻辑，当CPU读取某个特定地址（比如&lt;code&gt;slv_reg0&lt;/code&gt;的地址）时，不返回&lt;code&gt;slv_reg0&lt;/code&gt;的值，而是返回&lt;code&gt;counter_value&lt;/code&gt;。
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-systemverilog" data-lang="systemverilog"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 示例：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;S_AXI_ACLK&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;slv_reg_rden&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 如果有读请求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;axi_araddr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ADDR_LSB&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nl"&gt;OPT_MEM_ADDR_BITS:&lt;/span&gt;&lt;span class="n"&gt;ADDR_LSB&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="mh"&gt;2&amp;#39;h0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;reg_data_out&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;counter_value_from_pwm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 读地址0时，返回计数器值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="mh"&gt;2&amp;#39;h1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;reg_data_out&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;slv_reg1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 读地址1时，返回duty1的设置值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="mh"&gt;2&amp;#39;h2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;reg_data_out&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;slv_reg2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="mh"&gt;2&amp;#39;h3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;reg_data_out&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;slv_reg3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;default&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;reg_data_out&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 你需要先用线把pwm_inst的counter_value输出连接到一个叫counter_value_from_pwm的信号上。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="步骤四打包和发布"&gt;步骤四：打包和发布
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;切换到 &lt;code&gt;Package IP&lt;/code&gt; 标签页。&lt;/li&gt;
&lt;li&gt;检查 &lt;code&gt;File Groups&lt;/code&gt;，确保你的&lt;code&gt;pwm.sv&lt;/code&gt;已经被正确识别并添加。&lt;/li&gt;
&lt;li&gt;检查 &lt;code&gt;Customization Parameters&lt;/code&gt; 和 &lt;code&gt;Ports and Interfaces&lt;/code&gt;，确认一切无误。&lt;/li&gt;
&lt;li&gt;点击 &lt;code&gt;Review and Package&lt;/code&gt; -&amp;gt; &lt;code&gt;Package IP&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;恭喜！&lt;/strong&gt; 你已经成功地将一个纯逻辑模块，封装成了一个符合工业标准的、带AXI接口的、可复用的IP核。现在你可以回到你的主项目中，在IP Catalog里找到它，将它拖入Block Design，你会看到一个干净、专业的模块，它有一个AXI接口和三个PWM输出物理端口。&lt;/p&gt;</description></item></channel></rss>