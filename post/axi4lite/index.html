<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 `timescale 1 ns / 1 ps module myip_slave_lite_v1_0_S00_AXI # ( // Users to add parameters here // User parameters ends // Do not modify the parameters beyond this line // Width of S_AXI data bus parameter integer C_S_AXI_DATA_WIDTH\t= 32, // Width of S_AXI address bus parameter integer C_S_AXI_ADDR_WIDTH\t= 4 ) ( // Users to add ports here // User ports ends // Do not modify the ports beyond this line // Global Clock Signal input wire S_AXI_ACLK, // Global Reset Signal. This Signal is Active LOW input wire S_AXI_ARESETN, // Write address (issued by master, acceped by Slave) input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR, // Write channel Protection type. This signal indicates the // privilege and security level of the transaction, and whether // the transaction is a data access or an instruction access. input wire [2 : 0] S_AXI_AWPROT, // Write address valid. This signal indicates that the master signaling // valid write address and control information. input wire S_AXI_AWVALID, // Write address ready. This signal indicates that the slave is ready // to accept an address and associated control signals. output wire S_AXI_AWREADY, // Write data (issued by master, acceped by Slave) input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA, // Write strobes. This signal indicates which byte lanes hold // valid data. There is one write strobe bit for each eight // bits of the write data bus. input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB, // Write valid. This signal indicates that valid write // data and strobes are available. input wire S_AXI_WVALID, // Write ready. This signal indicates that the slave // can accept the write data. output wire S_AXI_WREADY, // Write response. This signal indicates the status // of the write transaction. output wire [1 : 0] S_AXI_BRESP, // Write response valid. This signal indicates that the channel // is signaling a valid write response. output wire S_AXI_BVALID, // Response ready. This signal indicates that the master // can accept a write response. input wire S_AXI_BREADY, // Read address (issued by master, acceped by Slave) input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR, // Protection type. This signal indicates the privilege // and security level of the transaction, and whether the // transaction is a data access or an instruction access. input wire [2 : 0] S_AXI_ARPROT, // Read address valid. This signal indicates that the channel // is signaling valid read address and control information. input wire S_AXI_ARVALID, // Read address ready. This signal indicates that the slave is // ready to accept an address and associated control signals. output wire S_AXI_ARREADY, // Read data (issued by slave) output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA, // Read response. This signal indicates the status of the // read transfer. output wire [1 : 0] S_AXI_RRESP, // Read valid. This signal indicates that the channel is // signaling the required read data. output wire S_AXI_RVALID, // Read ready. This signal indicates that the master can // accept the read data and response information. input wire S_AXI_RREADY ); // AXI4LITE signals reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_awaddr; reg axi_awready; reg axi_wready; reg [1 : 0] axi_bresp; reg axi_bvalid; reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_araddr; reg axi_arready; reg [1 : 0] axi_rresp; reg axi_rvalid; // Example-specific design signals // local parameter for addressing 32 bit / 64 bit C_S_AXI_DATA_WIDTH // ADDR_LSB is used for addressing 32/64 bit registers/memories // ADDR_LSB = 2 for 32 bits (n downto 2) // ADDR_LSB = 3 for 64 bits (n downto 3) localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1; localparam integer OPT_MEM_ADDR_BITS = 1; //---------------------------------------------- //-- Signals for user logic register space example //------------------------------------------------ //-- Number of Slave Registers 4 reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg0; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg1; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg2; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg3; integer\tbyte_index; // I/O Connections assignments assign S_AXI_AWREADY\t= axi_awready; assign S_AXI_WREADY\t= axi_wready; assign S_AXI_BRESP\t= axi_bresp; assign S_AXI_BVALID\t= axi_bvalid; assign S_AXI_ARREADY\t= axi_arready; assign S_AXI_RRESP\t= axi_rresp; assign S_AXI_RVALID\t= axi_rvalid; //state machine varibles reg [1:0] state_write; reg [1:0] state_read; //State machine local parameters localparam Idle = 2'b00,Raddr = 2'b10,Rdata = 2'b11 ,Waddr = 2'b10,Wdata = 2'b11; // Implement Write state machine // Outstanding write transactions are not supported by the slave i.e., master should assert bready to receive response on or before it starts sending the new transaction always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1'b0) begin axi_awready <= 0; axi_wready <= 0; axi_bvalid <= 0; axi_bresp <= 0; axi_awaddr <= 0; state_write <= Idle; end else begin case(state_write) Idle: begin if(S_AXI_ARESETN == 1'b1) begin axi_awready <= 1'b1; axi_wready <= 1'b1; state_write <= Waddr; end else state_write <= state_write; end Waddr: //At this state, slave is ready to receive address along with corresponding control signals and first data packet. Response valid is also handled at this state begin if (S_AXI_AWVALID && S_AXI_AWREADY) begin axi_awaddr <= S_AXI_AWADDR; if(S_AXI_WVALID) begin axi_awready <= 1'b1; state_write <= Waddr; axi_bvalid <= 1'b1; end else begin axi_awready <= 1'b0; state_write <= Wdata; if (S_AXI_BREADY && axi_bvalid) axi_bvalid <= 1'b0; end end else begin state_write <= state_write; if (S_AXI_BREADY && axi_bvalid) axi_bvalid <= 1'b0; end end Wdata: //At this state, slave is ready to receive the data packets until the number of transfers is equal to burst length begin if (S_AXI_WVALID) begin state_write <= Waddr; axi_bvalid <= 1'b1; axi_awready <= 1'b1; end else begin state_write <= state_write; if (S_AXI_BREADY && axi_bvalid) axi_bvalid <= 1'b0; end end endcase end end // Implement memory mapped register select and write logic generation // The write data is accepted and written to memory mapped registers when // axi_awready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted. Write strobes are used to // select byte enables of slave registers while writing. // These registers are cleared when reset (active low) is applied. // Slave register write enable is asserted when valid address and data are available // and the slave is ready to accept the write address and write data. always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin slv_reg0 <= 0; slv_reg1 <= 0; slv_reg2 <= 0; slv_reg3 <= 0; end else begin if (S_AXI_WVALID) begin case ( (S_AXI_AWVALID) ? S_AXI_AWADDR[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] : axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] ) 2'h0: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 0 slv_reg0[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h1: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 1 slv_reg1[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h2: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 2 slv_reg2[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h3: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 3 slv_reg3[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end default : begin slv_reg0 <= slv_reg0; slv_reg1 <= slv_reg1; slv_reg2 <= slv_reg2; slv_reg3 <= slv_reg3; end endcase end end end // Implement read state machine always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1'b0) begin //asserting initial values to all 0's during reset axi_arready <= 1'b0; axi_rvalid <= 1'b0; axi_rresp <= 1'b0; state_read <= Idle; end else begin case(state_read) Idle: //Initial state inidicating reset is done and ready to receive read/write transactions begin if (S_AXI_ARESETN == 1'b1) begin state_read <= Raddr; axi_arready <= 1'b1; end else state_read <= state_read; end Raddr: //At this state, slave is ready to receive address along with corresponding control signals begin if (S_AXI_ARVALID && S_AXI_ARREADY) begin state_read <= Rdata; axi_araddr <= S_AXI_ARADDR; axi_rvalid <= 1'b1; axi_arready <= 1'b0; end else state_read <= state_read; end Rdata: //At this state, slave is ready to send the data packets until the number of transfers is equal to burst length begin if (S_AXI_RVALID && S_AXI_RREADY) begin axi_rvalid <= 1'b0; axi_arready <= 1'b1; state_read <= Raddr; end else state_read <= state_read; end endcase end end // Implement memory mapped register select and read logic generation assign S_AXI_RDATA = (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h0) ? slv_reg0 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h1) ? slv_reg1 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h2) ? slv_reg2 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h3) ? slv_reg3 : 0; // Add user logic here // User logic ends endmodule "><title>Axi4lite</title><link rel=canonical href=https://demo.stack.jimmycai.com/post/axi4lite/><link rel=stylesheet href=/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css><meta property='og:title' content="Axi4lite"><meta property='og:description' content="代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 `timescale 1 ns / 1 ps module myip_slave_lite_v1_0_S00_AXI # ( // Users to add parameters here // User parameters ends // Do not modify the parameters beyond this line // Width of S_AXI data bus parameter integer C_S_AXI_DATA_WIDTH\t= 32, // Width of S_AXI address bus parameter integer C_S_AXI_ADDR_WIDTH\t= 4 ) ( // Users to add ports here // User ports ends // Do not modify the ports beyond this line // Global Clock Signal input wire S_AXI_ACLK, // Global Reset Signal. This Signal is Active LOW input wire S_AXI_ARESETN, // Write address (issued by master, acceped by Slave) input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR, // Write channel Protection type. This signal indicates the // privilege and security level of the transaction, and whether // the transaction is a data access or an instruction access. input wire [2 : 0] S_AXI_AWPROT, // Write address valid. This signal indicates that the master signaling // valid write address and control information. input wire S_AXI_AWVALID, // Write address ready. This signal indicates that the slave is ready // to accept an address and associated control signals. output wire S_AXI_AWREADY, // Write data (issued by master, acceped by Slave) input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA, // Write strobes. This signal indicates which byte lanes hold // valid data. There is one write strobe bit for each eight // bits of the write data bus. input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB, // Write valid. This signal indicates that valid write // data and strobes are available. input wire S_AXI_WVALID, // Write ready. This signal indicates that the slave // can accept the write data. output wire S_AXI_WREADY, // Write response. This signal indicates the status // of the write transaction. output wire [1 : 0] S_AXI_BRESP, // Write response valid. This signal indicates that the channel // is signaling a valid write response. output wire S_AXI_BVALID, // Response ready. This signal indicates that the master // can accept a write response. input wire S_AXI_BREADY, // Read address (issued by master, acceped by Slave) input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR, // Protection type. This signal indicates the privilege // and security level of the transaction, and whether the // transaction is a data access or an instruction access. input wire [2 : 0] S_AXI_ARPROT, // Read address valid. This signal indicates that the channel // is signaling valid read address and control information. input wire S_AXI_ARVALID, // Read address ready. This signal indicates that the slave is // ready to accept an address and associated control signals. output wire S_AXI_ARREADY, // Read data (issued by slave) output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA, // Read response. This signal indicates the status of the // read transfer. output wire [1 : 0] S_AXI_RRESP, // Read valid. This signal indicates that the channel is // signaling the required read data. output wire S_AXI_RVALID, // Read ready. This signal indicates that the master can // accept the read data and response information. input wire S_AXI_RREADY ); // AXI4LITE signals reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_awaddr; reg axi_awready; reg axi_wready; reg [1 : 0] axi_bresp; reg axi_bvalid; reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_araddr; reg axi_arready; reg [1 : 0] axi_rresp; reg axi_rvalid; // Example-specific design signals // local parameter for addressing 32 bit / 64 bit C_S_AXI_DATA_WIDTH // ADDR_LSB is used for addressing 32/64 bit registers/memories // ADDR_LSB = 2 for 32 bits (n downto 2) // ADDR_LSB = 3 for 64 bits (n downto 3) localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1; localparam integer OPT_MEM_ADDR_BITS = 1; //---------------------------------------------- //-- Signals for user logic register space example //------------------------------------------------ //-- Number of Slave Registers 4 reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg0; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg1; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg2; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg3; integer\tbyte_index; // I/O Connections assignments assign S_AXI_AWREADY\t= axi_awready; assign S_AXI_WREADY\t= axi_wready; assign S_AXI_BRESP\t= axi_bresp; assign S_AXI_BVALID\t= axi_bvalid; assign S_AXI_ARREADY\t= axi_arready; assign S_AXI_RRESP\t= axi_rresp; assign S_AXI_RVALID\t= axi_rvalid; //state machine varibles reg [1:0] state_write; reg [1:0] state_read; //State machine local parameters localparam Idle = 2'b00,Raddr = 2'b10,Rdata = 2'b11 ,Waddr = 2'b10,Wdata = 2'b11; // Implement Write state machine // Outstanding write transactions are not supported by the slave i.e., master should assert bready to receive response on or before it starts sending the new transaction always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1'b0) begin axi_awready <= 0; axi_wready <= 0; axi_bvalid <= 0; axi_bresp <= 0; axi_awaddr <= 0; state_write <= Idle; end else begin case(state_write) Idle: begin if(S_AXI_ARESETN == 1'b1) begin axi_awready <= 1'b1; axi_wready <= 1'b1; state_write <= Waddr; end else state_write <= state_write; end Waddr: //At this state, slave is ready to receive address along with corresponding control signals and first data packet. Response valid is also handled at this state begin if (S_AXI_AWVALID && S_AXI_AWREADY) begin axi_awaddr <= S_AXI_AWADDR; if(S_AXI_WVALID) begin axi_awready <= 1'b1; state_write <= Waddr; axi_bvalid <= 1'b1; end else begin axi_awready <= 1'b0; state_write <= Wdata; if (S_AXI_BREADY && axi_bvalid) axi_bvalid <= 1'b0; end end else begin state_write <= state_write; if (S_AXI_BREADY && axi_bvalid) axi_bvalid <= 1'b0; end end Wdata: //At this state, slave is ready to receive the data packets until the number of transfers is equal to burst length begin if (S_AXI_WVALID) begin state_write <= Waddr; axi_bvalid <= 1'b1; axi_awready <= 1'b1; end else begin state_write <= state_write; if (S_AXI_BREADY && axi_bvalid) axi_bvalid <= 1'b0; end end endcase end end // Implement memory mapped register select and write logic generation // The write data is accepted and written to memory mapped registers when // axi_awready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted. Write strobes are used to // select byte enables of slave registers while writing. // These registers are cleared when reset (active low) is applied. // Slave register write enable is asserted when valid address and data are available // and the slave is ready to accept the write address and write data. always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin slv_reg0 <= 0; slv_reg1 <= 0; slv_reg2 <= 0; slv_reg3 <= 0; end else begin if (S_AXI_WVALID) begin case ( (S_AXI_AWVALID) ? S_AXI_AWADDR[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] : axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] ) 2'h0: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 0 slv_reg0[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h1: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 1 slv_reg1[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h2: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 2 slv_reg2[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h3: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 3 slv_reg3[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end default : begin slv_reg0 <= slv_reg0; slv_reg1 <= slv_reg1; slv_reg2 <= slv_reg2; slv_reg3 <= slv_reg3; end endcase end end end // Implement read state machine always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1'b0) begin //asserting initial values to all 0's during reset axi_arready <= 1'b0; axi_rvalid <= 1'b0; axi_rresp <= 1'b0; state_read <= Idle; end else begin case(state_read) Idle: //Initial state inidicating reset is done and ready to receive read/write transactions begin if (S_AXI_ARESETN == 1'b1) begin state_read <= Raddr; axi_arready <= 1'b1; end else state_read <= state_read; end Raddr: //At this state, slave is ready to receive address along with corresponding control signals begin if (S_AXI_ARVALID && S_AXI_ARREADY) begin state_read <= Rdata; axi_araddr <= S_AXI_ARADDR; axi_rvalid <= 1'b1; axi_arready <= 1'b0; end else state_read <= state_read; end Rdata: //At this state, slave is ready to send the data packets until the number of transfers is equal to burst length begin if (S_AXI_RVALID && S_AXI_RREADY) begin axi_rvalid <= 1'b0; axi_arready <= 1'b1; state_read <= Raddr; end else state_read <= state_read; end endcase end end // Implement memory mapped register select and read logic generation assign S_AXI_RDATA = (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h0) ? slv_reg0 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h1) ? slv_reg1 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h2) ? slv_reg2 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h3) ? slv_reg3 : 0; // Add user logic here // User logic ends endmodule "><meta property='og:url' content='https://demo.stack.jimmycai.com/post/axi4lite/'><meta property='og:site_name' content='fusang blog'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='zynq'><meta property='article:tag' content='axi4'><meta property='article:published_time' content='2025-10-24T09:13:35+08:00'><meta property='article:modified_time' content='2025-10-24T09:13:35+08:00'><meta name=twitter:title content="Axi4lite"><meta name=twitter:description content="代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 `timescale 1 ns / 1 ps module myip_slave_lite_v1_0_S00_AXI # ( // Users to add parameters here // User parameters ends // Do not modify the parameters beyond this line // Width of S_AXI data bus parameter integer C_S_AXI_DATA_WIDTH\t= 32, // Width of S_AXI address bus parameter integer C_S_AXI_ADDR_WIDTH\t= 4 ) ( // Users to add ports here // User ports ends // Do not modify the ports beyond this line // Global Clock Signal input wire S_AXI_ACLK, // Global Reset Signal. This Signal is Active LOW input wire S_AXI_ARESETN, // Write address (issued by master, acceped by Slave) input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR, // Write channel Protection type. This signal indicates the // privilege and security level of the transaction, and whether // the transaction is a data access or an instruction access. input wire [2 : 0] S_AXI_AWPROT, // Write address valid. This signal indicates that the master signaling // valid write address and control information. input wire S_AXI_AWVALID, // Write address ready. This signal indicates that the slave is ready // to accept an address and associated control signals. output wire S_AXI_AWREADY, // Write data (issued by master, acceped by Slave) input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA, // Write strobes. This signal indicates which byte lanes hold // valid data. There is one write strobe bit for each eight // bits of the write data bus. input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB, // Write valid. This signal indicates that valid write // data and strobes are available. input wire S_AXI_WVALID, // Write ready. This signal indicates that the slave // can accept the write data. output wire S_AXI_WREADY, // Write response. This signal indicates the status // of the write transaction. output wire [1 : 0] S_AXI_BRESP, // Write response valid. This signal indicates that the channel // is signaling a valid write response. output wire S_AXI_BVALID, // Response ready. This signal indicates that the master // can accept a write response. input wire S_AXI_BREADY, // Read address (issued by master, acceped by Slave) input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR, // Protection type. This signal indicates the privilege // and security level of the transaction, and whether the // transaction is a data access or an instruction access. input wire [2 : 0] S_AXI_ARPROT, // Read address valid. This signal indicates that the channel // is signaling valid read address and control information. input wire S_AXI_ARVALID, // Read address ready. This signal indicates that the slave is // ready to accept an address and associated control signals. output wire S_AXI_ARREADY, // Read data (issued by slave) output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA, // Read response. This signal indicates the status of the // read transfer. output wire [1 : 0] S_AXI_RRESP, // Read valid. This signal indicates that the channel is // signaling the required read data. output wire S_AXI_RVALID, // Read ready. This signal indicates that the master can // accept the read data and response information. input wire S_AXI_RREADY ); // AXI4LITE signals reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_awaddr; reg axi_awready; reg axi_wready; reg [1 : 0] axi_bresp; reg axi_bvalid; reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_araddr; reg axi_arready; reg [1 : 0] axi_rresp; reg axi_rvalid; // Example-specific design signals // local parameter for addressing 32 bit / 64 bit C_S_AXI_DATA_WIDTH // ADDR_LSB is used for addressing 32/64 bit registers/memories // ADDR_LSB = 2 for 32 bits (n downto 2) // ADDR_LSB = 3 for 64 bits (n downto 3) localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1; localparam integer OPT_MEM_ADDR_BITS = 1; //---------------------------------------------- //-- Signals for user logic register space example //------------------------------------------------ //-- Number of Slave Registers 4 reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg0; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg1; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg2; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg3; integer\tbyte_index; // I/O Connections assignments assign S_AXI_AWREADY\t= axi_awready; assign S_AXI_WREADY\t= axi_wready; assign S_AXI_BRESP\t= axi_bresp; assign S_AXI_BVALID\t= axi_bvalid; assign S_AXI_ARREADY\t= axi_arready; assign S_AXI_RRESP\t= axi_rresp; assign S_AXI_RVALID\t= axi_rvalid; //state machine varibles reg [1:0] state_write; reg [1:0] state_read; //State machine local parameters localparam Idle = 2'b00,Raddr = 2'b10,Rdata = 2'b11 ,Waddr = 2'b10,Wdata = 2'b11; // Implement Write state machine // Outstanding write transactions are not supported by the slave i.e., master should assert bready to receive response on or before it starts sending the new transaction always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1'b0) begin axi_awready <= 0; axi_wready <= 0; axi_bvalid <= 0; axi_bresp <= 0; axi_awaddr <= 0; state_write <= Idle; end else begin case(state_write) Idle: begin if(S_AXI_ARESETN == 1'b1) begin axi_awready <= 1'b1; axi_wready <= 1'b1; state_write <= Waddr; end else state_write <= state_write; end Waddr: //At this state, slave is ready to receive address along with corresponding control signals and first data packet. Response valid is also handled at this state begin if (S_AXI_AWVALID && S_AXI_AWREADY) begin axi_awaddr <= S_AXI_AWADDR; if(S_AXI_WVALID) begin axi_awready <= 1'b1; state_write <= Waddr; axi_bvalid <= 1'b1; end else begin axi_awready <= 1'b0; state_write <= Wdata; if (S_AXI_BREADY && axi_bvalid) axi_bvalid <= 1'b0; end end else begin state_write <= state_write; if (S_AXI_BREADY && axi_bvalid) axi_bvalid <= 1'b0; end end Wdata: //At this state, slave is ready to receive the data packets until the number of transfers is equal to burst length begin if (S_AXI_WVALID) begin state_write <= Waddr; axi_bvalid <= 1'b1; axi_awready <= 1'b1; end else begin state_write <= state_write; if (S_AXI_BREADY && axi_bvalid) axi_bvalid <= 1'b0; end end endcase end end // Implement memory mapped register select and write logic generation // The write data is accepted and written to memory mapped registers when // axi_awready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted. Write strobes are used to // select byte enables of slave registers while writing. // These registers are cleared when reset (active low) is applied. // Slave register write enable is asserted when valid address and data are available // and the slave is ready to accept the write address and write data. always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin slv_reg0 <= 0; slv_reg1 <= 0; slv_reg2 <= 0; slv_reg3 <= 0; end else begin if (S_AXI_WVALID) begin case ( (S_AXI_AWVALID) ? S_AXI_AWADDR[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] : axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] ) 2'h0: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 0 slv_reg0[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h1: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 1 slv_reg1[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h2: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 2 slv_reg2[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h3: for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 3 slv_reg3[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8]; end default : begin slv_reg0 <= slv_reg0; slv_reg1 <= slv_reg1; slv_reg2 <= slv_reg2; slv_reg3 <= slv_reg3; end endcase end end end // Implement read state machine always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1'b0) begin //asserting initial values to all 0's during reset axi_arready <= 1'b0; axi_rvalid <= 1'b0; axi_rresp <= 1'b0; state_read <= Idle; end else begin case(state_read) Idle: //Initial state inidicating reset is done and ready to receive read/write transactions begin if (S_AXI_ARESETN == 1'b1) begin state_read <= Raddr; axi_arready <= 1'b1; end else state_read <= state_read; end Raddr: //At this state, slave is ready to receive address along with corresponding control signals begin if (S_AXI_ARVALID && S_AXI_ARREADY) begin state_read <= Rdata; axi_araddr <= S_AXI_ARADDR; axi_rvalid <= 1'b1; axi_arready <= 1'b0; end else state_read <= state_read; end Rdata: //At this state, slave is ready to send the data packets until the number of transfers is equal to burst length begin if (S_AXI_RVALID && S_AXI_RREADY) begin axi_rvalid <= 1'b0; axi_arready <= 1'b1; state_read <= Raddr; end else state_read <= state_read; end endcase end end // Implement memory mapped register select and read logic generation assign S_AXI_RDATA = (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h0) ? slv_reg0 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h1) ? slv_reg1 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h2) ? slv_reg2 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2'h3) ? slv_reg3 : 0; // Add user logic here // User logic ends endmodule "><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/circuitboard_hu_69d219ece9ed483c.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>fusang blog</a></h1><h2 class=site-description>六根清净方为道 退步原来是向前</h2></div></header><ol class=menu-social><li><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/page/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/page/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/page/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/zynq/>Zynq</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/axi4lite/>Axi4lite</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 24, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>9 minute read</time></div></footer></div></header><section class=article-content><h1 id=代码>代码</h1><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span><span class=lnt>273
</span><span class=lnt>274
</span><span class=lnt>275
</span><span class=lnt>276
</span><span class=lnt>277
</span><span class=lnt>278
</span><span class=lnt>279
</span><span class=lnt>280
</span><span class=lnt>281
</span><span class=lnt>282
</span><span class=lnt>283
</span><span class=lnt>284
</span><span class=lnt>285
</span><span class=lnt>286
</span><span class=lnt>287
</span><span class=lnt>288
</span><span class=lnt>289
</span><span class=lnt>290
</span><span class=lnt>291
</span><span class=lnt>292
</span><span class=lnt>293
</span><span class=lnt>294
</span><span class=lnt>295
</span><span class=lnt>296
</span><span class=lnt>297
</span><span class=lnt>298
</span><span class=lnt>299
</span><span class=lnt>300
</span><span class=lnt>301
</span><span class=lnt>302
</span><span class=lnt>303
</span><span class=lnt>304
</span><span class=lnt>305
</span><span class=lnt>306
</span><span class=lnt>307
</span><span class=lnt>308
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-verilog data-lang=verilog><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=no>`timescale</span> <span class=mh>1</span> <span class=n>ns</span> <span class=o>/</span> <span class=mh>1</span> <span class=n>ps</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>module</span> <span class=n>myip_slave_lite_v1_0_S00_AXI</span> <span class=p>#</span>
</span></span><span class=line><span class=cl>	<span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Users to add parameters here
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>// User parameters ends
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Do not modify the parameters beyond this line
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>// Width of S_AXI data bus
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>parameter</span> <span class=k>integer</span> <span class=n>C_S_AXI_DATA_WIDTH</span>	<span class=o>=</span> <span class=mh>32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Width of S_AXI address bus
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>parameter</span> <span class=k>integer</span> <span class=n>C_S_AXI_ADDR_WIDTH</span>	<span class=o>=</span> <span class=mh>4</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Users to add ports here
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>// User ports ends
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Do not modify the ports beyond this line
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>// Global Clock Signal
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span>  <span class=n>S_AXI_ACLK</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Global Reset Signal. This Signal is Active LOW
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span>  <span class=n>S_AXI_ARESETN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Write address (issued by master, acceped by Slave)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span> <span class=p>[</span><span class=n>C_S_AXI_ADDR_WIDTH</span><span class=o>-</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> <span class=n>S_AXI_AWADDR</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Write channel Protection type. This signal indicates the
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// privilege and security level of the transaction, and whether
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// the transaction is a data access or an instruction access.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span> <span class=p>[</span><span class=mh>2</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> <span class=n>S_AXI_AWPROT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Write address valid. This signal indicates that the master signaling
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// valid write address and control information.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span>  <span class=n>S_AXI_AWVALID</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Write address ready. This signal indicates that the slave is ready
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// to accept an address and associated control signals.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>output</span> <span class=kt>wire</span>  <span class=n>S_AXI_AWREADY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Write data (issued by master, acceped by Slave) 
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span> <span class=p>[</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>-</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> <span class=n>S_AXI_WDATA</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Write strobes. This signal indicates which byte lanes hold
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// valid data. There is one write strobe bit for each eight
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// bits of the write data bus.    
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span> <span class=p>[(</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>/</span><span class=mh>8</span><span class=p>)</span><span class=o>-</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> <span class=n>S_AXI_WSTRB</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Write valid. This signal indicates that valid write
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// data and strobes are available.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span>  <span class=n>S_AXI_WVALID</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Write ready. This signal indicates that the slave
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// can accept the write data.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>output</span> <span class=kt>wire</span>  <span class=n>S_AXI_WREADY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Write response. This signal indicates the status
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// of the write transaction.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>output</span> <span class=kt>wire</span> <span class=p>[</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> <span class=n>S_AXI_BRESP</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Write response valid. This signal indicates that the channel
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// is signaling a valid write response.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>output</span> <span class=kt>wire</span>  <span class=n>S_AXI_BVALID</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Response ready. This signal indicates that the master
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// can accept a write response.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span>  <span class=n>S_AXI_BREADY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Read address (issued by master, acceped by Slave)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span> <span class=p>[</span><span class=n>C_S_AXI_ADDR_WIDTH</span><span class=o>-</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> <span class=n>S_AXI_ARADDR</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Protection type. This signal indicates the privilege
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// and security level of the transaction, and whether the
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// transaction is a data access or an instruction access.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span> <span class=p>[</span><span class=mh>2</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> <span class=n>S_AXI_ARPROT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Read address valid. This signal indicates that the channel
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// is signaling valid read address and control information.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span>  <span class=n>S_AXI_ARVALID</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Read address ready. This signal indicates that the slave is
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// ready to accept an address and associated control signals.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>output</span> <span class=kt>wire</span>  <span class=n>S_AXI_ARREADY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Read data (issued by slave)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>output</span> <span class=kt>wire</span> <span class=p>[</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>-</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> <span class=n>S_AXI_RDATA</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Read response. This signal indicates the status of the
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// read transfer.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>output</span> <span class=kt>wire</span> <span class=p>[</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> <span class=n>S_AXI_RRESP</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Read valid. This signal indicates that the channel is
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// signaling the required read data.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>output</span> <span class=kt>wire</span>  <span class=n>S_AXI_RVALID</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Read ready. This signal indicates that the master can
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// accept the read data and response information.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>input</span> <span class=kt>wire</span>  <span class=n>S_AXI_RREADY</span>
</span></span><span class=line><span class=cl>	<span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// AXI4LITE signals
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>reg</span> <span class=p>[</span><span class=n>C_S_AXI_ADDR_WIDTH</span><span class=o>-</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> 	<span class=n>axi_awaddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span>  	<span class=n>axi_awready</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span>  	<span class=n>axi_wready</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span> <span class=p>[</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> 	<span class=n>axi_bresp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span>  	<span class=n>axi_bvalid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span> <span class=p>[</span><span class=n>C_S_AXI_ADDR_WIDTH</span><span class=o>-</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> 	<span class=n>axi_araddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span>  	<span class=n>axi_arready</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span> <span class=p>[</span><span class=mh>1</span> <span class=o>:</span> <span class=mh>0</span><span class=p>]</span> 	<span class=n>axi_rresp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span>  	<span class=n>axi_rvalid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Example-specific design signals
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// local parameter for addressing 32 bit / 64 bit C_S_AXI_DATA_WIDTH
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ADDR_LSB is used for addressing 32/64 bit registers/memories
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ADDR_LSB = 2 for 32 bits (n downto 2)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ADDR_LSB = 3 for 64 bits (n downto 3)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>localparam</span> <span class=k>integer</span> <span class=n>ADDR_LSB</span> <span class=o>=</span> <span class=p>(</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>/</span><span class=mh>32</span><span class=p>)</span> <span class=o>+</span> <span class=mh>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>localparam</span> <span class=k>integer</span> <span class=n>OPT_MEM_ADDR_BITS</span> <span class=o>=</span> <span class=mh>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>//----------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//-- Signals for user logic register space example
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//-- Number of Slave Registers 4
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>reg</span> <span class=p>[</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>-</span><span class=mh>1</span><span class=o>:</span><span class=mh>0</span><span class=p>]</span>	<span class=n>slv_reg0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span> <span class=p>[</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>-</span><span class=mh>1</span><span class=o>:</span><span class=mh>0</span><span class=p>]</span>	<span class=n>slv_reg1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span> <span class=p>[</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>-</span><span class=mh>1</span><span class=o>:</span><span class=mh>0</span><span class=p>]</span>	<span class=n>slv_reg2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>reg</span> <span class=p>[</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>-</span><span class=mh>1</span><span class=o>:</span><span class=mh>0</span><span class=p>]</span>	<span class=n>slv_reg3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>integer</span>	 <span class=n>byte_index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// I/O Connections assignments
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>assign</span> <span class=n>S_AXI_AWREADY</span>	<span class=o>=</span> <span class=n>axi_awready</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>assign</span> <span class=n>S_AXI_WREADY</span>	<span class=o>=</span> <span class=n>axi_wready</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>assign</span> <span class=n>S_AXI_BRESP</span>	<span class=o>=</span> <span class=n>axi_bresp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>assign</span> <span class=n>S_AXI_BVALID</span>	<span class=o>=</span> <span class=n>axi_bvalid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>assign</span> <span class=n>S_AXI_ARREADY</span>	<span class=o>=</span> <span class=n>axi_arready</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>assign</span> <span class=n>S_AXI_RRESP</span>	<span class=o>=</span> <span class=n>axi_rresp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>assign</span> <span class=n>S_AXI_RVALID</span>	<span class=o>=</span> <span class=n>axi_rvalid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	 <span class=c1>//state machine varibles 
</span></span></span><span class=line><span class=cl><span class=c1></span>	 <span class=kt>reg</span> <span class=p>[</span><span class=mh>1</span><span class=o>:</span><span class=mh>0</span><span class=p>]</span> <span class=n>state_write</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	 <span class=kt>reg</span> <span class=p>[</span><span class=mh>1</span><span class=o>:</span><span class=mh>0</span><span class=p>]</span> <span class=n>state_read</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	 <span class=c1>//State machine local parameters
</span></span></span><span class=line><span class=cl><span class=c1></span>	 <span class=k>localparam</span> <span class=n>Idle</span> <span class=o>=</span> <span class=mh>2</span><span class=mb>&#39;b00</span><span class=p>,</span><span class=n>Raddr</span> <span class=o>=</span> <span class=mh>2</span><span class=mb>&#39;b10</span><span class=p>,</span><span class=n>Rdata</span> <span class=o>=</span> <span class=mh>2</span><span class=mb>&#39;b11</span> <span class=p>,</span><span class=n>Waddr</span> <span class=o>=</span> <span class=mh>2</span><span class=mb>&#39;b10</span><span class=p>,</span><span class=n>Wdata</span> <span class=o>=</span> <span class=mh>2</span><span class=mb>&#39;b11</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Implement Write state machine
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Outstanding write transactions are not supported by the slave i.e., master should assert bready to receive response on or before it starts sending the new transaction
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>always</span> <span class=p>@(</span><span class=k>posedge</span> <span class=n>S_AXI_ACLK</span><span class=p>)</span>                                 
</span></span><span class=line><span class=cl>	  <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	     <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_ARESETN</span> <span class=o>==</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>)</span>                                 
</span></span><span class=line><span class=cl>	       <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	         <span class=n>axi_awready</span> <span class=o>&lt;=</span> <span class=mh>0</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	         <span class=n>axi_wready</span> <span class=o>&lt;=</span> <span class=mh>0</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	         <span class=n>axi_bvalid</span> <span class=o>&lt;=</span> <span class=mh>0</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	         <span class=n>axi_bresp</span> <span class=o>&lt;=</span> <span class=mh>0</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	         <span class=n>axi_awaddr</span> <span class=o>&lt;=</span> <span class=mh>0</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	         <span class=n>state_write</span> <span class=o>&lt;=</span> <span class=n>Idle</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	       <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	     <span class=k>else</span>                                  
</span></span><span class=line><span class=cl>	       <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	         <span class=k>case</span><span class=p>(</span><span class=n>state_write</span><span class=p>)</span>                                 
</span></span><span class=line><span class=cl>	           <span class=nl>Idle:</span>                                      
</span></span><span class=line><span class=cl>	             <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	               <span class=k>if</span><span class=p>(</span><span class=n>S_AXI_ARESETN</span> <span class=o>==</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>)</span>                                  
</span></span><span class=line><span class=cl>	                 <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	                   <span class=n>axi_awready</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                   <span class=n>axi_wready</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                   <span class=n>state_write</span> <span class=o>&lt;=</span> <span class=n>Waddr</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                 <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	               <span class=k>else</span> <span class=n>state_write</span> <span class=o>&lt;=</span> <span class=n>state_write</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	             <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	           <span class=nl>Waddr:</span>        <span class=c1>//At this state, slave is ready to receive address along with corresponding control signals and first data packet. Response valid is also handled at this state                                 
</span></span></span><span class=line><span class=cl><span class=c1></span>	             <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	               <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_AWVALID</span> <span class=o>&amp;&amp;</span> <span class=n>S_AXI_AWREADY</span><span class=p>)</span>                                 
</span></span><span class=line><span class=cl>	                  <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	                    <span class=n>axi_awaddr</span> <span class=o>&lt;=</span> <span class=n>S_AXI_AWADDR</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                    <span class=k>if</span><span class=p>(</span><span class=n>S_AXI_WVALID</span><span class=p>)</span>                                  
</span></span><span class=line><span class=cl>	                      <span class=k>begin</span>                                   
</span></span><span class=line><span class=cl>	                        <span class=n>axi_awready</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                        <span class=n>state_write</span> <span class=o>&lt;=</span> <span class=n>Waddr</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                        <span class=n>axi_bvalid</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                      <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	                    <span class=k>else</span>                                  
</span></span><span class=line><span class=cl>	                      <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	                        <span class=n>axi_awready</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                        <span class=n>state_write</span> <span class=o>&lt;=</span> <span class=n>Wdata</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                        <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_BREADY</span> <span class=o>&amp;&amp;</span> <span class=n>axi_bvalid</span><span class=p>)</span> <span class=n>axi_bvalid</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                      <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	                  <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	               <span class=k>else</span>                                  
</span></span><span class=line><span class=cl>	                  <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	                    <span class=n>state_write</span> <span class=o>&lt;=</span> <span class=n>state_write</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                    <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_BREADY</span> <span class=o>&amp;&amp;</span> <span class=n>axi_bvalid</span><span class=p>)</span> <span class=n>axi_bvalid</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                   <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	             <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	          <span class=nl>Wdata:</span>        <span class=c1>//At this state, slave is ready to receive the data packets until the number of transfers is equal to burst length                                 
</span></span></span><span class=line><span class=cl><span class=c1></span>	             <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	               <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_WVALID</span><span class=p>)</span>                                 
</span></span><span class=line><span class=cl>	                 <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	                   <span class=n>state_write</span> <span class=o>&lt;=</span> <span class=n>Waddr</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                   <span class=n>axi_bvalid</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                   <span class=n>axi_awready</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                 <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	                <span class=k>else</span>                                  
</span></span><span class=line><span class=cl>	                 <span class=k>begin</span>                                 
</span></span><span class=line><span class=cl>	                   <span class=n>state_write</span> <span class=o>&lt;=</span> <span class=n>state_write</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                   <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_BREADY</span> <span class=o>&amp;&amp;</span> <span class=n>axi_bvalid</span><span class=p>)</span> <span class=n>axi_bvalid</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>;</span>                                 
</span></span><span class=line><span class=cl>	                 <span class=k>end</span>                                              
</span></span><span class=line><span class=cl>	             <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	          <span class=k>endcase</span>                                 
</span></span><span class=line><span class=cl>	        <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>	      <span class=k>end</span>                                 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Implement memory mapped register select and write logic generation
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// The write data is accepted and written to memory mapped registers when
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// axi_awready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted. Write strobes are used to
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// select byte enables of slave registers while writing.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// These registers are cleared when reset (active low) is applied.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Slave register write enable is asserted when valid address and data are available
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// and the slave is ready to accept the write address and write data.
</span></span></span><span class=line><span class=cl><span class=c1></span>	 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>always</span> <span class=p>@(</span> <span class=k>posedge</span> <span class=n>S_AXI_ACLK</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>begin</span>
</span></span><span class=line><span class=cl>	  <span class=k>if</span> <span class=p>(</span> <span class=n>S_AXI_ARESETN</span> <span class=o>==</span> <span class=mh>1</span><span class=mb>&#39;b0</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>	    <span class=k>begin</span>
</span></span><span class=line><span class=cl>	      <span class=n>slv_reg0</span> <span class=o>&lt;=</span> <span class=mh>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	      <span class=n>slv_reg1</span> <span class=o>&lt;=</span> <span class=mh>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	      <span class=n>slv_reg2</span> <span class=o>&lt;=</span> <span class=mh>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	      <span class=n>slv_reg3</span> <span class=o>&lt;=</span> <span class=mh>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	    <span class=k>end</span> 
</span></span><span class=line><span class=cl>	  <span class=k>else</span> <span class=k>begin</span>
</span></span><span class=line><span class=cl>	    <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_WVALID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	      <span class=k>begin</span>
</span></span><span class=line><span class=cl>	        <span class=k>case</span> <span class=p>(</span> <span class=p>(</span><span class=n>S_AXI_AWVALID</span><span class=p>)</span> <span class=o>?</span> <span class=n>S_AXI_AWADDR</span><span class=p>[</span><span class=n>ADDR_LSB</span><span class=o>+</span><span class=nl>OPT_MEM_ADDR_BITS:</span><span class=n>ADDR_LSB</span><span class=p>]</span> <span class=o>:</span> <span class=n>axi_awaddr</span><span class=p>[</span><span class=n>ADDR_LSB</span><span class=o>+</span><span class=nl>OPT_MEM_ADDR_BITS:</span><span class=n>ADDR_LSB</span><span class=p>]</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>	          <span class=mh>2&#39;h0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	            <span class=k>for</span> <span class=p>(</span> <span class=n>byte_index</span> <span class=o>=</span> <span class=mh>0</span><span class=p>;</span> <span class=n>byte_index</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>/</span><span class=mh>8</span><span class=p>)</span><span class=o>-</span><span class=mh>1</span><span class=p>;</span> <span class=n>byte_index</span> <span class=o>=</span> <span class=n>byte_index</span><span class=o>+</span><span class=mh>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>	              <span class=k>if</span> <span class=p>(</span> <span class=n>S_AXI_WSTRB</span><span class=p>[</span><span class=n>byte_index</span><span class=p>]</span> <span class=o>==</span> <span class=mh>1</span> <span class=p>)</span> <span class=k>begin</span>
</span></span><span class=line><span class=cl>	                <span class=c1>// Respective byte enables are asserted as per write strobes 
</span></span></span><span class=line><span class=cl><span class=c1></span>	                <span class=c1>// Slave register 0
</span></span></span><span class=line><span class=cl><span class=c1></span>	                <span class=n>slv_reg0</span><span class=p>[(</span><span class=n>byte_index</span><span class=o>*</span><span class=mh>8</span><span class=p>)</span> <span class=o>+:</span> <span class=mh>8</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>S_AXI_WDATA</span><span class=p>[(</span><span class=n>byte_index</span><span class=o>*</span><span class=mh>8</span><span class=p>)</span> <span class=o>+:</span> <span class=mh>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	              <span class=k>end</span>  
</span></span><span class=line><span class=cl>	          <span class=mh>2&#39;h1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	            <span class=k>for</span> <span class=p>(</span> <span class=n>byte_index</span> <span class=o>=</span> <span class=mh>0</span><span class=p>;</span> <span class=n>byte_index</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>/</span><span class=mh>8</span><span class=p>)</span><span class=o>-</span><span class=mh>1</span><span class=p>;</span> <span class=n>byte_index</span> <span class=o>=</span> <span class=n>byte_index</span><span class=o>+</span><span class=mh>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>	              <span class=k>if</span> <span class=p>(</span> <span class=n>S_AXI_WSTRB</span><span class=p>[</span><span class=n>byte_index</span><span class=p>]</span> <span class=o>==</span> <span class=mh>1</span> <span class=p>)</span> <span class=k>begin</span>
</span></span><span class=line><span class=cl>	                <span class=c1>// Respective byte enables are asserted as per write strobes 
</span></span></span><span class=line><span class=cl><span class=c1></span>	                <span class=c1>// Slave register 1
</span></span></span><span class=line><span class=cl><span class=c1></span>	                <span class=n>slv_reg1</span><span class=p>[(</span><span class=n>byte_index</span><span class=o>*</span><span class=mh>8</span><span class=p>)</span> <span class=o>+:</span> <span class=mh>8</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>S_AXI_WDATA</span><span class=p>[(</span><span class=n>byte_index</span><span class=o>*</span><span class=mh>8</span><span class=p>)</span> <span class=o>+:</span> <span class=mh>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	              <span class=k>end</span>  
</span></span><span class=line><span class=cl>	          <span class=mh>2&#39;h2</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	            <span class=k>for</span> <span class=p>(</span> <span class=n>byte_index</span> <span class=o>=</span> <span class=mh>0</span><span class=p>;</span> <span class=n>byte_index</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>/</span><span class=mh>8</span><span class=p>)</span><span class=o>-</span><span class=mh>1</span><span class=p>;</span> <span class=n>byte_index</span> <span class=o>=</span> <span class=n>byte_index</span><span class=o>+</span><span class=mh>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>	              <span class=k>if</span> <span class=p>(</span> <span class=n>S_AXI_WSTRB</span><span class=p>[</span><span class=n>byte_index</span><span class=p>]</span> <span class=o>==</span> <span class=mh>1</span> <span class=p>)</span> <span class=k>begin</span>
</span></span><span class=line><span class=cl>	                <span class=c1>// Respective byte enables are asserted as per write strobes 
</span></span></span><span class=line><span class=cl><span class=c1></span>	                <span class=c1>// Slave register 2
</span></span></span><span class=line><span class=cl><span class=c1></span>	                <span class=n>slv_reg2</span><span class=p>[(</span><span class=n>byte_index</span><span class=o>*</span><span class=mh>8</span><span class=p>)</span> <span class=o>+:</span> <span class=mh>8</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>S_AXI_WDATA</span><span class=p>[(</span><span class=n>byte_index</span><span class=o>*</span><span class=mh>8</span><span class=p>)</span> <span class=o>+:</span> <span class=mh>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	              <span class=k>end</span>  
</span></span><span class=line><span class=cl>	          <span class=mh>2&#39;h3</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	            <span class=k>for</span> <span class=p>(</span> <span class=n>byte_index</span> <span class=o>=</span> <span class=mh>0</span><span class=p>;</span> <span class=n>byte_index</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=n>C_S_AXI_DATA_WIDTH</span><span class=o>/</span><span class=mh>8</span><span class=p>)</span><span class=o>-</span><span class=mh>1</span><span class=p>;</span> <span class=n>byte_index</span> <span class=o>=</span> <span class=n>byte_index</span><span class=o>+</span><span class=mh>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>	              <span class=k>if</span> <span class=p>(</span> <span class=n>S_AXI_WSTRB</span><span class=p>[</span><span class=n>byte_index</span><span class=p>]</span> <span class=o>==</span> <span class=mh>1</span> <span class=p>)</span> <span class=k>begin</span>
</span></span><span class=line><span class=cl>	                <span class=c1>// Respective byte enables are asserted as per write strobes 
</span></span></span><span class=line><span class=cl><span class=c1></span>	                <span class=c1>// Slave register 3
</span></span></span><span class=line><span class=cl><span class=c1></span>	                <span class=n>slv_reg3</span><span class=p>[(</span><span class=n>byte_index</span><span class=o>*</span><span class=mh>8</span><span class=p>)</span> <span class=o>+:</span> <span class=mh>8</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>S_AXI_WDATA</span><span class=p>[(</span><span class=n>byte_index</span><span class=o>*</span><span class=mh>8</span><span class=p>)</span> <span class=o>+:</span> <span class=mh>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	              <span class=k>end</span>  
</span></span><span class=line><span class=cl>	          <span class=k>default</span> <span class=o>:</span> <span class=k>begin</span>
</span></span><span class=line><span class=cl>	                      <span class=n>slv_reg0</span> <span class=o>&lt;=</span> <span class=n>slv_reg0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	                      <span class=n>slv_reg1</span> <span class=o>&lt;=</span> <span class=n>slv_reg1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	                      <span class=n>slv_reg2</span> <span class=o>&lt;=</span> <span class=n>slv_reg2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	                      <span class=n>slv_reg3</span> <span class=o>&lt;=</span> <span class=n>slv_reg3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	                    <span class=k>end</span>
</span></span><span class=line><span class=cl>	        <span class=k>endcase</span>
</span></span><span class=line><span class=cl>	      <span class=k>end</span>
</span></span><span class=line><span class=cl>	  <span class=k>end</span>
</span></span><span class=line><span class=cl>	<span class=k>end</span>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Implement read state machine
</span></span></span><span class=line><span class=cl><span class=c1></span>	  <span class=k>always</span> <span class=p>@(</span><span class=k>posedge</span> <span class=n>S_AXI_ACLK</span><span class=p>)</span>                                       
</span></span><span class=line><span class=cl>	    <span class=k>begin</span>                                       
</span></span><span class=line><span class=cl>	      <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_ARESETN</span> <span class=o>==</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>)</span>                                       
</span></span><span class=line><span class=cl>	        <span class=k>begin</span>                                       
</span></span><span class=line><span class=cl>	         <span class=c1>//asserting initial values to all 0&#39;s during reset                                       
</span></span></span><span class=line><span class=cl><span class=c1></span>	         <span class=n>axi_arready</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	         <span class=n>axi_rvalid</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	         <span class=n>axi_rresp</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	         <span class=n>state_read</span> <span class=o>&lt;=</span> <span class=n>Idle</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	        <span class=k>end</span>                                       
</span></span><span class=line><span class=cl>	      <span class=k>else</span>                                       
</span></span><span class=line><span class=cl>	        <span class=k>begin</span>                                       
</span></span><span class=line><span class=cl>	          <span class=k>case</span><span class=p>(</span><span class=n>state_read</span><span class=p>)</span>                                       
</span></span><span class=line><span class=cl>	            <span class=nl>Idle:</span>     <span class=c1>//Initial state inidicating reset is done and ready to receive read/write transactions                                       
</span></span></span><span class=line><span class=cl><span class=c1></span>	              <span class=k>begin</span>                                                
</span></span><span class=line><span class=cl>	                <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_ARESETN</span> <span class=o>==</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>)</span>                                        
</span></span><span class=line><span class=cl>	                  <span class=k>begin</span>                                       
</span></span><span class=line><span class=cl>	                    <span class=n>state_read</span> <span class=o>&lt;=</span> <span class=n>Raddr</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	                    <span class=n>axi_arready</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	                  <span class=k>end</span>                                       
</span></span><span class=line><span class=cl>	                <span class=k>else</span> <span class=n>state_read</span> <span class=o>&lt;=</span> <span class=n>state_read</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	              <span class=k>end</span>                                       
</span></span><span class=line><span class=cl>	            <span class=nl>Raddr:</span>        <span class=c1>//At this state, slave is ready to receive address along with corresponding control signals                                       
</span></span></span><span class=line><span class=cl><span class=c1></span>	              <span class=k>begin</span>                                       
</span></span><span class=line><span class=cl>	                <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_ARVALID</span> <span class=o>&amp;&amp;</span> <span class=n>S_AXI_ARREADY</span><span class=p>)</span>                                       
</span></span><span class=line><span class=cl>	                  <span class=k>begin</span>                                       
</span></span><span class=line><span class=cl>	                    <span class=n>state_read</span> <span class=o>&lt;=</span> <span class=n>Rdata</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	                    <span class=n>axi_araddr</span> <span class=o>&lt;=</span> <span class=n>S_AXI_ARADDR</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	                    <span class=n>axi_rvalid</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	                    <span class=n>axi_arready</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	                  <span class=k>end</span>                                       
</span></span><span class=line><span class=cl>	                <span class=k>else</span> <span class=n>state_read</span> <span class=o>&lt;=</span> <span class=n>state_read</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	              <span class=k>end</span>                                       
</span></span><span class=line><span class=cl>	            <span class=nl>Rdata:</span>        <span class=c1>//At this state, slave is ready to send the data packets until the number of transfers is equal to burst length                                       
</span></span></span><span class=line><span class=cl><span class=c1></span>	              <span class=k>begin</span>                                           
</span></span><span class=line><span class=cl>	                <span class=k>if</span> <span class=p>(</span><span class=n>S_AXI_RVALID</span> <span class=o>&amp;&amp;</span> <span class=n>S_AXI_RREADY</span><span class=p>)</span>                                       
</span></span><span class=line><span class=cl>	                  <span class=k>begin</span>                                       
</span></span><span class=line><span class=cl>	                    <span class=n>axi_rvalid</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b0</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	                    <span class=n>axi_arready</span> <span class=o>&lt;=</span> <span class=mh>1</span><span class=mb>&#39;b1</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	                    <span class=n>state_read</span> <span class=o>&lt;=</span> <span class=n>Raddr</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	                  <span class=k>end</span>                                       
</span></span><span class=line><span class=cl>	                <span class=k>else</span> <span class=n>state_read</span> <span class=o>&lt;=</span> <span class=n>state_read</span><span class=p>;</span>                                       
</span></span><span class=line><span class=cl>	              <span class=k>end</span>                                       
</span></span><span class=line><span class=cl>	           <span class=k>endcase</span>                                       
</span></span><span class=line><span class=cl>	          <span class=k>end</span>                                       
</span></span><span class=line><span class=cl>	        <span class=k>end</span>                                         
</span></span><span class=line><span class=cl>	<span class=c1>// Implement memory mapped register select and read logic generation
</span></span></span><span class=line><span class=cl><span class=c1></span>	  <span class=k>assign</span> <span class=n>S_AXI_RDATA</span> <span class=o>=</span> <span class=p>(</span><span class=n>axi_araddr</span><span class=p>[</span><span class=n>ADDR_LSB</span><span class=o>+</span><span class=nl>OPT_MEM_ADDR_BITS:</span><span class=n>ADDR_LSB</span><span class=p>]</span> <span class=o>==</span> <span class=mh>2&#39;h0</span><span class=p>)</span> <span class=o>?</span> <span class=n>slv_reg0</span> <span class=o>:</span> <span class=p>(</span><span class=n>axi_araddr</span><span class=p>[</span><span class=n>ADDR_LSB</span><span class=o>+</span><span class=nl>OPT_MEM_ADDR_BITS:</span><span class=n>ADDR_LSB</span><span class=p>]</span> <span class=o>==</span> <span class=mh>2&#39;h1</span><span class=p>)</span> <span class=o>?</span> <span class=n>slv_reg1</span> <span class=o>:</span> <span class=p>(</span><span class=n>axi_araddr</span><span class=p>[</span><span class=n>ADDR_LSB</span><span class=o>+</span><span class=nl>OPT_MEM_ADDR_BITS:</span><span class=n>ADDR_LSB</span><span class=p>]</span> <span class=o>==</span> <span class=mh>2&#39;h2</span><span class=p>)</span> <span class=o>?</span> <span class=n>slv_reg2</span> <span class=o>:</span> <span class=p>(</span><span class=n>axi_araddr</span><span class=p>[</span><span class=n>ADDR_LSB</span><span class=o>+</span><span class=nl>OPT_MEM_ADDR_BITS:</span><span class=n>ADDR_LSB</span><span class=p>]</span> <span class=o>==</span> <span class=mh>2&#39;h3</span><span class=p>)</span> <span class=o>?</span> <span class=n>slv_reg3</span> <span class=o>:</span> <span class=mh>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>	<span class=c1>// Add user logic here
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// User logic ends
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>endmodule</span>
</span></span></code></pre></td></tr></table></div></div></section><footer class=article-footer><section class=article-tags><a href=/tags/zynq/>Zynq</a>
<a href=/tags/axi4/>Axi4</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/zynq-xuartlite/><div class=article-details><h2 class=article-title>Zynq Xuartlite</h2></div></a></article><article><a href=/post/zynq-ps-port/><div class=article-details><h2 class=article-title>Zynq Ps Port</h2></div></a></article><article><a href=/post/%E4%BB%A5pwm%E4%B8%BA%E4%BE%8B%E5%AE%9E%E7%8E%B0axi%E7%9A%84ip%E5%B0%81%E8%A3%85/><div class=article-details><h2 class=article-title>以pwm为例实现axi的ip封装(created by gemini)</h2></div></a></article><article><a href=/post/zynq%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93/><div class=article-details><h2 class=article-title>Zynq文档总结</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 fusang blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.31.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>