[{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://demo.stack.jimmycai.com/post/hello-world/cover_hu_e95a4276bf860a84.jpg","permalink":"https://demo.stack.jimmycai.com/post/hello-world/","title":"Hello World"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include \u0026#34;xil_io.h\u0026#34; #include \u0026#34;xparameters.h\u0026#34; #include \u0026#34;xparameters_ps.h\u0026#34; #include \u0026#34;xil_printf.h\u0026#34; #include \u0026#34;xgpio.h\u0026#34; #include \u0026#34;xgpiops.h\u0026#34; #include \u0026#34;xuartps.h\u0026#34; #include \u0026#34;xuartps_hw.h\u0026#34; void PL_SW_INIT(); void PS_GPIO_INIT(); void delay_1s(); void led_on_off(u32 on); void uart_init(); XGpio pl_sw; XGpioPs ps_gpio; XGpioPs_Config ps_gpio_config; XUartPs uart; XUartPs_Config uart_config; void main() { print(\u0026#34;hello world\\n\u0026#34;); PL_SW_INIT(); PS_GPIO_INIT(); u32 pin12,pin13,pin14,pin15,pin47; u32 sw_cur,sw_last=0; u32 pl_sw_state; XGpio_DiscreteSet(\u0026amp;pl_sw,2,0xff); while(1) { /* led_on_off(1); delay_1s(); led_on_off(0); delay_1s();*/ pl_sw_state=XGpio_DiscreteRead(\u0026amp;pl_sw,1); XGpio_DiscreteWrite(\u0026amp;pl_sw,2,pl_sw_state); pin12=XGpioPs_ReadPin(\u0026amp;ps_gpio, 12); pin13=XGpioPs_ReadPin(\u0026amp;ps_gpio, 13); pin14=XGpioPs_ReadPin(\u0026amp;ps_gpio, 14); pin15=XGpioPs_ReadPin(\u0026amp;ps_gpio, 15); pin47=XGpioPs_ReadPin(\u0026amp;ps_gpio, 47); XGpioPs_WritePin(\u0026amp;ps_gpio, 7, pin47); XGpioPs_WritePin(\u0026amp;ps_gpio, 8, pin12); XGpioPs_WritePin(\u0026amp;ps_gpio, 9, pin14); XGpioPs_WritePin(\u0026amp;ps_gpio, 10, pin15); XGpioPs_WritePin(\u0026amp;ps_gpio, 11, pin13); sw_cur=XGpio_DiscreteRead(\u0026amp;pl_sw, 1); /* if(sw_cur\u0026amp;0x1==0x1) { led_on_off(1); } else { led_on_off(0); }*/ if(sw_cur!=sw_last) { xil_printf(\u0026#34;pl key is %x\\n\u0026#34;,sw_cur); sw_last=sw_cur; } } } void PL_SW_INIT() { //初始化结构体 XGpio_Initialize(\u0026amp;pl_sw, XPAR_AXI_GPIO_1_BASEADDR); //设置通道1，8位为输入模式 XGpio_SetDataDirection(\u0026amp;pl_sw, 1,0xff);//1输入，0输出 XGpio_SetDataDirection(\u0026amp;pl_sw, 2,0); } void PS_GPIO_INIT() { XGpioPs_CfgInitialize(\u0026amp;ps_gpio, \u0026amp;ps_gpio_config,XPAR_XGPIOPS_0_BASEADDR); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 12, 0);//0输入，1输出 XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 13, 0); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 14, 0); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 15, 0); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 47, 0); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 7, 1); XGpioPs_SetOutputEnablePin(\u0026amp;ps_gpio,7,1); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 8, 1); XGpioPs_SetOutputEnablePin(\u0026amp;ps_gpio,8,1); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 9, 1); XGpioPs_SetOutputEnablePin(\u0026amp;ps_gpio,9,1); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 10, 1); XGpioPs_SetOutputEnablePin(\u0026amp;ps_gpio,10,1); XGpioPs_SetDirectionPin(\u0026amp;ps_gpio, 11, 1); XGpioPs_SetOutputEnablePin(\u0026amp;ps_gpio,11,1); } void delay_1s() { for(int i=0;i\u0026lt;1000000;i++) for(int j=0;j\u0026lt;100;j++); } void led_on_off(u32 on) { XGpioPs_WritePin(\u0026amp;ps_gpio, 7, on); XGpioPs_WritePin(\u0026amp;ps_gpio, 8, on); XGpioPs_WritePin(\u0026amp;ps_gpio, 9, on); XGpioPs_WritePin(\u0026amp;ps_gpio, 10, on); XGpioPs_WritePin(\u0026amp;ps_gpio, 11, on); } void uart_init() { XUartPs_CfgInitialize(\u0026amp;uart,\u0026amp;uart_config,XPS_UART1_BASEADDR); XUartPs_SetBaudRate(\u0026amp;uart,115200); } ","date":"2025-11-01T15:51:42+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq-gpio/","title":"Zynq Gpio"},{"content":"vitis code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026#34;xparameters.h\u0026#34; #include \u0026#34;xspi.h\u0026#34; #include \u0026#34;xspi_i.h\u0026#34; #include \u0026#34;xspi_l.h\u0026#34; #include \u0026#34;xil_io.h\u0026#34; #include \u0026#34;sleep.h\u0026#34; XSpi spi_dac; u8 dac_send[2]; u8 dac_recv[2]={0}; // spi_dac:CPOL=1;CPHA=0 u32 dac_option=XSP_MASTER_OPTION|XSP_CLK_ACTIVE_LOW_OPTION|XSP_MANUAL_SSELECT_OPTION; //u32 dac_option=XSP_MASTER_OPTION|XSP_CLK_ACTIVE_LOW_OPTION; int main(void){ XSpi_Initialize(\u0026amp;spi_dac, XPAR_DAC_SPI_BASEADDR); XSpi_SetOptions(\u0026amp;spi_dac, dac_option); XSpi_Start(\u0026amp;spi_dac); while(1){ sleep(1); XSpi_SetSlaveSelect(\u0026amp;spi_dac,0x01); //XSpi_SetSlaveSelectReg(\u0026amp;spi_dac, 0x01); u16 dac_mode=(0x00); u16 dac_value=1000; u16 dac_data=dac_value|(dac_mode \u0026lt;\u0026lt;12); dac_send[0]=dac_data\u0026gt;\u0026gt;8; dac_send[1]=dac_data\u0026amp;0xff; XSpi_Transfer(\u0026amp;spi_dac, dac_send, dac_recv,2); XSpi_SetSlaveSelect(\u0026amp;spi_dac,0x00); //XSpi_SetSlaveSelectReg(\u0026amp;spi_dac, 0x00); sleep(1); XSpi_SetSlaveSelect(\u0026amp;spi_dac,0x01); //XSpi_SetSlaveSelectReg(\u0026amp;spi_dac, 0x01); dac_mode=(0x00); dac_value=0; dac_data=dac_value|(dac_mode \u0026lt;\u0026lt;12); dac_send[0]=dac_data\u0026gt;\u0026gt;8; dac_send[1]=dac_data\u0026amp;0xff; XSpi_Transfer(\u0026amp;spi_dac, dac_send, dac_recv,2); XSpi_SetSlaveSelect(\u0026amp;spi_dac,0x00); //XSpi_SetSlaveSelectReg(\u0026amp;spi_dac, 0x00); } } 总结 烦的第一大错误：忘记在vivado中设置ddr ","date":"2025-11-01T14:41:55+08:00","permalink":"https://demo.stack.jimmycai.com/post/spi-dac/","title":"Spi Dac"},{"content":"generate for generate for 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module generate_for1( input logic clk, input logic in, output logic [3:0]out ); genvar i; generate for(i=1;i\u0026lt;=3;i=i+1) begin always_ff@(posedge clk) begin out[0]\u0026lt;=in; out[i]\u0026lt;=out[i-1]; end end endgenerate endmodule generate for2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module generate_for1( input logic clk, input logic in, output logic [3:0]out ); genvar i; generate for(i=0;i\u0026lt;=3;i=i+1) begin always_ff@(posedge clk) begin //out[0]\u0026lt;=in; out[i]\u0026lt;=out[i-1]; end end endgenerate endmodule 草率了，忘记数组不能负索引了，但是负索引竟然可以综合\ngenerate for3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module generate_for1( input logic clk, input logic in, output logic [3:0]out ); genvar i; generate for(i=1;i\u0026lt;=3;i=i+1) begin always_ff@(posedge clk) begin //out[0]\u0026lt;=in; out[i]\u0026lt;=out[i-1]; end always_ff@(posedge clk) begin out[0]\u0026lt;=in; end end endgenerate endmodule generate for 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 module generate_for1( input logic clk, input logic in, output logic [3:0]out ); genvar i; generate for(i=1;i\u0026lt;=3;i=i+1) begin always_ff@(posedge clk) begin //out[0]\u0026lt;=in; out[i]\u0026lt;=out[i-1]; end end endgenerate always_ff@(posedge clk) begin out[0]\u0026lt;=in; end endmodule for for1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module for1( input logic clk, input logic in, output logic [3:0]out ); integer i; always_ff@(posedge clk) begin out[0]\u0026lt;=in; for(i=1;i\u0026lt;=3;i=i+1) begin out[i]\u0026lt;=out[i-1]; end end endmodule for2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module for1( input logic clk, input logic in, output logic [3:0]out ); integer i; always_ff@(posedge clk) begin out[0]\u0026lt;=in; for(i=0;i\u0026lt;=3;i=i+1) begin out[i]\u0026lt;=out[i-1]; end end endmodule 草率了，忘记数组不能负索引了，但是负索引竟然可以综合\n","date":"2025-10-29T15:50:08+08:00","permalink":"https://demo.stack.jimmycai.com/post/generate-for/","title":"Generate For vs. For"},{"content":"下面我为你总结一套工业级、学术界都广泛使用的Matplotlib作图“套路”，以及与之配合的NumPy常用函数。这套流程能覆盖你80%以上的作图需求，并让你的图表清晰、美观、信息量丰富。\n核心理念：“面向对象”的作图范式 忘掉零散的plt.plot()、plt.title()。从现在开始，拥抱“Figure与Axes”的面向对象范式。这是最重要的一步。\n基本模板（所有作图的起点）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import matplotlib.pyplot as plt import numpy as np # --- 1. 创建画布(Figure)和子图(Axes) --- # fig是整个画布，ax是具体的绘图区域 # nrows=1, ncols=1 表示创建一个1x1的网格，即只有一个子图 fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(10, 6)) # figsize控制画布大小 # --- 2. 在Axes上绘图 --- # 所有绘图操作都通过ax对象完成，而不是plt # x_data, y_data = ... (你的数据) # ax.plot(x_data, y_data, label=\u0026#39;My Data\u0026#39;) # --- 3. 精细化定制Axes --- ax.set_title(\u0026#34;This is the Title\u0026#34;, fontsize=16) ax.set_xlabel(\u0026#34;X-axis Label\u0026#34;, fontsize=12) ax.set_ylabel(\u0026#34;Y-axis Label\u0026#34;, fontsize=12) ax.grid(True, linestyle=\u0026#39;--\u0026#39;, alpha=0.6) # 添加网格线 ax.legend(fontsize=10) # 显示图例 # --- 4. 调整布局并显示 --- plt.tight_layout() # 自动调整子图参数，使之填充整个图像区域 plt.show() 记住这个模板，你就掌握了套路的精髓。\nNumPy \u0026amp; Matplotlib 常用函数与作图套路 下面我将作图需求分为几大类，每一类都提供一个“套路”和相关的常用函数。\n套路一：单线/多线对比图 (最常用) 场景：对比滤波前后的信号、不同参数下的模型性能、理论值与实际值。\n流程：\n用np.linspace或np.arange创建统一的X轴数据。 在同一个ax对象上多次调用plot()。 通过label参数区分不同曲线，最后用ax.legend()显示图例。 代码范例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # --- 数据准备 (NumPy) --- fs = 1000 t = np.linspace(0, 1, fs, endpoint=False) # 0到1秒的时间轴 signal_clean = np.sin(2 * np.pi * 5 * t) noise = 0.5 * np.random.randn(len(t)) signal_noisy = signal_clean + noise # --- Matplotlib 套路 --- fig, ax = plt.subplots(figsize=(12, 6)) ax.plot(t, signal_noisy, label=\u0026#39;Noisy Signal\u0026#39;, color=\u0026#39;blue\u0026#39;, alpha=0.5) ax.plot(t, signal_clean, label=\u0026#39;Clean Signal\u0026#39;, color=\u0026#39;red\u0026#39;, linewidth=2, linestyle=\u0026#39;-\u0026#39;) # 精细化控制 ax.set_title(\u0026#34;Comparison of Signals\u0026#34;) ax.set_xlabel(\u0026#34;Time [s]\u0026#34;) ax.set_ylabel(\u0026#34;Amplitude\u0026#34;) ax.set_xlim(0, 0.5) # 常用：放大X轴的某个区域 ax.grid(True) ax.legend() plt.tight_layout() plt.show() 常用NumPy函数：\nnp.linspace(start, stop, num): 创建等差数列，常用于时间轴或平滑的X轴。 np.arange(start, stop, step): 按步长创建数组，常用于离散序列。 np.sin, np.cos, np.exp: 生成各种数学函数波形。 np.random.randn(size): 生成标准正态分布（高斯）噪声。 套路二：多子图布局 (信息维度扩展) 场景：同时展示时域和频域、输入和输出、多个实验结果。\n流程：\n在plt.subplots()中指定nrows和ncols。 subplots会返回一个**axes数组**。通过索引（如ax[0], ax[1]或ax[0, 1]）来选择要在哪个子图上绘图。 可以设置sharex=True或sharey=True来共享坐标轴，使对比更直观。 代码范例 (时域 vs 频域)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from scipy.fft import fft, fftfreq # --- 数据准备 (NumPy \u0026amp; SciPy) --- fs = 1000 t = np.linspace(0, 1, fs, endpoint=False) signal = np.sin(2 * np.pi * 50 * t) + 0.5 * np.sin(2 * np.pi * 120 * t) # FFT计算 N = len(signal) yf = fft(signal) xf = fftfreq(N, 1 / fs)[:N//2] # 获取频率轴 # --- Matplotlib 套路 (1行2列) --- fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(10, 8), sharex=False) # 在第一个子图 (axes[0]) 上画时域图 axes[0].plot(t, signal) axes[0].set_title(\u0026#34;Time Domain\u0026#34;) axes[0].set_xlabel(\u0026#34;Time [s]\u0026#34;) axes[0].set_ylabel(\u0026#34;Amplitude\u0026#34;) axes[0].grid(True) axes[0].set_xlim(0, 0.2) # 在第二个子图 (axes[1]) 上画频域图 axes[1].plot(xf, 2.0/N * np.abs(yf[0:N//2])) axes[1].set_title(\u0026#34;Frequency Domain (FFT)\u0026#34;) axes[1].set_xlabel(\u0026#34;Frequency [Hz]\u0026#34;) axes[1].set_ylabel(\u0026#34;Amplitude\u0026#34;) axes[1].grid(True) axes[1].set_xlim(0, 200) plt.tight_layout() plt.show() 套路三：数据分布与统计图 (直方图/散点图) 场景：分析噪声分布、变量之间的相关性。\n流程：\n直方图使用ax.hist()，可以直观地看到数据分布的形状。 散点图使用ax.scatter()，用于观察两个变量之间的关系。 代码范例 (直方图)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # --- 数据准备 (NumPy) --- # 生成均值为5，标准差为2的高斯分布数据 data = 5 + 2 * np.random.randn(1000) # --- Matplotlib 套路 --- fig, ax = plt.subplots(figsize=(8, 5)) # bins控制柱子的数量，density=True表示归一化为概率密度 ax.hist(data, bins=30, density=True, alpha=0.7, label=\u0026#39;Histogram\u0026#39;) # 常用：在直方图上叠加理论分布曲线 from scipy.stats import norm xmin, xmax = plt.xlim() x = np.linspace(xmin, xmax, 100) p = norm.pdf(x, 5, 2) # 理论概率密度函数 ax.plot(x, p, \u0026#39;k\u0026#39;, linewidth=2, label=\u0026#39;Theoretical PDF\u0026#39;) ax.set_title(\u0026#34;Data Distribution\u0026#34;) ax.set_xlabel(\u0026#34;Value\u0026#34;) ax.set_ylabel(\u0026#34;Density\u0026#34;) ax.legend() ax.grid(True) plt.tight_layout() plt.show() 常用NumPy函数：\nnp.mean(data), np.std(data): 计算均值和标准差。 np.random.rand(size): [0, 1)均匀分布。 np.corrcoef(x, y): 计算相关系数矩阵。 套路四：添加辅助线与注释 (让图表“说话”) 场景：标记阈值、截止频率、特定事件点、理论极限。\n流程：\nax.axvline(): 画垂直线。 ax.axhline(): 画水平线。 ax.axvspan(): 垂直区域着色。 ax.text() 或 ax.annotate(): 添加文字注释。 代码范例 (频率响应图标注)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 假设 freq_hz, magnitude_db 是频率响应数据 # ... fig, ax = plt.subplots(figsize=(10, 6)) ax.plot(freq_hz, magnitude_db) ax.set_title(\u0026#34;Filter Frequency Response\u0026#34;) ax.set_xlabel(\u0026#34;Frequency [Hz]\u0026#34;) ax.set_ylabel(\u0026#34;Magnitude [dB]\u0026#34;) # --- 添加辅助线 --- cutoff_freq = 50 # 标记-3dB线（半功率点） ax.axhline(-3, color=\u0026#39;red\u0026#39;, linestyle=\u0026#39;--\u0026#39;, label=\u0026#39;-3 dB Cutoff\u0026#39;) # 标记名义截止频率 ax.axvline(cutoff_freq, color=\u0026#39;green\u0026#39;, linestyle=\u0026#39;:\u0026#39;, label=f\u0026#39;Nominal Cutoff = {cutoff_freq} Hz\u0026#39;) # 标记通带区域 ax.axvspan(0, 40, color=\u0026#39;gray\u0026#39;, alpha=0.2, label=\u0026#39;Passband Region\u0026#39;) ax.set_ylim(-60, 5) ax.grid(True) ax.legend() plt.tight_layout() plt.show() 总结：你的“作图武器库” 需求分类 核心Matplotlib函数 常用NumPy函数 套路精髓 基础框架 fig, ax = plt.subplots() np.array 面向对象，分离画布与绘图区 曲线对比 ax.plot(), ax.legend() np.linspace, np.arange 同一ax多次plot，用label区分 多维展示 plt.subplots(nrows, ncols) fft (from scipy) 索引axes数组，用sharex/y联动 数据分布 ax.hist(), ax.scatter() np.random, np.mean, np.std 选择合适的图表类型展示数据内在结构 信息高亮 ax.axvline, ax.axhline, ax.axvspan - 用辅助线和注释引导读者关注重点 全局美化 plt.tight_layout() - 自动调整布局，防止标签重叠 将这套流程和范例代码保存在你的笔记中，每次作图时，先思考你的“故事”需要哪种套路，然后填充数据和细节。很快，你就能随心所欲地创作出专业且富有洞察力的图表了。\n","date":"2025-10-27T16:23:21+08:00","permalink":"https://demo.stack.jimmycai.com/post/matplotlib_numpy/","title":"Matplotlib_numpy(created by gemini)"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 //通过串口输入数字点亮对应的小灯 #include \u0026#34;xparameters.h\u0026#34; #include \u0026#34;xuartlite.h\u0026#34; #include \u0026#34;xuartlite_l.h\u0026#34; #include \u0026#34;xil_io.h\u0026#34; #include \u0026#34;xil_printf.h\u0026#34; #include \u0026lt;xil_types.h\u0026gt; #include \u0026#34;xgpio.h\u0026#34; XUartLite puart_lite; XGpio pl_sw; void PL_SW_INIT(); u8 status; u8 recv_package[8]; u8 send_package[8]={\u0026#39;i\u0026#39;,\u0026#39;n\u0026#39;}; u8 count; int main() { PL_SW_INIT(); XUartLite_Initialize(\u0026amp;puart_lite,XPAR_XUARTLITE_0_BASEADDR); XGpio_DiscreteSet(\u0026amp;pl_sw,2,0); XUartLite_Send(\u0026amp;puart_lite,send_package,2); while(1) { count=0; XUartLite_Send(\u0026amp;puart_lite,send_package,2); //XUartLite_Recv(\u0026amp;puart_lite,recv_package,2); //while (count\u0026lt;2) //{ // if(count==0){XUartLite_Recv(\u0026amp;puart_lite,recv_package,2);}} // if(count==1){XUartLite_Recv(\u0026amp;puart_lite,recv_package,1);} // XUartLite_Send(\u0026amp;puart_lite,recv_package,2); // 等待并接收第一个字节 recv_package[0] = XUartLite_RecvByte(XPAR_XUARTLITE_0_BASEADDR); // 等待并接收第二个字节 recv_package[1] = XUartLite_RecvByte(XPAR_XUARTLITE_0_BASEADDR); //XUartLite_Send(\u0026amp;puart_lite,recv_package,2); u32 led_control=10*(recv_package[0]-\u0026#39;0\u0026#39;)+(recv_package[1]-\u0026#39;0\u0026#39;); //xil_printf(\u0026#34;%u\u0026#34;,led_control); XGpio_DiscreteWrite(\u0026amp;pl_sw,2,0); XGpio_DiscreteWrite(\u0026amp;pl_sw,2,led_control); //XUartLite_Send(\u0026amp;puart_lite,recv_package,2); //XUartLite_Send(\u0026amp;puart_lite,send_package,2); } } void PL_SW_INIT() { //初始化结构体 XGpio_Initialize(\u0026amp;pl_sw, XPAR_AXI_GPIO_1_BASEADDR); //设置通道1，8位为输入模式 XGpio_SetDataDirection(\u0026amp;pl_sw, 1,0xff);//1输入，0输出 XGpio_SetDataDirection(\u0026amp;pl_sw, 2,0); } ","date":"2025-10-25T14:33:53+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq-xuartlite/","title":"Zynq Xuartlite"},{"content":"zynq有着完备以及强大的文档辅助学习，本文将记录阅读过的zynq文档，简单评价或是剖析精彩的章节\nUG585-Zynq 7000 SoC Technical Reference Manual UG585\n当之无愧最重要的文档\n","date":"2025-10-24T23:56:42+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93/","title":"Zynq文档总结"},{"content":"Vivado 中的约束（Constraints）主要通过 Xilinx Design Constraints (XDC) 文件来定义，其语法基于 Tcl（Tool Command Language），并扩展了用于时序、管脚分配、物理约束等的专用命令。以下是 Vivado 约束的基本语法和常用命令分类：\n1. 管脚分配（Pin Assignment） 指定顶层模块端口对应的 FPGA 引脚：\n1 2 set_property PACKAGE_PIN \u0026lt;pin_name\u0026gt; [get_ports \u0026lt;port_name\u0026gt;] set_property IOSTANDARD LVCMOS33 [get_ports \u0026lt;port_name\u0026gt;] 示例：\n1 2 set_property PACKAGE_PIN D18 [get_ports clk] set_property IOSTANDARD LVCMOS33 [get_ports clk] 2. 时钟约束（Clock Constraints） 定义主时钟、生成时钟或虚拟时钟。\n主时钟（Primary Clock）： 1 create_clock -name \u0026lt;clk_name\u0026gt; -period \u0026lt;period_ns\u0026gt; [get_ports \u0026lt;port_name\u0026gt;] 示例（100 MHz 时钟）：\n1 create_clock -name sys_clk -period 10.000 [get_ports clk] 生成时钟（Generated Clock）： 用于 PLL/MMCM 输出或分频/倍频时钟：\n1 create_generated_clock -name \u0026lt;gen_clk_name\u0026gt; -source [get_pins \u0026lt;source_pin\u0026gt;] -divide_by \u0026lt;N\u0026gt; [get_pins \u0026lt;output_pin\u0026gt;] 示例（2 分频）：\n1 create_generated_clock -name clk_div2 -source [get_pins clk] -divide_by 2 [get_pins clk_div2_reg/Q] 3. 输入/输出延迟约束（I/O Delay） 用于指定外部器件与 FPGA 之间的时序关系。\n输入延迟： 1 set_input_delay -clock \u0026lt;clk_name\u0026gt; \u0026lt;delay_ns\u0026gt; [get_ports \u0026lt;input_port\u0026gt;] 输出延迟： 1 set_output_delay -clock \u0026lt;clk_name\u0026gt; \u0026lt;delay_ns\u0026gt; [get_ports \u0026lt;output_port\u0026gt;] 示例：\n1 2 set_input_delay -clock sys_clk 2.0 [get_ports data_in] set_output_delay -clock sys_clk 1.5 [get_ports data_out] 4. 时序例外（Timing Exceptions） 用于覆盖默认时序分析，如多周期路径、伪路径等。\n伪路径（False Path）： 1 set_false_path -from [get_pins \u0026lt;start_point\u0026gt;] -to [get_pins \u0026lt;end_point\u0026gt;] 或针对端口：\n1 set_false_path -from [get_ports async_in] 多周期路径（Multicycle Path）： 1 2 set_multicycle_path \u0026lt;num_cycles\u0026gt; -setup -from [get_clocks clk1] -to [get_clocks clk2] set_multicycle_path \u0026lt;num_cycles\u0026gt; -hold -from [get_clocks clk1] -to [get_clocks clk2] 5. 物理约束（Physical Constraints） 如区域约束（Pblock）、布局锁定等（较少在 XDC 中直接写，但支持）：\n1 set_property LOC SLICE_X10Y20 [get_cells my_reg] 注意事项： 顺序敏感：XDC 文件按顺序执行，后面的约束可能覆盖前面的。 对象获取：常用 [get_ports ...]、[get_pins ...]、[get_cells ...]、[get_clocks ...] 来定位设计对象。 单位：时间单位默认为纳秒（ns），可省略。 注释：使用 # 开头。 示例完整 XDC 片段： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Clock create_clock -name clk -period 10.000 [get_ports clk] # Pin assignment set_property PACKAGE_PIN E3 [get_ports clk] set_property IOSTANDARD LVCMOS33 [get_ports clk] set_property PACKAGE_PIN D9 [get_ports reset_n] set_property IOSTANDARD LVCMOS33 [get_ports reset_n] # Input delay set_input_delay -clock clk 2.0 [get_ports data_in] # False path for async reset set_false_path -from [get_ports reset_n] 如果你正在编写状态机并关注复位信号（如 rst），通常建议：\n若为同步复位，无需特殊约束； 若为异步复位，需用 set_false_path 或 set_input_delay 明确其时序不参与分析，或使用 create_clock + set_false_path 组合处理。 需要更具体的约束示例（比如针对你的状态机复位）可以告诉我。\n","date":"2025-10-24T20:19:58+08:00","permalink":"https://demo.stack.jimmycai.com/post/vivado-constraint/","title":"Vivado Constraint(created by gemini)"},{"content":"zynq ps端有一圈信号端口，本文将逐一拆解\n","date":"2025-10-24T19:59:11+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq-ps-port/","title":"Zynq Ps Port"},{"content":"好的，这是一个关于 fzf、fd 和 rg 这三个现代命令行神器（俗称“命令行三剑客”）的用法梗概。它们各自独立时已经非常强大，但组合使用更能发挥出惊人的效率。\n核心思想 fd: 替代 find，用来 找文件。 rg (ripgrep): 替代 grep，用来 找文件内容。 fzf (fuzzy finder): 模糊搜索器，用来 从列表中交互式地选择。 它们的共同优点是：快、智能、用户友好。\n1. fzf - 命令行模糊搜索器 一句话总结：一个交互式的过滤器，可以从任何文本输入中快速筛选并选择一项或多项。\nfzf 是这三者中的“粘合剂”，能与各种命令无缝配合。\n核心功能 模糊匹配：你不需要输入完整的词，只需输入几个关键字母，它就能找到匹配项。 交互式界面：实时反馈，上下键选择，回车确认。 高度可定制：可以自定义外观、快捷键和预览窗口。 与 Shell 深度集成：可以极大地增强 Ctrl+R（历史命令搜索）、Ctrl+T（文件路径补全）等功能。 常用场景与示例 基础用法：查找当前目录下的文件 直接运行 fzf，它会列出所有文件和目录，你可以模糊搜索并按回车，它会将你选择的文件名输出到标准输出。\n1 fzf 增强命令历史搜索 (Ctrl+R) 这是 fzf 最受欢迎的功能。安装后，按 Ctrl+R 会调出 fzf 的交互式历史记录搜索界面，比默认的好用一万倍。\n查找文件并用 Vim 打开 结合命令替换 $(...) 或反引号 `...`。\n1 2 3 4 5 # 查找文件，然后用 vim 打开选中的那个 vim $(fzf) # 查找并选择多个文件打开 vim $(fzf --multi) 作为管道中的过滤器 fzf 可以处理任何通过管道 (|) 传给它的文本。\n1 2 3 4 5 # 从 ps 结果中选择一个进程并结束它 ps -ef | fzf | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 # 模糊搜索并切换 git 分支 git branch | fzf | xargs git checkout 2. fd - 一个更简单、更快速的 find 一句话总结：一个为人类设计的、默认配置极佳的找文件工具。\nfd 在功能上与 find 类似，但语法更简洁，速度更快。\n核心功能 语法简单：fd \u0026lt;模式\u0026gt; 即可，不像 find 需要复杂的 -name 等参数。 智能忽略：默认忽略 .gitignore 中定义的文件、隐藏文件和目录。这在项目开发中非常有用。 速度极快：利用并行处理，搜索速度通常比 find 快得多。 彩色输出：结果按文件类型着色，一目了然。 常用场景与示例 基础用法：查找包含 \u0026ldquo;report\u0026rdquo; 的文件\n1 2 3 4 # 在当前目录及子目录中查找 fd report # 相当于 find . -iname \u0026#34;*report*\u0026#34; 按扩展名查找\n1 2 3 4 5 # 查找所有的 markdown 文件 fd -e md # 查找所有的 jpg 或 png 文件 fd -e jpg -e png 按文件类型查找\n1 2 3 4 5 6 7 8 # 只查找目录 fd -t d # 只查找文件 fd -t f # 只查找符号链接 fd -t l 执行命令 -x 或 --exec 参数可以对每个搜索结果执行一个命令。{} 是占位符，代表找到的文件路径。\n1 2 3 4 5 6 # 查找所有 zip 文件并解压 fd -e zip -x unzip {} # 批量修改文件名（将 .jpeg 改为 .jpg） fd -e jpeg -x mv {} {.}.jpg # {.}` 代表不含扩展名的路径 覆盖智能忽略 如果你想搜索隐藏文件或被 .gitignore 忽略的文件：\n1 2 3 # --hidden: 搜索隐藏文件 # --no-ignore: 不使用 .gitignore 规则 fd --hidden --no-ignore \u0026#39;^\\.bash\u0026#39; 3. rg (ripgrep) - 一个超快的 grep 一句话总结：一个专注于速度和易用性的代码内容搜索工具。\nrg 同样默认尊重 .gitignore，并且会自动跳过二进制文件，是程序员日常搜索代码的利器。\n核心功能 速度极快：通常是 grep 或 ag (The Silver Searcher) 中最快的。 智能忽略：和 fd 一样，默认忽略 .gitignore 和隐藏文件。 优秀输出：彩色高亮、显示行号、自动分组。 跨平台：在 Windows, macOS, Linux 上表现同样出色。 常用场景与示例 基础用法：在当前目录搜索字符串\n1 2 # 搜索包含 \u0026#34;main\u0026#34; 的所有行 rg main 不区分大小写搜索\n1 rg -i \u0026#34;error\u0026#34; (rg 默认使用智能大小写：如果你的搜索词全小写，它就不区分大小写；如果包含大写，它就精确匹配。)\n仅列出包含匹配项的文件名\n1 rg -l \u0026#34;TODO\u0026#34; 在特定类型的文件中搜索\n1 2 3 4 5 # 只在 python 文件中搜索 \u0026#34;import\u0026#34; rg \u0026#34;import\u0026#34; -t py # 不在 javascript 文件中搜索 \u0026#34;console.log\u0026#34; rg \u0026#34;console.log\u0026#34; -g \u0026#39;!*.js\u0026#39; 显示上下文\n1 2 # 显示匹配行的前后各 2 行 rg -C 2 \u0026#34;important_function\u0026#34; 统计匹配数量\n1 rg --count \u0026#34;User\u0026#34; 三者合璧：黄金组合 这三个工具的真正威力在于通过管道 (|) 结合，形成强大的工作流。\n场景1：查找一个项目中的配置文件，然后交互式选择并打开。\nfd 负责快速找出所有 .conf 文件。 fzf 负责提供交互界面让你选择。 vim 负责打开你选择的文件。 1 2 3 4 5 # 1. fd 找到所有以 .conf 结尾的文件 # 2. | 将结果传给 fzf # 3. fzf 让你模糊搜索并选择一个 # 4. vim 打开最终选定的文件 vim $(fd -e conf | fzf) 场景2：在代码库中搜索一个函数，然后交互式地预览并跳转到该行。\n这是最强大的组合之一，需要 fzf 的预览功能。\nrg 负责搜索函数名，并输出 文件名:行号:内容。 fzf 负责交互选择，并使用 --preview 功能实时显示文件上下文。 vim/vscode 等编辑器负责打开文件并跳转到指定行。 1 2 3 4 5 # rg 搜索 \u0026#34;function_name\u0026#34;，--vimgrep 格式化输出 # fzf 读取结果，并使用 bat (一个带高亮的 cat) 来预览文件 # {1} 是文件名, {2} 是行号 rg --vimgrep \u0026#34;function_name\u0026#34; | \\ fzf --preview \u0026#39;bat --color=always --highlight-line {2} {1}\u0026#39; 当你选中一项后，可以进一步处理 fzf 的输出，提取文件名和行号，然后用编辑器打开。例如：\n1 2 3 4 5 # 选中后，提取文件名和行号，用 vim 打开并跳转 ITEM=$(rg --vimgrep \u0026#34;my_api_key\u0026#34; | fzf) FILE=$(echo $ITEM | cut -d: -f1) LINE=$(echo $ITEM | cut -d: -f2) [ -n \u0026#34;$FILE\u0026#34; ] \u0026amp;\u0026amp; vim \u0026#34;$FILE\u0026#34; +$LINE 总结表格 工具 核心功能 经典替代品 关键优势 fzf 交互式选择 (无直接替代) 模糊搜索、万物皆可过滤、高度集成 fd 查找文件/目录 find 语法简单、速度快、智能忽略 rg 搜索文件内容 grep, ack, ag 速度极快、智能忽略、输出友好 ","date":"2025-10-24T09:38:06+08:00","permalink":"https://demo.stack.jimmycai.com/post/fzf-fd-rg/","title":"Fzf Fd Rg"},{"content":"代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 `timescale 1 ns / 1 ps module myip_slave_lite_v1_0_S00_AXI # ( // Users to add parameters here // User parameters ends // Do not modify the parameters beyond this line // Width of S_AXI data bus parameter integer C_S_AXI_DATA_WIDTH\t= 32, // Width of S_AXI address bus parameter integer C_S_AXI_ADDR_WIDTH\t= 4 ) ( // Users to add ports here // User ports ends // Do not modify the ports beyond this line // Global Clock Signal input wire S_AXI_ACLK, // Global Reset Signal. This Signal is Active LOW input wire S_AXI_ARESETN, // Write address (issued by master, acceped by Slave) input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR, // Write channel Protection type. This signal indicates the // privilege and security level of the transaction, and whether // the transaction is a data access or an instruction access. input wire [2 : 0] S_AXI_AWPROT, // Write address valid. This signal indicates that the master signaling // valid write address and control information. input wire S_AXI_AWVALID, // Write address ready. This signal indicates that the slave is ready // to accept an address and associated control signals. output wire S_AXI_AWREADY, // Write data (issued by master, acceped by Slave) input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA, // Write strobes. This signal indicates which byte lanes hold // valid data. There is one write strobe bit for each eight // bits of the write data bus. input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB, // Write valid. This signal indicates that valid write // data and strobes are available. input wire S_AXI_WVALID, // Write ready. This signal indicates that the slave // can accept the write data. output wire S_AXI_WREADY, // Write response. This signal indicates the status // of the write transaction. output wire [1 : 0] S_AXI_BRESP, // Write response valid. This signal indicates that the channel // is signaling a valid write response. output wire S_AXI_BVALID, // Response ready. This signal indicates that the master // can accept a write response. input wire S_AXI_BREADY, // Read address (issued by master, acceped by Slave) input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR, // Protection type. This signal indicates the privilege // and security level of the transaction, and whether the // transaction is a data access or an instruction access. input wire [2 : 0] S_AXI_ARPROT, // Read address valid. This signal indicates that the channel // is signaling valid read address and control information. input wire S_AXI_ARVALID, // Read address ready. This signal indicates that the slave is // ready to accept an address and associated control signals. output wire S_AXI_ARREADY, // Read data (issued by slave) output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA, // Read response. This signal indicates the status of the // read transfer. output wire [1 : 0] S_AXI_RRESP, // Read valid. This signal indicates that the channel is // signaling the required read data. output wire S_AXI_RVALID, // Read ready. This signal indicates that the master can // accept the read data and response information. input wire S_AXI_RREADY ); // AXI4LITE signals reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_awaddr; reg axi_awready; reg axi_wready; reg [1 : 0] axi_bresp; reg axi_bvalid; reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_araddr; reg axi_arready; reg [1 : 0] axi_rresp; reg axi_rvalid; // Example-specific design signals // local parameter for addressing 32 bit / 64 bit C_S_AXI_DATA_WIDTH // ADDR_LSB is used for addressing 32/64 bit registers/memories // ADDR_LSB = 2 for 32 bits (n downto 2) // ADDR_LSB = 3 for 64 bits (n downto 3) localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1; localparam integer OPT_MEM_ADDR_BITS = 1; //---------------------------------------------- //-- Signals for user logic register space example //------------------------------------------------ //-- Number of Slave Registers 4 reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg0; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg1; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg2; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg3; integer\tbyte_index; // I/O Connections assignments assign S_AXI_AWREADY\t= axi_awready; assign S_AXI_WREADY\t= axi_wready; assign S_AXI_BRESP\t= axi_bresp; assign S_AXI_BVALID\t= axi_bvalid; assign S_AXI_ARREADY\t= axi_arready; assign S_AXI_RRESP\t= axi_rresp; assign S_AXI_RVALID\t= axi_rvalid; //state machine varibles reg [1:0] state_write; reg [1:0] state_read; //State machine local parameters localparam Idle = 2\u0026#39;b00,Raddr = 2\u0026#39;b10,Rdata = 2\u0026#39;b11 ,Waddr = 2\u0026#39;b10,Wdata = 2\u0026#39;b11; // Implement Write state machine // Outstanding write transactions are not supported by the slave i.e., master should assert bready to receive response on or before it starts sending the new transaction always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1\u0026#39;b0) begin axi_awready \u0026lt;= 0; axi_wready \u0026lt;= 0; axi_bvalid \u0026lt;= 0; axi_bresp \u0026lt;= 0; axi_awaddr \u0026lt;= 0; state_write \u0026lt;= Idle; end else begin case(state_write) Idle: begin if(S_AXI_ARESETN == 1\u0026#39;b1) begin axi_awready \u0026lt;= 1\u0026#39;b1; axi_wready \u0026lt;= 1\u0026#39;b1; state_write \u0026lt;= Waddr; end else state_write \u0026lt;= state_write; end Waddr: //At this state, slave is ready to receive address along with corresponding control signals and first data packet. Response valid is also handled at this state begin if (S_AXI_AWVALID \u0026amp;\u0026amp; S_AXI_AWREADY) begin axi_awaddr \u0026lt;= S_AXI_AWADDR; if(S_AXI_WVALID) begin axi_awready \u0026lt;= 1\u0026#39;b1; state_write \u0026lt;= Waddr; axi_bvalid \u0026lt;= 1\u0026#39;b1; end else begin axi_awready \u0026lt;= 1\u0026#39;b0; state_write \u0026lt;= Wdata; if (S_AXI_BREADY \u0026amp;\u0026amp; axi_bvalid) axi_bvalid \u0026lt;= 1\u0026#39;b0; end end else begin state_write \u0026lt;= state_write; if (S_AXI_BREADY \u0026amp;\u0026amp; axi_bvalid) axi_bvalid \u0026lt;= 1\u0026#39;b0; end end Wdata: //At this state, slave is ready to receive the data packets until the number of transfers is equal to burst length begin if (S_AXI_WVALID) begin state_write \u0026lt;= Waddr; axi_bvalid \u0026lt;= 1\u0026#39;b1; axi_awready \u0026lt;= 1\u0026#39;b1; end else begin state_write \u0026lt;= state_write; if (S_AXI_BREADY \u0026amp;\u0026amp; axi_bvalid) axi_bvalid \u0026lt;= 1\u0026#39;b0; end end endcase end end // Implement memory mapped register select and write logic generation // The write data is accepted and written to memory mapped registers when // axi_awready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted. Write strobes are used to // select byte enables of slave registers while writing. // These registers are cleared when reset (active low) is applied. // Slave register write enable is asserted when valid address and data are available // and the slave is ready to accept the write address and write data. always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1\u0026#39;b0 ) begin slv_reg0 \u0026lt;= 0; slv_reg1 \u0026lt;= 0; slv_reg2 \u0026lt;= 0; slv_reg3 \u0026lt;= 0; end else begin if (S_AXI_WVALID) begin case ( (S_AXI_AWVALID) ? S_AXI_AWADDR[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] : axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] ) 2\u0026#39;h0: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 0 slv_reg0[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end 2\u0026#39;h1: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 1 slv_reg1[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end 2\u0026#39;h2: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 2 slv_reg2[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end 2\u0026#39;h3: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 3 slv_reg3[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end default : begin slv_reg0 \u0026lt;= slv_reg0; slv_reg1 \u0026lt;= slv_reg1; slv_reg2 \u0026lt;= slv_reg2; slv_reg3 \u0026lt;= slv_reg3; end endcase end end end // Implement read state machine always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1\u0026#39;b0) begin //asserting initial values to all 0\u0026#39;s during reset axi_arready \u0026lt;= 1\u0026#39;b0; axi_rvalid \u0026lt;= 1\u0026#39;b0; axi_rresp \u0026lt;= 1\u0026#39;b0; state_read \u0026lt;= Idle; end else begin case(state_read) Idle: //Initial state inidicating reset is done and ready to receive read/write transactions begin if (S_AXI_ARESETN == 1\u0026#39;b1) begin state_read \u0026lt;= Raddr; axi_arready \u0026lt;= 1\u0026#39;b1; end else state_read \u0026lt;= state_read; end Raddr: //At this state, slave is ready to receive address along with corresponding control signals begin if (S_AXI_ARVALID \u0026amp;\u0026amp; S_AXI_ARREADY) begin state_read \u0026lt;= Rdata; axi_araddr \u0026lt;= S_AXI_ARADDR; axi_rvalid \u0026lt;= 1\u0026#39;b1; axi_arready \u0026lt;= 1\u0026#39;b0; end else state_read \u0026lt;= state_read; end Rdata: //At this state, slave is ready to send the data packets until the number of transfers is equal to burst length begin if (S_AXI_RVALID \u0026amp;\u0026amp; S_AXI_RREADY) begin axi_rvalid \u0026lt;= 1\u0026#39;b0; axi_arready \u0026lt;= 1\u0026#39;b1; state_read \u0026lt;= Raddr; end else state_read \u0026lt;= state_read; end endcase end end // Implement memory mapped register select and read logic generation assign S_AXI_RDATA = (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2\u0026#39;h0) ? slv_reg0 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2\u0026#39;h1) ? slv_reg1 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2\u0026#39;h2) ? slv_reg2 : (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2\u0026#39;h3) ? slv_reg3 : 0; // Add user logic here // User logic ends endmodule ","date":"2025-10-24T09:13:35+08:00","permalink":"https://demo.stack.jimmycai.com/post/axi4lite/","title":"Axi4lite"},{"content":"太棒了！让我们从绝对的第一性原理出发，彻底搞懂AXI，然后一步步将它与你的PWM设计融合，完成一次工业级的IP封装。\n第一性原理：AXI是什么，它到底解决了什么问题？ 想象一下，你的Zynq芯片里有一个国王（CPU / PS）和很多工匠（你的PWM模块、DMA、GPIO等 / PL）。\n问题：国王只有一个，但他需要同时对很多工匠下达指令（“PWM模块，把周期设为1000”，“DMA，把这段数据搬走”）。如果每个工匠都有一根专线连到国王那里，那国王身上就要插无数根线，这显然不现实。\n解决方案：建立一个**“中央邮政系统”。所有工匠都在这个系统里注册一个唯一的“邮箱地址”**。国王想给谁下指令，只需要写一封信，写上“收件人地址”和“信件内容”，然后扔进邮政系统。邮政系统会负责把信送到正确的工匠手里。\n这个**“中央邮政系统”，在我们的芯片世界里，就是总线（Bus）。 这个“写信、送信、收信的规则”，就是协议（Protocol）**。\nAXI (Advanced eXtensible Interface) 就是ARM公司定义的一套非常流行、非常高效的“邮政系统规则”。\nAXI4-Lite: 轻量级的信件服务 AXI有很多版本，我们封装PWM这样的控制模块，只需要最简单的一种：AXI4-Lite。你可以把它理解为专门用来收发**“短信”或“明信片”**的系统，每次只传递少量（32位/64位）的数据，非常适合用来读写配置寄存器。\nAXI的核心交互：握手（Handshake） AXI协议的灵魂是**“VALID/READY”握手机制**。忘掉所有复杂的信号，只记住这一点：\nVALID (有效信号): 由发送方控制。当发送方把数据/地址准备好后，它就拉高VALID，大声宣布：“我的信息已经准备好了，并且稳定不变！” READY (就绪信号): 由接收方控制。当接收方有能力接收信息时，它就拉高READY，大声回应：“我准备好了，请把信息发给我！” 黄金法则： 只有在一个时钟上升沿，当VALID和READY同时为高时，一次有效的数据传输（或地址传输）才会发生。\n这个机制极其强大，它完美地解决了快慢设备之间的通信问题。快的设备可以等慢的设备READY，慢的设备也可以等快的设备VALID。\nAXI4-Lite的五个“通信渠道” AXI4-Lite把一次完整的读/写操作分成了几个独立的渠道，就像邮局把寄信和收信流程分开一样：\n写地址渠道 (Write Address Channel - AW): 国王（Master）告诉邮局（Interconnect）要把信送到哪个地址（AWADDR）。 写数据渠道 (Write Data Channel - W): 国王把信的内容（WDATA）交给邮局。 写响应渠道 (Write Response Channel - B): 邮局告诉国王，信送到了（BRESP），任务完成。 读地址渠道 (Read Address Channel - AR): 国王告诉邮局，他想从哪个地址取信（ARADDR）。 读数据渠道 (Read Data Channel - R): 邮局把取回来的信的内容（RDATA）交给国王。 每个渠道都有自己的VALID/READY握手信号（例如AWVALID/AWREADY）。\n我们自己设计PWM模块时，只需要扮演“工匠”（Slave）的角色，响应国王的指令。幸运的是，Vivado工具可以自动帮我们生成处理这些复杂握手逻辑的“秘书”，我们只需要和“秘书”对话就行了。\n实战：引导你完成AXI + PWM的IP封装 现在，我们把上面的理论应用到你的pwm.sv上。\n核心思想转变 旧思想：period, duty1, duty2, duty3 是物理输入端口，由外部的GPIO硬连线驱动。 新思想：period, duty1, duty2, duty3 是寄存器，它们是存在于你的IP核内部的“邮箱”。CPU通过AXI总线，使用不同的地址来写入这些“邮箱”。 步骤一：召唤“秘书”——使用IP Packager向导 在Vivado中，Tools -\u0026gt; Create and Package New IP -\u0026gt; Next。 选择 Create a new AXI4 peripheral -\u0026gt; Next。 信息填写： Name: pwm_axi (或者你喜欢的名字) Version: 1.0 Display Name: My PWM Controller with AXI 接口配置 (最关键的一步)： Interface Type: AXI4-Lite (我们的“短信服务”) Interface Mode: Slave (我们是“工匠”，被动接收指令) Data Width: 32 (AXI总线标准宽度) Number of Registers: 我们需要4个参数 (period, duty1, duty2, duty3)。所以这里填 4。这会自动为我们创建4个32位的可读写寄存器（“邮箱”）。 点击Next，然后Finish。Vivado会为你创建一个全新的项目，里面包含了所有AXI接口的“秘书”代码。 步骤二：介绍你的PWM给“秘书” 现在你进入了IP封装项目。\n添加你的代码：在Sources窗口中，右键 Add Sources，把你写好的 pwm.sv 文件添加进来。 打开“秘书”的办公室：在Sources中，找到并打开顶层文件，名字通常是 pwm_axi_v1_0_S00_AXI.v 或 .sv。 步骤三：连接PWM和“秘书” 在这个自动生成的顶层文件中，向下滚动，你会找到这样几行代码，它们就是“秘书”为你准备好的“邮箱”（寄存器）：\n1 2 3 4 5 // User logic registers reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg0; reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg1; reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg2; reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg3; slv_reg0 就是地址 0x00 对应的邮箱。 slv_reg1 就是地址 0x04 对应的邮箱。 \u0026hellip;以此类推。 现在，我们要做的就是在文件的末尾（endmodule之前），把你的PWM模块例化出来，并把这些“邮箱”连接到它的输入端口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 在 ..._S00_AXI.v 文件末尾添加以下代码 // 1. 例化你的PWM模块 pwm pwm_inst ( // .clk(clk), -\u0026gt; 应该连接到AXI总线的时钟 .clk(S_AXI_ACLK), // .rst(rst), -\u0026gt; 应该连接到AXI总线的复位 // 注意：AXI复位通常是低电平有效(ARESETN)，而你的模块可能是高电平有效。 // 如果你的复位是高电平有效，需要加一个非门。 .rst(!S_AXI_ARESETN), // 2. 将寄存器（邮箱）连接到PWM的参数输入 // 我们只关心寄存器的低16位，因为你的参数是16位的 .period(slv_reg0[15:0]), .duty1 (slv_reg1[15:0]), .duty2 (slv_reg2[15:0]), .duty3 (slv_reg3[15:0]), // 3. 将PWM的输出引出到IP核的顶层 .pwm1(pwm1_out), .pwm2(pwm2_out), .pwm3(pwm3_out) ); // 4. 在文件顶部声明这些输出信号，让它们成为IP核的物理端口 // 找到模块的端口声明区域，添加以下几行： /* module pwm_axi_v1_0_S00_AXI # (... ) ( // ... 已有的AXI端口 ... output logic pwm1_out, output logic pwm2_out, output logic pwm3_out, // ... ); */ 画龙点睛（可选但强烈推荐）：实现状态回读\nAXI不仅能写，还能读。我们可以让CPU读回PWM内部的计数器值，这对于调试非常有用。\n修改pwm.sv: 给你的PWM模块增加一个输出端口 output logic [15:0] counter_value，并把内部的counter赋给它。 在..._S00_AXI.v中：找到负责读操作的逻辑。通常会有一段 case 语句，根据读地址 axi_araddr 来选择输出哪个寄存器的数据。你可以在这里添加逻辑，当CPU读取某个特定地址（比如slv_reg0的地址）时，不返回slv_reg0的值，而是返回counter_value。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 示例： always @( posedge S_AXI_ACLK ) begin if (slv_reg_rden) // 如果有读请求 begin case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] ) 2\u0026#39;h0: reg_data_out \u0026lt;= counter_value_from_pwm; // 读地址0时，返回计数器值 2\u0026#39;h1: reg_data_out \u0026lt;= slv_reg1; // 读地址1时，返回duty1的设置值 2\u0026#39;h2: reg_data_out \u0026lt;= slv_reg2; 2\u0026#39;h3: reg_data_out \u0026lt;= slv_reg3; default : reg_data_out \u0026lt;= 0; endcase end end // 你需要先用线把pwm_inst的counter_value输出连接到一个叫counter_value_from_pwm的信号上。 步骤四：打包和发布 切换到 Package IP 标签页。 检查 File Groups，确保你的pwm.sv已经被正确识别并添加。 检查 Customization Parameters 和 Ports and Interfaces，确认一切无误。 点击 Review and Package -\u0026gt; Package IP。 恭喜！ 你已经成功地将一个纯逻辑模块，封装成了一个符合工业标准的、带AXI接口的、可复用的IP核。现在你可以回到你的主项目中，在IP Catalog里找到它，将它拖入Block Design，你会看到一个干净、专业的模块，它有一个AXI接口和三个PWM输出物理端口。\n","date":"2025-10-23T22:40:54+08:00","permalink":"https://demo.stack.jimmycai.com/post/%E4%BB%A5pwm%E4%B8%BA%E4%BE%8B%E5%AE%9E%E7%8E%B0axi%E7%9A%84ip%E5%B0%81%E8%A3%85/","title":"以pwm为例实现axi的ip封装(created by gemini)"},{"content":"优质blog ustc:axi4总线\nustc:cecs2023 计算机综合实验\n状态设计之我见：\n我从你的分析视角看到了我之前缺略的一个思路，就是很好的区分了边界和状态。简而言之，边界之间是状态。然而对于一般的设计，边界是易于表达的，而状态是易于理解的。以周期的计算来说，边界就是counter这个计数器构成了0，1，2\u0026mdash;n-1这个n个边界点，其中存在突变点m。但是边界点却不能直观看出时间，我们将两个边界之间的点定义为状态。一般来说，每个状态的参数是相同的（比如每个状态的时间).然后我们就去计算我们要去讨论的大状态包含的基状态，比如一个周期包含的基状态，一个周期中上升沿包含的基状态。而基状态的研究只需要看大状态对应的边界点就行了\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //pwm.sv // 1个端口控制输出pwm的周期，3个输入端口分别控制3个输出端口的占空比 module pwm ( input logic clk, input logic [15:0] period, input logic [15:0] duty1, input logic [15:0] duty2, input logic [15:0] duty3, input logic rst, output logic pwm1, output logic pwm2, output logic pwm3 ); logic [15:0] counter = 0; always_ff @(posedge clk, negedge rst) begin : pwm_block if (!rst) begin counter \u0026lt;= 0; end else begin if (counter \u0026lt; period - 1) counter \u0026lt;= counter + 1; else counter \u0026lt;= 0; //pmw1 end end always_comb begin if (counter \u0026lt; duty1) begin pwm1 = 0; end else begin pwm1 = 1; end if (counter \u0026lt; duty2) begin pwm2 = 0; end else begin pwm2 = 1; end if (counter \u0026lt; duty3) begin pwm3 = 0; end else begin pwm3 = 1; end end endmodule // 注：这个代码写的并不规范，应该把组合逻辑部分放到时序部分变成同步更新，减少毛刺 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //tb_pwm.sv module tb_pwm (); parameter real CLK_PERIOD = 10; //假设时钟周期为10ns logic clk; logic [15:0] period; logic [15:0] duty1; logic [15:0] duty2; logic [15:0] duty3; logic rst; logic pwm1; logic pwm2; logic pwm3; pwm dut_pwm ( .clk(clk), .period(period), .duty1(duty1), .duty2(duty2), .duty3(duty3), .rst(rst), .pwm1(pwm1), .pwm2(pwm2), .pwm3(pwm3) ); initial begin clk = 0; end always begin #(CLK_PERIOD / 2) clk = ~clk; end initial begin rst = 1; @(posedge clk); period = 10; duty1 = 2; duty2 = 4; duty3 = 6; repeat (1000) @(posedge clk) ; $finish; end endmodule PS 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 //ps 端通过uart控制占空比 //ps 端通过uart控制占空比 #include \u0026#34;xparameters.h\u0026#34; #include \u0026#34;xil_io.h\u0026#34; #include \u0026#34;xuartlite.h\u0026#34; #include \u0026#34;xuartlite_l.h\u0026#34; #include \u0026#34;xuartlite_i.h\u0026#34; #define period_offset 0x00 #define duty1_offset 0x04 #define duty2_offset 0x08 #define duty3_offset 0x0c int main(void){ //uartlite XUartLite uartlite0; XUartLite_Initialize(\u0026amp;uartlite0,XPAR_XUARTLITE_0_BASEADDR); u8 recv_package[8]; u8 send_package[8]={\u0026#39;i\u0026#39;,\u0026#39;n\u0026#39;}; //XUartLite_Send(\u0026amp;uartlite0,send_package,2); // T=period/fclk // 由于设计失误,duty1,2,3分别表示一个周期内低电平的状态数 u32 period=1000; u32 duty1=600; u32 duty2=400; u32 duty3=200; Xil_Out32(XPAR_PWM_IP_0_BASEADDR+period_offset,period); Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty1_offset,duty1); Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty2_offset,duty2); Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty3_offset,duty3); while(1) { XUartLite_Send(\u0026amp;uartlite0,send_package,2); //XUartLite_Send(\u0026amp;uartlite0,send_package,2); recv_package[0]=XUartLite_RecvByte(XPAR_XUARTLITE_0_BASEADDR); XUartLite_Send(\u0026amp;uartlite0,send_package,2); recv_package[1]=XUartLite_RecvByte(XPAR_XUARTLITE_0_BASEADDR); recv_package[2]=XUartLite_RecvByte(XPAR_XUARTLITE_0_BASEADDR); //XUartLite_Recv(\u0026amp;uartlite0,recv_package,3); XUartLite_Send(\u0026amp;uartlite0,send_package,2); u32 sum=10*(recv_package[1]-\u0026#39;0\u0026#39;)+(recv_package[2]-\u0026#39;0\u0026#39;); u32 duty=period-period*sum/100; if(recv_package[0]==\u0026#39;1\u0026#39;) { duty1=duty; Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty1_offset,duty1); } else if(recv_package[0]==\u0026#39;2\u0026#39;) { duty2=duty; Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty2_offset,duty2); } else { duty3=duty; Xil_Out32(XPAR_PWM_IP_0_BASEADDR+duty3_offset,duty3); } } } AXI ","date":"2025-10-23T21:46:18+08:00","permalink":"https://demo.stack.jimmycai.com/post/zynq-pwm/","title":"Zynq Pwm"},{"content":"参考文章：VHDL whiz\n","date":"2025-10-23T09:56:10+08:00","permalink":"https://demo.stack.jimmycai.com/post/ready-valid/","title":"Ready Valid"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/post/markdown-syntax/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://demo.stack.jimmycai.com/post/image-gallery/2_hu_3e58a979f20e4e46.jpg","permalink":"https://demo.stack.jimmycai.com/post/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://demo.stack.jimmycai.com/post/shortcodes/cover_hu_5667347daefb4230.jpg","permalink":"https://demo.stack.jimmycai.com/post/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/post/math-typesetting/","title":"Math Typesetting"}]